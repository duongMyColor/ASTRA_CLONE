var __create = Object.create;
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb2, mod) => function __require2() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __template = (cooked, raw3) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw3 || cooked.slice()) }));

// .wrangler/tmp/bundle-NyGiPh/checked-fetch.js
function checkURL(request, init2) {
  const url = request instanceof URL ? request : new URL(
    (typeof request === "string" ? new Request(request, init2) : request).url
  );
  if (url.port && url.port !== "443" && url.protocol === "https:") {
    if (!urls.has(url.toString())) {
      urls.add(url.toString());
      console.warn(
        `WARNING: known issue with \`fetch()\` requests to custom HTTPS ports in published Workers:
 - ${url.toString()} - the custom port will be ignored when the Worker is published using the \`wrangler deploy\` command.
`
      );
    }
  }
}
var urls;
var init_checked_fetch = __esm({
  ".wrangler/tmp/bundle-NyGiPh/checked-fetch.js"() {
    "use strict";
    urls = /* @__PURE__ */ new Set();
    globalThis.fetch = new Proxy(globalThis.fetch, {
      apply(target, thisArg, argArray) {
        const [request, init2] = argArray;
        checkURL(request, init2);
        return Reflect.apply(target, thisArg, argArray);
      }
    });
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_checked_fetch();
    init_modules_watch_stub();
  }
});

// ../../node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "../../node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// src/core/statusCodes.ts
var statusCodes, statusCodes_default;
var init_statusCodes = __esm({
  "src/core/statusCodes.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    statusCodes = {
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.2.1
       *
       * This interim response indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.
       */
      CONTINUE: 100,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.2.2
       *
       * This code is sent in response to an Upgrade request header by the client, and indicates the protocol the server is switching too.
       */
      SWITCHING_PROTOCOLS: 101,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.1
       *
       * This code indicates that the server has received and is processing the request, but no response is available yet.
       */
      PROCESSING: 102,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.1
       *
       * The request has succeeded. The meaning of a success varies depending on the HTTP method:
       * GET: The resource has been fetched and is transmitted in the message body.
       * HEAD: The entity headers are in the message body.
       * POST: The resource describing the result of the action is transmitted in the message body.
       * TRACE: The message body contains the request message as received by the server
       */
      OK: 200,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.2
       *
       * The request has succeeded and a new resource has been created as a result of it. This is typically the response sent after a PUT request.
       */
      CREATED: 201,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.3
       *
       * The request has been received but not yet acted upon. It is non-committal, meaning that there is no way in HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.
       */
      ACCEPTED: 202,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.4
       *
       * This response code means returned meta-information set is not exact set as available from the origin server, but collected from a local or a third party copy. Except this condition, 200 OK response should be preferred instead of this response.
       */
      NON_AUTHORITATIVE_INFORMATION: 203,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.5
       *
       * There is no content to send for this request, but the headers may be useful. The user-agent may update its cached headers for this resource with the new ones.
       */
      NO_CONTENT: 204,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.6
       *
       * This response code is sent after accomplishing request to tell user agent reset document view which sent this request.
       */
      RESET_CONTENT: 205,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7233#section-4.1
       *
       * This response code is used because of range header sent by the client to separate download into multiple streams.
       */
      PARTIAL_CONTENT: 206,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.2
       *
       * A Multi-Status response conveys information about multiple resources in situations where multiple status codes might be appropriate.
       */
      MULTI_STATUS: 207,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.1
       *
       * The request has more than one possible responses. User-agent or user should choose one of them. There is no standardized way to choose one of the responses.
       */
      MULTIPLE_CHOICES: 300,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.2
       *
       * This response code means that URI of requested resource has been changed. Probably, new URI would be given in the response.
       */
      MOVED_PERMANENTLY: 301,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.3
       *
       * This response code means that URI of requested resource has been changed temporarily. New changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.
       */
      MOVED_TEMPORARILY: 302,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.4
       *
       * Server sent this response to directing client to get requested resource to another URI with an GET request.
       */
      SEE_OTHER: 303,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7232#section-4.1
       *
       * This is used for caching purposes. It is telling to client that response has not been modified. So, client can continue to use same cached version of response.
       */
      NOT_MODIFIED: 304,
      /**
       * @deprecated
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.6
       *
       * Was defined in a previous version of the HTTP specification to indicate that a requested response must be accessed by a proxy. It has been deprecated due to security concerns regarding in-band configuration of a proxy.
       */
      USE_PROXY: 305,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.7
       *
       * Server sent this response to directing client to get requested resource to another URI with same method that used prior request. This has the same semantic than the 302 Found HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.
       */
      TEMPORARY_REDIRECT: 307,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7538#section-3
       *
       * This means that the resource is now permanently located at another URI, specified by the Location: HTTP Response header. This has the same semantics as the 301 Moved Permanently HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.
       */
      PERMANENT_REDIRECT: 308,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.1
       *
       * This response means that server could not understand the request due to invalid syntax.
       */
      BAD_REQUEST: 400,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7235#section-3.1
       *
       * Although the HTTP standard specifies "unauthorized", semantically this response means "unauthenticated". That is, the client must authenticate itself to get the requested response.
       */
      UNAUTHORIZED: 401,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.2
       *
       * This response code is reserved for future use. Initial aim for creating this code was using it for digital payment systems however this is not used currently.
       */
      PAYMENT_REQUIRED: 402,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.3
       *
       * The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server.
       */
      FORBIDDEN: 403,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.4
       *
       * The server can not find requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurence on the web.
       */
      NOT_FOUND: 404,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.5
       *
       * The request method is known by the server but has been disabled and cannot be used. For example, an API may forbid DELETE-ing a resource. The two mandatory methods, GET and HEAD, must never be disabled and should not return this error code.
       */
      METHOD_NOT_ALLOWED: 405,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.6
       *
       * This response is sent when the web server, after performing server-driven content negotiation, doesn't find any content following the criteria given by the user agent.
       */
      NOT_ACCEPTABLE: 406,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7235#section-3.2
       *
       * This is similar to 401 but authentication is needed to be done by a proxy.
       */
      PROXY_AUTHENTICATION_REQUIRED: 407,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.7
       *
       * This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome, Firefox 27+, or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers merely shut down the connection without sending this message.
       */
      REQUEST_TIMEOUT: 408,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.8
       *
       * This response is sent when a request conflicts with the current state of the server.
       */
      CONFLICT: 409,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.9
       *
       * This response would be sent when the requested content has been permenantly deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for "limited-time, promotional services". APIs should not feel compelled to indicate resources that have been deleted with this status code.
       */
      GONE: 410,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.10
       *
       * The server rejected the request because the Content-Length header field is not defined and the server requires it.
       */
      LENGTH_REQUIRED: 411,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7232#section-4.2
       *
       * The client has indicated preconditions in its headers which the server does not meet.
       */
      PRECONDITION_FAILED: 412,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.11
       *
       * Request entity is larger than limits defined by server; the server might close the connection or return an Retry-After header field.
       */
      REQUEST_TOO_LONG: 413,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.12
       *
       * The URI requested by the client is longer than the server is willing to interpret.
       */
      REQUEST_URI_TOO_LONG: 414,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.13
       *
       * The media format of the requested data is not supported by the server, so the server is rejecting the request.
       */
      UNSUPPORTED_MEDIA_TYPE: 415,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7233#section-4.4
       *
       * The range specified by the Range header field in the request can't be fulfilled; it's possible that the range is outside the size of the target URI's data.
       */
      REQUESTED_RANGE_NOT_SATISFIABLE: 416,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.14
       *
       * This response code means the expectation indicated by the Expect request header field can't be met by the server.
       */
      EXPECTATION_FAILED: 417,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2324#section-2.3.2
       *
       * Any attempt to brew coffee with a teapot should result in the error code "418 I'm a teapot". The resulting entity body MAY be short and stout.
       */
      IM_A_TEAPOT: 418,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.6
       *
       * The 507 (Insufficient Storage) status code means the method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request. This condition is considered to be temporary. If the request which received this status code was the result of a user action, the request MUST NOT be repeated until it is requested by a separate user action.
       */
      INSUFFICIENT_SPACE_ON_RESOURCE: 419,
      /**
       * @deprecated
       * Official Documentation @ https://tools.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-webdav-protocol-06.txt
       *
       * A deprecated response used by the Spring Framework when a method has failed.
       */
      METHOD_FAILURE: 420,
      /**
       * Official Documentation @ https://datatracker.ietf.org/doc/html/rfc7540#section-9.1.2
       *
       * Defined in the specification of HTTP/2 to indicate that a server is not able to produce a response for the combination of scheme and authority that are included in the request URI.
       */
      MISDIRECTED_REQUEST: 421,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.3
       *
       * The request was well-formed but was unable to be followed due to semantic errors.
       */
      UNPROCESSABLE_ENTITY: 422,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.4
       *
       * The resource that is being accessed is locked.
       */
      LOCKED: 423,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.5
       *
       * The request failed due to failure of a previous request.
       */
      FAILED_DEPENDENCY: 424,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-3
       *
       * The origin server requires the request to be conditional. Intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.
       */
      PRECONDITION_REQUIRED: 428,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-4
       *
       * The user has sent too many requests in a given amount of time ("rate limiting").
       */
      TOO_MANY_REQUESTS: 429,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-5
       *
       * The server is unwilling to process the request because its header fields are too large. The request MAY be resubmitted after reducing the size of the request header fields.
       */
      REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7725
       *
       * The user-agent requested a resource that cannot legally be provided, such as a web page censored by a government.
       */
      UNAVAILABLE_FOR_LEGAL_REASONS: 451,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.1
       *
       * The server encountered an unexpected condition that prevented it from fulfilling the request.
       */
      INTERNAL_SERVER_ERROR: 500,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.2
       *
       * The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are GET and HEAD.
       */
      NOT_IMPLEMENTED: 501,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.3
       *
       * This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response.
       */
      BAD_GATEWAY: 502,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.4
       *
       * The server is not ready to handle the request. Common causes are a server that is down for maintenance or that is overloaded. Note that together with this response, a user-friendly page explaining the problem should be sent. This responses should be used for temporary conditions and the Retry-After: HTTP header should, if possible, contain the estimated time before the recovery of the service. The webmaster must also take care about the caching-related headers that are sent along with this response, as these temporary condition responses should usually not be cached.
       */
      SERVICE_UNAVAILABLE: 503,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.5
       *
       * This error response is given when the server is acting as a gateway and cannot get a response in time.
       */
      GATEWAY_TIMEOUT: 504,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.6
       *
       * The HTTP version used in the request is not supported by the server.
       */
      HTTP_VERSION_NOT_SUPPORTED: 505,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.6
       *
       * The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.
       */
      INSUFFICIENT_STORAGE: 507,
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-6
       *
       * The 511 status code indicates that the client needs to authenticate to gain network access.
       */
      NETWORK_AUTHENTICATION_REQUIRED: 511
    };
    statusCodes_default = statusCodes;
  }
});

// src/core/reasonPhrases.ts
var reasonPhrases, reasonPhrases_default;
var init_reasonPhrases = __esm({
  "src/core/reasonPhrases.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    reasonPhrases = {
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.3
       *
       * The request has been received but not yet acted upon. It is non-committal, meaning that there is no way in HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.
       */
      ACCEPTED: "Accepted",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.3
       *
       * This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response.
       */
      BAD_GATEWAY: "Bad Gateway",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.1
       *
       * This response means that server could not understand the request due to invalid syntax.
       */
      BAD_REQUEST: "Bad Request",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.8
       *
       * This response is sent when a request conflicts with the current state of the server.
       */
      CONFLICT: "Conflict",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.2.1
       *
       * This interim response indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.
       */
      CONTINUE: "Continue",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.2
       *
       * The request has succeeded and a new resource has been created as a result of it. This is typically the response sent after a PUT request.
       */
      CREATED: "Created",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.14
       *
       * This response code means the expectation indicated by the Expect request header field can't be met by the server.
       */
      EXPECTATION_FAILED: "Expectation Failed",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.5
       *
       * The request failed due to failure of a previous request.
       */
      FAILED_DEPENDENCY: "Failed Dependency",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.3
       *
       * The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server.
       */
      FORBIDDEN: "Forbidden",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.5
       *
       * This error response is given when the server is acting as a gateway and cannot get a response in time.
       */
      GATEWAY_TIMEOUT: "Gateway Timeout",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.9
       *
       * This response would be sent when the requested content has been permenantly deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for "limited-time, promotional services". APIs should not feel compelled to indicate resources that have been deleted with this status code.
       */
      GONE: "Gone",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.6
       *
       * The HTTP version used in the request is not supported by the server.
       */
      HTTP_VERSION_NOT_SUPPORTED: "HTTP Version Not Supported",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2324#section-2.3.2
       *
       * Any attempt to brew coffee with a teapot should result in the error code "418 I'm a teapot". The resulting entity body MAY be short and stout.
       */
      IM_A_TEAPOT: "I'm a teapot",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.6
       *
       * The 507 (Insufficient Storage) status code means the method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request. This condition is considered to be temporary. If the request which received this status code was the result of a user action, the request MUST NOT be repeated until it is requested by a separate user action.
       */
      INSUFFICIENT_SPACE_ON_RESOURCE: "Insufficient Space on Resource",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.6
       *
       * The server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.
       */
      INSUFFICIENT_STORAGE: "Insufficient Storage",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.1
       *
       * The server encountered an unexpected condition that prevented it from fulfilling the request.
       */
      INTERNAL_SERVER_ERROR: "Internal Server Error",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.10
       *
       * The server rejected the request because the Content-Length header field is not defined and the server requires it.
       */
      LENGTH_REQUIRED: "Length Required",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.4
       *
       * The resource that is being accessed is locked.
       */
      LOCKED: "Locked",
      /**
       * @deprecated
       * Official Documentation @ https://tools.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-ietf-webdav-protocol-06.txt
       *
       * A deprecated response used by the Spring Framework when a method has failed.
       */
      METHOD_FAILURE: "Method Failure",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.5
       *
       * The request method is known by the server but has been disabled and cannot be used. For example, an API may forbid DELETE-ing a resource. The two mandatory methods, GET and HEAD, must never be disabled and should not return this error code.
       */
      METHOD_NOT_ALLOWED: "Method Not Allowed",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.2
       *
       * This response code means that URI of requested resource has been changed. Probably, new URI would be given in the response.
       */
      MOVED_PERMANENTLY: "Moved Permanently",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.3
       *
       * This response code means that URI of requested resource has been changed temporarily. New changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.
       */
      MOVED_TEMPORARILY: "Moved Temporarily",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.2
       *
       * A Multi-Status response conveys information about multiple resources in situations where multiple status codes might be appropriate.
       */
      MULTI_STATUS: "Multi-Status",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.1
       *
       * The request has more than one possible responses. User-agent or user should choose one of them. There is no standardized way to choose one of the responses.
       */
      MULTIPLE_CHOICES: "Multiple Choices",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-6
       *
       * The 511 status code indicates that the client needs to authenticate to gain network access.
       */
      NETWORK_AUTHENTICATION_REQUIRED: "Network Authentication Required",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.5
       *
       * There is no content to send for this request, but the headers may be useful. The user-agent may update its cached headers for this resource with the new ones.
       */
      NO_CONTENT: "No Content",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.4
       *
       * This response code means returned meta-information set is not exact set as available from the origin server, but collected from a local or a third party copy. Except this condition, 200 OK response should be preferred instead of this response.
       */
      NON_AUTHORITATIVE_INFORMATION: "Non Authoritative Information",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.6
       *
       * This response is sent when the web server, after performing server-driven content negotiation, doesn't find any content following the criteria given by the user agent.
       */
      NOT_ACCEPTABLE: "Not Acceptable",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.4
       *
       * The server can not find requested resource. In the browser, this means the URL is not recognized. In an API, this can also mean that the endpoint is valid but the resource itself does not exist. Servers may also send this response instead of 403 to hide the existence of a resource from an unauthorized client. This response code is probably the most famous one due to its frequent occurence on the web.
       */
      NOT_FOUND: "Not Found",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.2
       *
       * The request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are GET and HEAD.
       */
      NOT_IMPLEMENTED: "Not Implemented",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7232#section-4.1
       *
       * This is used for caching purposes. It is telling to client that response has not been modified. So, client can continue to use same cached version of response.
       */
      NOT_MODIFIED: "Not Modified",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.1
       *
       * The request has succeeded. The meaning of a success varies depending on the HTTP method:
       * GET: The resource has been fetched and is transmitted in the message body.
       * HEAD: The entity headers are in the message body.
       * POST: The resource describing the result of the action is transmitted in the message body.
       * TRACE: The message body contains the request message as received by the server
       */
      OK: "OK",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7233#section-4.1
       *
       * This response code is used because of range header sent by the client to separate download into multiple streams.
       */
      PARTIAL_CONTENT: "Partial Content",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.2
       *
       * This response code is reserved for future use. Initial aim for creating this code was using it for digital payment systems however this is not used currently.
       */
      PAYMENT_REQUIRED: "Payment Required",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7538#section-3
       *
       * This means that the resource is now permanently located at another URI, specified by the Location: HTTP Response header. This has the same semantics as the 301 Moved Permanently HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.
       */
      PERMANENT_REDIRECT: "Permanent Redirect",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7232#section-4.2
       *
       * The client has indicated preconditions in its headers which the server does not meet.
       */
      PRECONDITION_FAILED: "Precondition Failed",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-3
       *
       * The origin server requires the request to be conditional. Intended to prevent the 'lost update' problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when meanwhile a third party has modified the state on the server, leading to a conflict.
       */
      PRECONDITION_REQUIRED: "Precondition Required",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.1
       *
       * This code indicates that the server has received and is processing the request, but no response is available yet.
       */
      PROCESSING: "Processing",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7235#section-3.2
       *
       * This is similar to 401 but authentication is needed to be done by a proxy.
       */
      PROXY_AUTHENTICATION_REQUIRED: "Proxy Authentication Required",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-5
       *
       * The server is unwilling to process the request because its header fields are too large. The request MAY be resubmitted after reducing the size of the request header fields.
       */
      REQUEST_HEADER_FIELDS_TOO_LARGE: "Request Header Fields Too Large",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.7
       *
       * This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome, Firefox 27+, or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers merely shut down the connection without sending this message.
       */
      REQUEST_TIMEOUT: "Request Timeout",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.11
       *
       * Request entity is larger than limits defined by server; the server might close the connection or return an Retry-After header field.
       */
      REQUEST_TOO_LONG: "Request Entity Too Large",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.12
       *
       * The URI requested by the client is longer than the server is willing to interpret.
       */
      REQUEST_URI_TOO_LONG: "Request-URI Too Long",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7233#section-4.4
       *
       * The range specified by the Range header field in the request can't be fulfilled; it's possible that the range is outside the size of the target URI's data.
       */
      REQUESTED_RANGE_NOT_SATISFIABLE: "Requested Range Not Satisfiable",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.3.6
       *
       * This response code is sent after accomplishing request to tell user agent reset document view which sent this request.
       */
      RESET_CONTENT: "Reset Content",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.4
       *
       * Server sent this response to directing client to get requested resource to another URI with an GET request.
       */
      SEE_OTHER: "See Other",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.6.4
       *
       * The server is not ready to handle the request. Common causes are a server that is down for maintenance or that is overloaded. Note that together with this response, a user-friendly page explaining the problem should be sent. This responses should be used for temporary conditions and the Retry-After: HTTP header should, if possible, contain the estimated time before the recovery of the service. The webmaster must also take care about the caching-related headers that are sent along with this response, as these temporary condition responses should usually not be cached.
       */
      SERVICE_UNAVAILABLE: "Service Unavailable",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.2.2
       *
       * This code is sent in response to an Upgrade request header by the client, and indicates the protocol the server is switching too.
       */
      SWITCHING_PROTOCOLS: "Switching Protocols",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.7
       *
       * Server sent this response to directing client to get requested resource to another URI with same method that used prior request. This has the same semantic than the 302 Found HTTP response code, with the exception that the user agent must not change the HTTP method used: if a POST was used in the first request, a POST must be used in the second request.
       */
      TEMPORARY_REDIRECT: "Temporary Redirect",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc6585#section-4
       *
       * The user has sent too many requests in a given amount of time ("rate limiting").
       */
      TOO_MANY_REQUESTS: "Too Many Requests",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7235#section-3.1
       *
       * Although the HTTP standard specifies "unauthorized", semantically this response means "unauthenticated". That is, the client must authenticate itself to get the requested response.
       */
      UNAUTHORIZED: "Unauthorized",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7725
       *
       * The user-agent requested a resource that cannot legally be provided, such as a web page censored by a government.
       */
      UNAVAILABLE_FOR_LEGAL_REASONS: "Unavailable For Legal Reasons",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc2518#section-10.3
       *
       * The request was well-formed but was unable to be followed due to semantic errors.
       */
      UNPROCESSABLE_ENTITY: "Unprocessable Entity",
      /**
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.5.13
       *
       * The media format of the requested data is not supported by the server, so the server is rejecting the request.
       */
      UNSUPPORTED_MEDIA_TYPE: "Unsupported Media Type",
      /**
       * @deprecated
       * Official Documentation @ https://tools.ietf.org/html/rfc7231#section-6.4.6
       *
       * Was defined in a previous version of the HTTP specification to indicate that a requested response must be accessed by a proxy. It has been deprecated due to security concerns regarding in-band configuration of a proxy.
       */
      USE_PROXY: "Use Proxy",
      /**
       * Official Documentation @ https://datatracker.ietf.org/doc/html/rfc7540#section-9.1.2
       *
       * Defined in the specification of HTTP/2 to indicate that a server is not able to produce a response for the combination of scheme and authority that are included in the request URI.
       */
      MISDIRECTED_REQUEST: "Misdirected Request"
    };
    reasonPhrases_default = reasonPhrases;
  }
});

// src/core/httpStatusCode.ts
var httpStatusCode_exports = {};
__export(httpStatusCode_exports, {
  ReasonPhrases: () => reasonPhrases_default,
  StatusCodes: () => statusCodes_default
});
var init_httpStatusCode = __esm({
  "src/core/httpStatusCode.ts"() {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    init_statusCodes();
    init_reasonPhrases();
  }
});

// ../../node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "../../node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string, regex) {
      const matches = [];
      let match = regex.exec(string);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string);
      }
      return matches;
    };
    var isName = function(string) {
      const match = regexName.exec(string);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function(v2) {
      return typeof v2 !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a2, arrayMode) {
      if (a2) {
        const keys = Object.keys(a2);
        const len = keys.length;
        for (let i2 = 0; i2 < len; i2++) {
          if (arrayMode === "strict") {
            target[keys[i2]] = [a2[keys[i2]]];
          } else {
            target[keys[i2]] = a2[keys[i2]];
          }
        }
      }
    };
    exports.getValue = function(v2) {
      if (exports.isExist(v2)) {
        return v2;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// ../../node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "../../node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var util2 = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i2 = 0; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<" && xmlData[i2 + 1] === "?") {
          i2 += 2;
          i2 = readPI(xmlData, i2);
          if (i2.err)
            return i2;
        } else if (xmlData[i2] === "<") {
          let tagStartPos = i2;
          i2++;
          if (xmlData[i2] === "!") {
            i2 = readCommentAndCDATA(xmlData, i2);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i2] === "/") {
              closingTag = true;
              i2++;
            }
            let tagName = "";
            for (; i2 < xmlData.length && xmlData[i2] !== ">" && xmlData[i2] !== " " && xmlData[i2] !== "	" && xmlData[i2] !== "\n" && xmlData[i2] !== "\r"; i2++) {
              tagName += xmlData[i2];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i2--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i2));
            }
            const result = readAttributeStr(xmlData, i2);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i2));
            }
            let attrStr = result.value;
            i2 = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i2 - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid2 = validateAttributeString(attrStr, options);
              if (isValid2 === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid2.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i2));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid2 = validateAttributeString(attrStr, options);
              if (isValid2 !== true) {
                return getErrorObject(isValid2.err.code, isValid2.err.msg, getLineNumberForPosition(xmlData, i2 - attrStr.length + isValid2.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i2));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i2++; i2 < xmlData.length; i2++) {
              if (xmlData[i2] === "<") {
                if (xmlData[i2 + 1] === "!") {
                  i2++;
                  i2 = readCommentAndCDATA(xmlData, i2);
                  continue;
                } else if (xmlData[i2 + 1] === "?") {
                  i2 = readPI(xmlData, ++i2);
                  if (i2.err)
                    return i2;
                } else {
                  break;
                }
              } else if (xmlData[i2] === "&") {
                const afterAmp = validateAmpersand(xmlData, i2);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i2));
                i2 = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i2])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i2));
                }
              }
            }
            if (xmlData[i2] === "<") {
              i2--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i2])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i2] + "' is not expected.", getLineNumberForPosition(xmlData, i2));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t2) => t2.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i2) {
      const start = i2;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] == "?" || xmlData[i2] == " ") {
          const tagname = xmlData.substr(start, i2 - start);
          if (i2 > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i2));
          } else if (xmlData[i2] == "?" && xmlData[i2 + 1] == ">") {
            i2++;
            break;
          } else {
            continue;
          }
        }
      }
      return i2;
    }
    function readCommentAndCDATA(xmlData, i2) {
      if (xmlData.length > i2 + 5 && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === "-") {
        for (i2 += 3; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "-" && xmlData[i2 + 1] === "-" && xmlData[i2 + 2] === ">") {
            i2 += 2;
            break;
          }
        }
      } else if (xmlData.length > i2 + 8 && xmlData[i2 + 1] === "D" && xmlData[i2 + 2] === "O" && xmlData[i2 + 3] === "C" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "Y" && xmlData[i2 + 6] === "P" && xmlData[i2 + 7] === "E") {
        let angleBracketsCount = 1;
        for (i2 += 8; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i2] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i2 + 9 && xmlData[i2 + 1] === "[" && xmlData[i2 + 2] === "C" && xmlData[i2 + 3] === "D" && xmlData[i2 + 4] === "A" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "A" && xmlData[i2 + 7] === "[") {
        for (i2 += 8; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "]" && xmlData[i2 + 1] === "]" && xmlData[i2 + 2] === ">") {
            i2 += 2;
            break;
          }
        }
      }
      return i2;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i2) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === doubleQuote || xmlData[i2] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i2];
          } else if (startChar !== xmlData[i2]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i2] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i2];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i2,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util2.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i2 = 0; i2 < matches.length; i2++) {
        if (matches[i2][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' has no space in starting.", getPositionFromMatch(matches[i2]));
        } else if (matches[i2][3] !== void 0 && matches[i2][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i2][2] + "' is without value.", getPositionFromMatch(matches[i2]));
        } else if (matches[i2][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i2][2] + "' is not allowed.", getPositionFromMatch(matches[i2]));
        }
        const attrName = matches[i2][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i2]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i2]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i2) {
      let re = /\d/;
      if (xmlData[i2] === "x") {
        i2++;
        re = /[\da-fA-F]/;
      }
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === ";")
          return i2;
        if (!xmlData[i2].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i2) {
      i2++;
      if (xmlData[i2] === ";")
        return -1;
      if (xmlData[i2] === "#") {
        i2++;
        return validateNumberAmpersand(xmlData, i2);
      }
      let count = 0;
      for (; i2 < xmlData.length; i2++, count++) {
        if (xmlData[i2].match(/\w/) && count < 20)
          continue;
        if (xmlData[i2] === ";")
          break;
        return -1;
      }
      return i2;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util2.isName(attrName);
    }
    function validateTagName(tagname) {
      return util2.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    init_checked_fetch();
    init_modules_watch_stub();
    var defaultOptions = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val2) {
        return val2;
      },
      attributeValueProcessor: function(attrName, val2) {
        return val2;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function(tagName, jPath, attrs) {
        return tagName;
      }
      // skipEmptyListItem: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var XmlNode2 = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val2) {
        if (key === "__proto__")
          key = "#__proto__";
        this.child.push({ [key]: val2 });
      }
      addChild(node) {
        if (node.tagname === "__proto__")
          node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module.exports = XmlNode2;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    var util2 = require_util();
    function readDocType(xmlData, i2) {
      const entities = {};
      if (xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "C" && xmlData[i2 + 5] === "T" && xmlData[i2 + 6] === "Y" && xmlData[i2 + 7] === "P" && xmlData[i2 + 8] === "E") {
        i2 = i2 + 9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for (; i2 < xmlData.length; i2++) {
          if (xmlData[i2] === "<" && !comment) {
            if (hasBody && isEntity(xmlData, i2)) {
              i2 += 7;
              [entityName, val, i2] = readEntityExp(xmlData, i2 + 1);
              if (val.indexOf("&") === -1)
                entities[validateEntityName(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val
                };
            } else if (hasBody && isElement(xmlData, i2))
              i2 += 8;
            else if (hasBody && isAttlist(xmlData, i2))
              i2 += 8;
            else if (hasBody && isNotation(xmlData, i2))
              i2 += 9;
            else if (isComment)
              comment = true;
            else
              throw new Error("Invalid DOCTYPE");
            angleBracketsCount++;
            exp = "";
          } else if (xmlData[i2] === ">") {
            if (comment) {
              if (xmlData[i2 - 1] === "-" && xmlData[i2 - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i2] === "[") {
            hasBody = true;
          } else {
            exp += xmlData[i2];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i: i2 };
    }
    function readEntityExp(xmlData, i2) {
      let entityName2 = "";
      for (; i2 < xmlData.length && (xmlData[i2] !== "'" && xmlData[i2] !== '"'); i2++) {
        entityName2 += xmlData[i2];
      }
      entityName2 = entityName2.trim();
      if (entityName2.indexOf(" ") !== -1)
        throw new Error("External entites are not supported");
      const startChar = xmlData[i2++];
      let val2 = "";
      for (; i2 < xmlData.length && xmlData[i2] !== startChar; i2++) {
        val2 += xmlData[i2];
      }
      return [entityName2, val2, i2];
    }
    function isComment(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "-" && xmlData[i2 + 3] === "-")
        return true;
      return false;
    }
    function isEntity(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "N" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "I" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "Y")
        return true;
      return false;
    }
    function isElement(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "E" && xmlData[i2 + 3] === "L" && xmlData[i2 + 4] === "E" && xmlData[i2 + 5] === "M" && xmlData[i2 + 6] === "E" && xmlData[i2 + 7] === "N" && xmlData[i2 + 8] === "T")
        return true;
      return false;
    }
    function isAttlist(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "A" && xmlData[i2 + 3] === "T" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "L" && xmlData[i2 + 6] === "I" && xmlData[i2 + 7] === "S" && xmlData[i2 + 8] === "T")
        return true;
      return false;
    }
    function isNotation(xmlData, i2) {
      if (xmlData[i2 + 1] === "!" && xmlData[i2 + 2] === "N" && xmlData[i2 + 3] === "O" && xmlData[i2 + 4] === "T" && xmlData[i2 + 5] === "A" && xmlData[i2 + 6] === "T" && xmlData[i2 + 7] === "I" && xmlData[i2 + 8] === "O" && xmlData[i2 + 9] === "N")
        return true;
      return false;
    }
    function validateEntityName(name2) {
      if (util2.isName(name2))
        return name2;
      else
        throw new Error(`Invalid entity name ${name2}`);
    }
    module.exports = readDocType;
  }
});

// ../../node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "../../node_modules/strnum/strnum.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }
    var consider = {
      hex: true,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    function toNumber(str, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str || typeof str !== "string")
        return str;
      let trimmedStr = str.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
        return str;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          const eNotation = match[4] || match[6];
          if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".")
            return str;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".")
            return str;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (eNotation) {
              if (options.eNotation)
                return num;
              else
                return str;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "")
                return num;
              else if (numStr === numTrimmedByZeros)
                return num;
              else if (sign && numStr === "-" + numTrimmedByZeros)
                return num;
              else
                return str;
            }
            if (leadingZeros) {
              if (numTrimmedByZeros === numStr)
                return num;
              else if (sign + numTrimmedByZeros === numStr)
                return num;
              else
                return str;
            }
            if (trimmedStr === numStr)
              return num;
            else if (trimmedStr === sign + numStr)
              return num;
            return str;
          }
        } else {
          return str;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".")
          numStr = "0";
        else if (numStr[0] === ".")
          numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".")
          numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    module.exports = toNumber;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var util2 = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber = require_strnum();
    var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, util2.nameRegexp);
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "\xA2" },
          "pound": { regex: /&(pound|#163);/g, val: "\xA3" },
          "yen": { regex: /&(yen|#165);/g, val: "\xA5" },
          "euro": { regex: /&(euro|#8364);/g, val: "\u20AC" },
          "copyright": { regex: /&(copy|#169);/g, val: "\xA9" },
          "reg": { regex: /&(reg|#174);/g, val: "\xAE" },
          "inr": { regex: /&(inr|#8377);/g, val: "\u20B9" }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i2 = 0; i2 < entKeys.length; i2++) {
        const ent = entKeys[i2];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val2 !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val2 = val2.trim();
        }
        if (val2.length > 0) {
          if (!escapeEntities)
            val2 = this.replaceEntitiesValue(val2);
          const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val2;
          } else if (typeof newval !== typeof val2 || newval !== val2) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val2.trim();
            if (trimmedVal === val2) {
              return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val2;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath, tagName) {
      if (!this.options.ignoreAttributes && typeof attrStr === "string") {
        const matches = util2.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i2 = 0; i2 < len; i2++) {
          const attrName = this.resolveNameSpace(matches[i2][1]);
          let oldVal = matches[i2][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__")
              aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i2 = 0; i2 < xmlData.length; i2++) {
        const ch2 = xmlData[i2];
        if (ch2 === "<") {
          if (xmlData[i2 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i2, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i2 + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
            }
            let propIndex = 0;
            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i2 = closeIndex;
          } else if (xmlData[i2 + 1] === "?") {
            let tagData = readTagExp(xmlData, i2, false, "?>");
            if (!tagData)
              throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
              }
              this.addChild(currentNode, childNode, jPath);
            }
            i2 = tagData.closeIndex + 1;
          } else if (xmlData.substr(i2 + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i2 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i2 + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i2 = endIndex;
          } else if (xmlData.substr(i2 + 1, 2) === "!D") {
            const result = readDocType(xmlData, i2);
            this.docTypeEntities = result.entities;
            i2 = result.i;
          } else if (xmlData.substr(i2 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i2, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i2 + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
              if (val2 == void 0)
                val2 = "";
              currentNode.add(this.options.textNodeName, val2);
            }
            i2 = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i2, this.options.removeNSPrefix);
            let tagName = result.tagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                i2 = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i2 = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
                if (!result2)
                  throw new Error(`Unexpected end of ${tagName}`);
                i2 = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i2 = closeIndex;
            }
          }
        } else {
          textData += xmlData[i2];
        }
      }
      return xmlObj.child;
    };
    function addChild(currentNode, childNode, jPath) {
      const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
      if (result === false) {
      } else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }
    var replaceEntitiesValue = function(val2) {
      if (this.options.processEntities) {
        for (let entityName2 in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName2];
          val2 = val2.replace(entity.regx, entity.val);
        }
        for (let entityName2 in this.lastEntities) {
          const entity = this.lastEntities[entityName2];
          val2 = val2.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName2 in this.htmlEntities) {
            const entity = this.htmlEntities[entityName2];
            val2 = val2.replace(entity.regex, entity.val);
          }
        }
        val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val2;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0)
          isLeafNode = Object.keys(currentNode.child).length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
          return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i2, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i2; index < xmlData.length; index++) {
        let ch2 = xmlData[index];
        if (attrBoundary) {
          if (ch2 === attrBoundary)
            attrBoundary = "";
        } else if (ch2 === '"' || ch2 === "'") {
          attrBoundary = ch2;
        } else if (ch2 === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch2 === "	") {
          ch2 = " ";
        }
        tagExp += ch2;
      }
    }
    function findClosingIndex(xmlData, str, i2, errMsg) {
      const closingIndex = xmlData.indexOf(str, i2);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str.length - 1;
      }
    }
    function readTagExp(xmlData, i2, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i2 + 1, closingChar);
      if (!result)
        return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, "");
        tagExp = tagExp.substr(separatorIndex + 1);
      }
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent
      };
    }
    function readStopNodeData(xmlData, tagName, i2) {
      const startIndex = i2;
      let openTagCount = 1;
      for (; i2 < xmlData.length; i2++) {
        if (xmlData[i2] === "<") {
          if (xmlData[i2 + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i2, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i2 + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i2),
                  i: closeIndex
                };
              }
            }
            i2 = closeIndex;
          } else if (xmlData[i2 + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i2 + 1, "StopNode is not closed.");
            i2 = closeIndex;
          } else if (xmlData.substr(i2 + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i2 + 3, "StopNode is not closed.");
            i2 = closeIndex;
          } else if (xmlData.substr(i2 + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i2, "StopNode is not closed.") - 2;
            i2 = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i2, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i2 = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val2, shouldParse, options) {
      if (shouldParse && typeof val2 === "string") {
        const newval = val2.trim();
        if (newval === "true")
          return true;
        else if (newval === "false")
          return false;
        else
          return toNumber(val2, options);
      } else {
        if (util2.isExist(val2)) {
          return val2;
        } else {
          return "";
        }
      }
    }
    module.exports = OrderedObjParser;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    function prettify(node, options) {
      return compress(node, options);
    }
    function compress(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i2 = 0; i2 < arr.length; i2++) {
        const tagObj = arr[i2];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0)
          newJpath = property;
        else
          newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0)
            text = tagObj[property];
          else
            text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val2 = compress(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val2, options);
          if (tagObj[":@"]) {
            assignAttributes(val2, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val2 = val2[options.textNodeName];
          } else if (Object.keys(val2).length === 0) {
            if (options.alwaysCreateTextNode)
              val2[options.textNodeName] = "";
            else
              val2 = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val2);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val2];
            } else {
              compressedObj[property] = val2;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0)
          compressedObj[options.textNodeName] = text;
      } else if (text !== void 0)
        compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        if (key !== ":@")
          return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i2 = 0; i2 < len; i2++) {
          const atrrName = keys[i2];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;
      if (propCount === 0) {
        return true;
      }
      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
        return true;
      }
      return false;
    }
    exports.prettify = prettify;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator2 = require_validator();
    var XMLParser2 = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true)
            validationOption = {};
          const result = validator2.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0)
          return orderedResult;
        else
          return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module.exports = XMLParser2;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i2 = 0; i2 < arr.length; i2++) {
        const tagObj = arr[i2];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0)
          newJPath = tagName;
        else
          newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode)
            xmlStr += tagStart + ">";
          else
            xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        if (key !== ":@")
          return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
          return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i2 = 0; i2 < options.entities.length; i2++) {
          const entity = options.entities[i2];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module.exports = toXml;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var buildFromOrderedJs = require_orderedJs2Xml();
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a2) {
        return a2;
      },
      attributeValueProcessor: function(attrName, a2) {
        return a2;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions, options);
      if (this.options.ignoreAttributes || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val2 = "";
      for (let key in jObj) {
        if (typeof jObj[key] === "undefined") {
        } else if (jObj[key] === null) {
          if (key[0] === "?")
            val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else
            val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
          val2 += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val2 += this.replaceEntitiesValue(newval);
            } else {
              val2 += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          let listTagVal = "";
          for (let j2 = 0; j2 < arrLen; j2++) {
            const item = jObj[key][j2];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?")
                val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else
                val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                listTagVal += this.j2x(item, level + 1).val;
              } else {
                listTagVal += this.processTextOrObjNode(item, key, level);
              }
            } else {
              listTagVal += this.buildTextValNode(item, key, "", level);
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(listTagVal, key, "", level);
          }
          val2 += listTagVal;
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L2 = Ks.length;
            for (let j2 = 0; j2 < L2; j2++) {
              attrStr += this.buildAttrPairStr(Ks[j2], "" + jObj[key][Ks[j2]]);
            }
          } else {
            val2 += this.processTextOrObjNode(jObj[key], key, level);
          }
        }
      }
      return { attrStr, val: val2 };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val2) {
      val2 = this.options.attributeValueProcessor(attrName, "" + val2);
      val2 = this.replaceEntitiesValue(val2);
      if (this.options.suppressBooleanAttributes && val2 === "true") {
        return " " + attrName;
      } else
        return " " + attrName + '="' + val2 + '"';
    };
    function processTextOrObjNode(object, key, level) {
      const result = this.j2x(object, level + 1);
      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function(val2, key, attrStr, level) {
      if (val2 === "") {
        if (key[0] === "?")
          return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if (attrStr && val2.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val2}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode)
          closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val2, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val2}-->` + this.newLine;
      } else if (key[0] === "?") {
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key, val2);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i2 = 0; i2 < this.options.entities.length; i2++) {
          const entity = this.options.entities[i2];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name2) {
      if (name2.startsWith(this.options.attributeNamePrefix)) {
        return name2.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module.exports = Builder;
  }
});

// ../../node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "../../node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var validator2 = require_validator();
    var XMLParser2 = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module.exports = {
      XMLParser: XMLParser2,
      XMLValidator: validator2,
      XMLBuilder
    };
  }
});

// ../../node_modules/@aws-crypto/sha1-browser/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "../../node_modules/@aws-crypto/sha1-browser/node_modules/tslib/tslib.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    var __extends;
    var __assign;
    var __rest2;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter2;
    var __generator2;
    var __exportStar;
    var __values2;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends = function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      __rest2 = function(s2, e2) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values2 = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar2 = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw3) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw3 });
        } else {
          cooked.raw = raw3;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values2);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// ../../node_modules/@aws-crypto/sha1-browser/build/isEmptyData.js
var require_isEmptyData = __commonJS({
  "../../node_modules/@aws-crypto/sha1-browser/build/isEmptyData.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData3(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    exports.isEmptyData = isEmptyData3;
  }
});

// ../../node_modules/@aws-crypto/sha1-browser/build/constants.js
var require_constants = __commonJS({
  "../../node_modules/@aws-crypto/sha1-browser/build/constants.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EMPTY_DATA_SHA_1 = exports.SHA_1_HMAC_ALGO = exports.SHA_1_HASH = void 0;
    exports.SHA_1_HASH = { name: "SHA-1" };
    exports.SHA_1_HMAC_ALGO = {
      name: "HMAC",
      hash: exports.SHA_1_HASH
    };
    exports.EMPTY_DATA_SHA_1 = new Uint8Array([
      218,
      57,
      163,
      238,
      94,
      107,
      75,
      13,
      50,
      85,
      191,
      239,
      149,
      96,
      24,
      144,
      175,
      216,
      7,
      9
    ]);
  }
});

// ../../node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js
var require_pureJs = __commonJS({
  "../../node_modules/@aws-sdk/util-utf8-browser/dist-cjs/pureJs.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = exports.fromUtf8 = void 0;
    var fromUtf84 = (input) => {
      const bytes = [];
      for (let i2 = 0, len = input.length; i2 < len; i2++) {
        const value = input.charCodeAt(i2);
        if (value < 128) {
          bytes.push(value);
        } else if (value < 2048) {
          bytes.push(value >> 6 | 192, value & 63 | 128);
        } else if (i2 + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i2 + 1) & 64512) === 56320) {
          const surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i2) & 1023);
          bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);
        } else {
          bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);
        }
      }
      return Uint8Array.from(bytes);
    };
    exports.fromUtf8 = fromUtf84;
    var toUtf82 = (input) => {
      let decoded = "";
      for (let i2 = 0, len = input.length; i2 < len; i2++) {
        const byte = input[i2];
        if (byte < 128) {
          decoded += String.fromCharCode(byte);
        } else if (192 <= byte && byte < 224) {
          const nextByte = input[++i2];
          decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);
        } else if (240 <= byte && byte < 365) {
          const surrogatePair = [byte, input[++i2], input[++i2], input[++i2]];
          const encoded = "%" + surrogatePair.map((byteValue) => byteValue.toString(16)).join("%");
          decoded += decodeURIComponent(encoded);
        } else {
          decoded += String.fromCharCode((byte & 15) << 12 | (input[++i2] & 63) << 6 | input[++i2] & 63);
        }
      }
      return decoded;
    };
    exports.toUtf8 = toUtf82;
  }
});

// ../../node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js
var require_whatwgEncodingApi = __commonJS({
  "../../node_modules/@aws-sdk/util-utf8-browser/dist-cjs/whatwgEncodingApi.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = exports.fromUtf8 = void 0;
    function fromUtf84(input) {
      return new TextEncoder().encode(input);
    }
    exports.fromUtf8 = fromUtf84;
    function toUtf82(input) {
      return new TextDecoder("utf-8").decode(input);
    }
    exports.toUtf8 = toUtf82;
  }
});

// ../../node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js
var require_dist_cjs = __commonJS({
  "../../node_modules/@aws-sdk/util-utf8-browser/dist-cjs/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = exports.fromUtf8 = void 0;
    var pureJs_1 = require_pureJs();
    var whatwgEncodingApi_1 = require_whatwgEncodingApi();
    var fromUtf84 = (input) => typeof TextEncoder === "function" ? (0, whatwgEncodingApi_1.fromUtf8)(input) : (0, pureJs_1.fromUtf8)(input);
    exports.fromUtf8 = fromUtf84;
    var toUtf82 = (input) => typeof TextDecoder === "function" ? (0, whatwgEncodingApi_1.toUtf8)(input) : (0, pureJs_1.toUtf8)(input);
    exports.toUtf8 = toUtf82;
  }
});

// ../../node_modules/@aws-sdk/util-locate-window/dist-cjs/index.js
var require_dist_cjs2 = __commonJS({
  "../../node_modules/@aws-sdk/util-locate-window/dist-cjs/index.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports2 = {};
    __export2(src_exports2, {
      locateWindow: () => locateWindow
    });
    module.exports = __toCommonJS2(src_exports2);
    var fallbackWindow = {};
    function locateWindow() {
      if (typeof window !== "undefined") {
        return window;
      } else if (typeof self !== "undefined") {
        return self;
      }
      return fallbackWindow;
    }
    __name(locateWindow, "locateWindow");
  }
});

// ../../node_modules/@aws-crypto/sha1-browser/build/ie11Sha1.js
var require_ie11Sha1 = __commonJS({
  "../../node_modules/@aws-crypto/sha1-browser/build/ie11Sha1.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha1 = void 0;
    var isEmptyData_1 = require_isEmptyData();
    var constants_1 = require_constants();
    var util_utf8_browser_1 = require_dist_cjs();
    var util_locate_window_1 = require_dist_cjs2();
    var Sha12 = (
      /** @class */
      function() {
        function Sha13(secret) {
          this.secret = secret;
          this.reset();
        }
        Sha13.prototype.update = function(toHash) {
          var _this = this;
          if ((0, isEmptyData_1.isEmptyData)(toHash)) {
            return;
          }
          this.operation = this.operation.then(function(operation) {
            operation.onerror = function() {
              _this.operation = Promise.reject(new Error("Error encountered updating hash"));
            };
            operation.process(toArrayBufferView(toHash));
            return operation;
          });
          this.operation.catch(function() {
          });
        };
        Sha13.prototype.digest = function() {
          return this.operation.then(function(operation) {
            return new Promise(function(resolve, reject) {
              operation.onerror = function() {
                reject(new Error("Error encountered finalizing hash"));
              };
              operation.oncomplete = function() {
                if (operation.result) {
                  resolve(new Uint8Array(operation.result));
                }
                reject(new Error("Error encountered finalizing hash"));
              };
              operation.finish();
            });
          });
        };
        Sha13.prototype.reset = function() {
          if (this.secret) {
            this.operation = getKeyPromise(this.secret).then(function(keyData) {
              return (0, util_locate_window_1.locateWindow)().msCrypto.subtle.sign(constants_1.SHA_1_HMAC_ALGO, keyData);
            });
            this.operation.catch(function() {
            });
          } else {
            this.operation = Promise.resolve((0, util_locate_window_1.locateWindow)().msCrypto.subtle.digest("SHA-1"));
          }
        };
        return Sha13;
      }()
    );
    exports.Sha1 = Sha12;
    function getKeyPromise(secret) {
      return new Promise(function(resolve, reject) {
        var keyOperation = (0, util_locate_window_1.locateWindow)().msCrypto.subtle.importKey("raw", toArrayBufferView(secret), constants_1.SHA_1_HMAC_ALGO, false, ["sign"]);
        keyOperation.oncomplete = function() {
          if (keyOperation.result) {
            resolve(keyOperation.result);
          }
          reject(new Error("ImportKey completed without importing key."));
        };
        keyOperation.onerror = function() {
          reject(new Error("ImportKey failed to import key."));
        };
      });
    }
    function toArrayBufferView(data) {
      if (typeof data === "string") {
        return (0, util_utf8_browser_1.fromUtf8)(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
  }
});

// ../../node_modules/@aws-crypto/sha1-browser/build/webCryptoSha1.js
var require_webCryptoSha1 = __commonJS({
  "../../node_modules/@aws-crypto/sha1-browser/build/webCryptoSha1.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha1 = void 0;
    var util_utf8_browser_1 = require_dist_cjs();
    var isEmptyData_1 = require_isEmptyData();
    var constants_1 = require_constants();
    var util_locate_window_1 = require_dist_cjs2();
    var Sha12 = (
      /** @class */
      function() {
        function Sha13(secret) {
          this.toHash = new Uint8Array(0);
          if (secret !== void 0) {
            this.key = new Promise(function(resolve, reject) {
              (0, util_locate_window_1.locateWindow)().crypto.subtle.importKey("raw", convertToBuffer3(secret), constants_1.SHA_1_HMAC_ALGO, false, ["sign"]).then(resolve, reject);
            });
            this.key.catch(function() {
            });
          }
        }
        Sha13.prototype.update = function(data) {
          if ((0, isEmptyData_1.isEmptyData)(data)) {
            return;
          }
          var update = convertToBuffer3(data);
          var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
          typedArray.set(this.toHash, 0);
          typedArray.set(update, this.toHash.byteLength);
          this.toHash = typedArray;
        };
        Sha13.prototype.digest = function() {
          var _this = this;
          if (this.key) {
            return this.key.then(function(key) {
              return (0, util_locate_window_1.locateWindow)().crypto.subtle.sign(constants_1.SHA_1_HMAC_ALGO, key, _this.toHash).then(function(data) {
                return new Uint8Array(data);
              });
            });
          }
          if ((0, isEmptyData_1.isEmptyData)(this.toHash)) {
            return Promise.resolve(constants_1.EMPTY_DATA_SHA_1);
          }
          return Promise.resolve().then(function() {
            return (0, util_locate_window_1.locateWindow)().crypto.subtle.digest(constants_1.SHA_1_HASH, _this.toHash);
          }).then(function(data) {
            return Promise.resolve(new Uint8Array(data));
          });
        };
        Sha13.prototype.reset = function() {
          this.toHash = new Uint8Array(0);
        };
        return Sha13;
      }()
    );
    exports.Sha1 = Sha12;
    function convertToBuffer3(data) {
      if (typeof data === "string") {
        return (0, util_utf8_browser_1.fromUtf8)(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
  }
});

// ../../node_modules/@aws-crypto/supports-web-crypto/node_modules/tslib/tslib.js
var require_tslib2 = __commonJS({
  "../../node_modules/@aws-crypto/supports-web-crypto/node_modules/tslib/tslib.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    var __extends;
    var __assign;
    var __rest2;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter2;
    var __generator2;
    var __exportStar;
    var __values2;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends = function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      __rest2 = function(s2, e2) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values2 = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar2 = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw3) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw3 });
        } else {
          cooked.raw = raw3;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values2);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// ../../node_modules/@aws-crypto/supports-web-crypto/build/supportsWebCrypto.js
var require_supportsWebCrypto = __commonJS({
  "../../node_modules/@aws-crypto/supports-web-crypto/build/supportsWebCrypto.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.supportsZeroByteGCM = exports.supportsSubtleCrypto = exports.supportsSecureRandom = exports.supportsWebCrypto = void 0;
    var tslib_1 = require_tslib2();
    var subtleCryptoMethods = [
      "decrypt",
      "digest",
      "encrypt",
      "exportKey",
      "generateKey",
      "importKey",
      "sign",
      "verify"
    ];
    function supportsWebCrypto(window2) {
      if (supportsSecureRandom(window2) && typeof window2.crypto.subtle === "object") {
        var subtle = window2.crypto.subtle;
        return supportsSubtleCrypto(subtle);
      }
      return false;
    }
    exports.supportsWebCrypto = supportsWebCrypto;
    function supportsSecureRandom(window2) {
      if (typeof window2 === "object" && typeof window2.crypto === "object") {
        var getRandomValues2 = window2.crypto.getRandomValues;
        return typeof getRandomValues2 === "function";
      }
      return false;
    }
    exports.supportsSecureRandom = supportsSecureRandom;
    function supportsSubtleCrypto(subtle) {
      return subtle && subtleCryptoMethods.every(function(methodName) {
        return typeof subtle[methodName] === "function";
      });
    }
    exports.supportsSubtleCrypto = supportsSubtleCrypto;
    function supportsZeroByteGCM(subtle) {
      return tslib_1.__awaiter(this, void 0, void 0, function() {
        var key, zeroByteAuthTag, _a2;
        return tslib_1.__generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!supportsSubtleCrypto(subtle))
                return [2, false];
              _b.label = 1;
            case 1:
              _b.trys.push([1, 4, , 5]);
              return [4, subtle.generateKey({ name: "AES-GCM", length: 128 }, false, ["encrypt"])];
            case 2:
              key = _b.sent();
              return [4, subtle.encrypt({
                name: "AES-GCM",
                iv: new Uint8Array(Array(12)),
                additionalData: new Uint8Array(Array(16)),
                tagLength: 128
              }, key, new Uint8Array(0))];
            case 3:
              zeroByteAuthTag = _b.sent();
              return [2, zeroByteAuthTag.byteLength === 16];
            case 4:
              _a2 = _b.sent();
              return [2, false];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }
    exports.supportsZeroByteGCM = supportsZeroByteGCM;
  }
});

// ../../node_modules/@aws-crypto/supports-web-crypto/build/index.js
var require_build = __commonJS({
  "../../node_modules/@aws-crypto/supports-web-crypto/build/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib2();
    tslib_1.__exportStar(require_supportsWebCrypto(), exports);
  }
});

// ../../node_modules/@aws-crypto/ie11-detection/node_modules/tslib/tslib.js
var require_tslib3 = __commonJS({
  "../../node_modules/@aws-crypto/ie11-detection/node_modules/tslib/tslib.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    var __extends;
    var __assign;
    var __rest2;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter2;
    var __generator2;
    var __exportStar;
    var __values2;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends = function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      __rest2 = function(s2, e2) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values2 = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar2 = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw3) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw3 });
        } else {
          cooked.raw = raw3;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values2);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// ../../node_modules/@aws-crypto/ie11-detection/build/CryptoOperation.js
var require_CryptoOperation = __commonJS({
  "../../node_modules/@aws-crypto/ie11-detection/build/CryptoOperation.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@aws-crypto/ie11-detection/build/Key.js
var require_Key = __commonJS({
  "../../node_modules/@aws-crypto/ie11-detection/build/Key.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@aws-crypto/ie11-detection/build/KeyOperation.js
var require_KeyOperation = __commonJS({
  "../../node_modules/@aws-crypto/ie11-detection/build/KeyOperation.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@aws-crypto/ie11-detection/build/MsSubtleCrypto.js
var require_MsSubtleCrypto = __commonJS({
  "../../node_modules/@aws-crypto/ie11-detection/build/MsSubtleCrypto.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../node_modules/@aws-crypto/ie11-detection/build/MsWindow.js
var require_MsWindow = __commonJS({
  "../../node_modules/@aws-crypto/ie11-detection/build/MsWindow.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsWindow = void 0;
    var msSubtleCryptoMethods = [
      "decrypt",
      "digest",
      "encrypt",
      "exportKey",
      "generateKey",
      "importKey",
      "sign",
      "verify"
    ];
    function quacksLikeAnMsWindow(window2) {
      return "MSInputMethodContext" in window2 && "msCrypto" in window2;
    }
    function isMsWindow(window2) {
      if (quacksLikeAnMsWindow(window2) && window2.msCrypto.subtle !== void 0) {
        var _a2 = window2.msCrypto, getRandomValues2 = _a2.getRandomValues, subtle_1 = _a2.subtle;
        return msSubtleCryptoMethods.map(function(methodName) {
          return subtle_1[methodName];
        }).concat(getRandomValues2).every(function(method) {
          return typeof method === "function";
        });
      }
      return false;
    }
    exports.isMsWindow = isMsWindow;
  }
});

// ../../node_modules/@aws-crypto/ie11-detection/build/index.js
var require_build2 = __commonJS({
  "../../node_modules/@aws-crypto/ie11-detection/build/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib3();
    tslib_1.__exportStar(require_CryptoOperation(), exports);
    tslib_1.__exportStar(require_Key(), exports);
    tslib_1.__exportStar(require_KeyOperation(), exports);
    tslib_1.__exportStar(require_MsSubtleCrypto(), exports);
    tslib_1.__exportStar(require_MsWindow(), exports);
  }
});

// ../../node_modules/@aws-crypto/util/build/convertToBuffer.js
var require_convertToBuffer = __commonJS({
  "../../node_modules/@aws-crypto/util/build/convertToBuffer.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertToBuffer = void 0;
    var util_utf8_browser_1 = require_dist_cjs();
    var fromUtf84 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
      return Buffer.from(input, "utf8");
    } : util_utf8_browser_1.fromUtf8;
    function convertToBuffer3(data) {
      if (data instanceof Uint8Array)
        return data;
      if (typeof data === "string") {
        return fromUtf84(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
    exports.convertToBuffer = convertToBuffer3;
  }
});

// ../../node_modules/@aws-crypto/util/build/isEmptyData.js
var require_isEmptyData2 = __commonJS({
  "../../node_modules/@aws-crypto/util/build/isEmptyData.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData3(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    exports.isEmptyData = isEmptyData3;
  }
});

// ../../node_modules/@aws-crypto/util/build/numToUint8.js
var require_numToUint8 = __commonJS({
  "../../node_modules/@aws-crypto/util/build/numToUint8.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numToUint8 = void 0;
    function numToUint82(num) {
      return new Uint8Array([
        (num & 4278190080) >> 24,
        (num & 16711680) >> 16,
        (num & 65280) >> 8,
        num & 255
      ]);
    }
    exports.numToUint8 = numToUint82;
  }
});

// ../../node_modules/@aws-crypto/util/build/uint32ArrayFrom.js
var require_uint32ArrayFrom = __commonJS({
  "../../node_modules/@aws-crypto/util/build/uint32ArrayFrom.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = void 0;
    function uint32ArrayFrom2(a_lookUpTable2) {
      if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable2.length);
        var a_index = 0;
        while (a_index < a_lookUpTable2.length) {
          return_array[a_index] = a_lookUpTable2[a_index];
          a_index += 1;
        }
        return return_array;
      }
      return Uint32Array.from(a_lookUpTable2);
    }
    exports.uint32ArrayFrom = uint32ArrayFrom2;
  }
});

// ../../node_modules/@aws-crypto/util/build/index.js
var require_build3 = __commonJS({
  "../../node_modules/@aws-crypto/util/build/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
    var convertToBuffer_1 = require_convertToBuffer();
    Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
      return convertToBuffer_1.convertToBuffer;
    } });
    var isEmptyData_1 = require_isEmptyData2();
    Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
      return isEmptyData_1.isEmptyData;
    } });
    var numToUint8_1 = require_numToUint8();
    Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
      return numToUint8_1.numToUint8;
    } });
    var uint32ArrayFrom_1 = require_uint32ArrayFrom();
    Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
      return uint32ArrayFrom_1.uint32ArrayFrom;
    } });
  }
});

// ../../node_modules/@aws-crypto/sha1-browser/build/crossPlatformSha1.js
var require_crossPlatformSha1 = __commonJS({
  "../../node_modules/@aws-crypto/sha1-browser/build/crossPlatformSha1.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha1 = void 0;
    var ie11Sha1_1 = require_ie11Sha1();
    var webCryptoSha1_1 = require_webCryptoSha1();
    var supports_web_crypto_1 = require_build();
    var ie11_detection_1 = require_build2();
    var util_locate_window_1 = require_dist_cjs2();
    var util_1 = require_build3();
    var Sha12 = (
      /** @class */
      function() {
        function Sha13(secret) {
          if ((0, supports_web_crypto_1.supportsWebCrypto)((0, util_locate_window_1.locateWindow)())) {
            this.hash = new webCryptoSha1_1.Sha1(secret);
          } else if ((0, ie11_detection_1.isMsWindow)((0, util_locate_window_1.locateWindow)())) {
            this.hash = new ie11Sha1_1.Sha1(secret);
          } else {
            throw new Error("SHA1 not supported");
          }
        }
        Sha13.prototype.update = function(data, encoding) {
          this.hash.update((0, util_1.convertToBuffer)(data));
        };
        Sha13.prototype.digest = function() {
          return this.hash.digest();
        };
        Sha13.prototype.reset = function() {
          this.hash.reset();
        };
        return Sha13;
      }()
    );
    exports.Sha1 = Sha12;
  }
});

// ../../node_modules/@aws-crypto/sha1-browser/build/index.js
var require_build4 = __commonJS({
  "../../node_modules/@aws-crypto/sha1-browser/build/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebCryptoSha1 = exports.Ie11Sha1 = void 0;
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_crossPlatformSha1(), exports);
    var ie11Sha1_1 = require_ie11Sha1();
    Object.defineProperty(exports, "Ie11Sha1", { enumerable: true, get: function() {
      return ie11Sha1_1.Sha1;
    } });
    var webCryptoSha1_1 = require_webCryptoSha1();
    Object.defineProperty(exports, "WebCryptoSha1", { enumerable: true, get: function() {
      return webCryptoSha1_1.Sha1;
    } });
  }
});

// ../../node_modules/@aws-crypto/sha256-browser/node_modules/tslib/tslib.js
var require_tslib4 = __commonJS({
  "../../node_modules/@aws-crypto/sha256-browser/node_modules/tslib/tslib.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    var __extends;
    var __assign;
    var __rest2;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter2;
    var __generator2;
    var __exportStar;
    var __values2;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends = function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      __rest2 = function(s2, e2) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values2 = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar2 = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw3) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw3 });
        } else {
          cooked.raw = raw3;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values2);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// ../../node_modules/@aws-crypto/sha256-browser/build/isEmptyData.js
var require_isEmptyData3 = __commonJS({
  "../../node_modules/@aws-crypto/sha256-browser/build/isEmptyData.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmptyData = void 0;
    function isEmptyData3(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    exports.isEmptyData = isEmptyData3;
  }
});

// ../../node_modules/@aws-crypto/sha256-browser/build/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/@aws-crypto/sha256-browser/build/constants.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EMPTY_DATA_SHA_256 = exports.SHA_256_HMAC_ALGO = exports.SHA_256_HASH = void 0;
    exports.SHA_256_HASH = { name: "SHA-256" };
    exports.SHA_256_HMAC_ALGO = {
      name: "HMAC",
      hash: exports.SHA_256_HASH
    };
    exports.EMPTY_DATA_SHA_256 = new Uint8Array([
      227,
      176,
      196,
      66,
      152,
      252,
      28,
      20,
      154,
      251,
      244,
      200,
      153,
      111,
      185,
      36,
      39,
      174,
      65,
      228,
      100,
      155,
      147,
      76,
      164,
      149,
      153,
      27,
      120,
      82,
      184,
      85
    ]);
  }
});

// ../../node_modules/@aws-crypto/sha256-browser/build/ie11Sha256.js
var require_ie11Sha256 = __commonJS({
  "../../node_modules/@aws-crypto/sha256-browser/build/ie11Sha256.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha256 = void 0;
    var isEmptyData_1 = require_isEmptyData3();
    var constants_1 = require_constants2();
    var util_utf8_browser_1 = require_dist_cjs();
    var util_locate_window_1 = require_dist_cjs2();
    var Sha2562 = (
      /** @class */
      function() {
        function Sha2563(secret) {
          this.secret = secret;
          this.reset();
        }
        Sha2563.prototype.update = function(toHash) {
          var _this = this;
          if ((0, isEmptyData_1.isEmptyData)(toHash)) {
            return;
          }
          this.operation = this.operation.then(function(operation) {
            operation.onerror = function() {
              _this.operation = Promise.reject(new Error("Error encountered updating hash"));
            };
            operation.process(toArrayBufferView(toHash));
            return operation;
          });
          this.operation.catch(function() {
          });
        };
        Sha2563.prototype.digest = function() {
          return this.operation.then(function(operation) {
            return new Promise(function(resolve, reject) {
              operation.onerror = function() {
                reject(new Error("Error encountered finalizing hash"));
              };
              operation.oncomplete = function() {
                if (operation.result) {
                  resolve(new Uint8Array(operation.result));
                }
                reject(new Error("Error encountered finalizing hash"));
              };
              operation.finish();
            });
          });
        };
        Sha2563.prototype.reset = function() {
          if (this.secret) {
            this.operation = getKeyPromise(this.secret).then(function(keyData) {
              return (0, util_locate_window_1.locateWindow)().msCrypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, keyData);
            });
            this.operation.catch(function() {
            });
          } else {
            this.operation = Promise.resolve((0, util_locate_window_1.locateWindow)().msCrypto.subtle.digest("SHA-256"));
          }
        };
        return Sha2563;
      }()
    );
    exports.Sha256 = Sha2562;
    function getKeyPromise(secret) {
      return new Promise(function(resolve, reject) {
        var keyOperation = (0, util_locate_window_1.locateWindow)().msCrypto.subtle.importKey("raw", toArrayBufferView(secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]);
        keyOperation.oncomplete = function() {
          if (keyOperation.result) {
            resolve(keyOperation.result);
          }
          reject(new Error("ImportKey completed without importing key."));
        };
        keyOperation.onerror = function() {
          reject(new Error("ImportKey failed to import key."));
        };
      });
    }
    function toArrayBufferView(data) {
      if (typeof data === "string") {
        return (0, util_utf8_browser_1.fromUtf8)(data);
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
  }
});

// ../../node_modules/@aws-crypto/sha256-browser/build/webCryptoSha256.js
var require_webCryptoSha256 = __commonJS({
  "../../node_modules/@aws-crypto/sha256-browser/build/webCryptoSha256.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha256 = void 0;
    var util_1 = require_build3();
    var constants_1 = require_constants2();
    var util_locate_window_1 = require_dist_cjs2();
    var Sha2562 = (
      /** @class */
      function() {
        function Sha2563(secret) {
          this.toHash = new Uint8Array(0);
          this.secret = secret;
          this.reset();
        }
        Sha2563.prototype.update = function(data) {
          if ((0, util_1.isEmptyData)(data)) {
            return;
          }
          var update = (0, util_1.convertToBuffer)(data);
          var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
          typedArray.set(this.toHash, 0);
          typedArray.set(update, this.toHash.byteLength);
          this.toHash = typedArray;
        };
        Sha2563.prototype.digest = function() {
          var _this = this;
          if (this.key) {
            return this.key.then(function(key) {
              return (0, util_locate_window_1.locateWindow)().crypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, key, _this.toHash).then(function(data) {
                return new Uint8Array(data);
              });
            });
          }
          if ((0, util_1.isEmptyData)(this.toHash)) {
            return Promise.resolve(constants_1.EMPTY_DATA_SHA_256);
          }
          return Promise.resolve().then(function() {
            return (0, util_locate_window_1.locateWindow)().crypto.subtle.digest(constants_1.SHA_256_HASH, _this.toHash);
          }).then(function(data) {
            return Promise.resolve(new Uint8Array(data));
          });
        };
        Sha2563.prototype.reset = function() {
          var _this = this;
          this.toHash = new Uint8Array(0);
          if (this.secret && this.secret !== void 0) {
            this.key = new Promise(function(resolve, reject) {
              (0, util_locate_window_1.locateWindow)().crypto.subtle.importKey("raw", (0, util_1.convertToBuffer)(_this.secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]).then(resolve, reject);
            });
            this.key.catch(function() {
            });
          }
        };
        return Sha2563;
      }()
    );
    exports.Sha256 = Sha2562;
  }
});

// ../../node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.js
var require_tslib5 = __commonJS({
  "../../node_modules/@aws-crypto/sha256-js/node_modules/tslib/tslib.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    var __extends;
    var __assign;
    var __rest2;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter2;
    var __generator2;
    var __exportStar;
    var __values2;
    var __read;
    var __spread;
    var __spreadArrays;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v2) {
          return exports2[id] = previous ? previous(id, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      __extends = function(d2, b2) {
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      __rest2 = function(s2, e2) {
        var t2 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
            t2[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t2[p2[i2]] = s2[p2[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve) {
            resolve(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                return t2;
              if (y2 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y2 = 0;
            } finally {
              f2 = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __createBinding = function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      };
      __exportStar = function(m2, exports2) {
        for (var p2 in m2)
          if (p2 !== "default" && !exports2.hasOwnProperty(p2))
            exports2[p2] = m2[p2];
      };
      __values2 = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar2 = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b2) {
                q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw3) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw3 });
        } else {
          cooked.raw = raw3;
        }
        return cooked;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (Object.hasOwnProperty.call(mod, k2))
              result[k2] = mod[k2];
        }
        result["default"] = mod;
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
          throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values2);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// ../../node_modules/@aws-crypto/sha256-js/build/constants.js
var require_constants3 = __commonJS({
  "../../node_modules/@aws-crypto/sha256-js/build/constants.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MAX_HASHABLE_LENGTH = exports.INIT = exports.KEY = exports.DIGEST_LENGTH = exports.BLOCK_SIZE = void 0;
    exports.BLOCK_SIZE = 64;
    exports.DIGEST_LENGTH = 32;
    exports.KEY = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    exports.INIT = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    exports.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
  }
});

// ../../node_modules/@aws-crypto/sha256-js/build/RawSha256.js
var require_RawSha256 = __commonJS({
  "../../node_modules/@aws-crypto/sha256-js/build/RawSha256.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RawSha256 = void 0;
    var constants_1 = require_constants3();
    var RawSha256 = (
      /** @class */
      function() {
        function RawSha2562() {
          this.state = Int32Array.from(constants_1.INIT);
          this.temp = new Int32Array(64);
          this.buffer = new Uint8Array(64);
          this.bufferLength = 0;
          this.bytesHashed = 0;
          this.finished = false;
        }
        RawSha2562.prototype.update = function(data) {
          if (this.finished) {
            throw new Error("Attempted to update an already finished hash.");
          }
          var position = 0;
          var byteLength = data.byteLength;
          this.bytesHashed += byteLength;
          if (this.bytesHashed * 8 > constants_1.MAX_HASHABLE_LENGTH) {
            throw new Error("Cannot hash more than 2^53 - 1 bits");
          }
          while (byteLength > 0) {
            this.buffer[this.bufferLength++] = data[position++];
            byteLength--;
            if (this.bufferLength === constants_1.BLOCK_SIZE) {
              this.hashBuffer();
              this.bufferLength = 0;
            }
          }
        };
        RawSha2562.prototype.digest = function() {
          if (!this.finished) {
            var bitsHashed = this.bytesHashed * 8;
            var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
            var undecoratedLength = this.bufferLength;
            bufferView.setUint8(this.bufferLength++, 128);
            if (undecoratedLength % constants_1.BLOCK_SIZE >= constants_1.BLOCK_SIZE - 8) {
              for (var i2 = this.bufferLength; i2 < constants_1.BLOCK_SIZE; i2++) {
                bufferView.setUint8(i2, 0);
              }
              this.hashBuffer();
              this.bufferLength = 0;
            }
            for (var i2 = this.bufferLength; i2 < constants_1.BLOCK_SIZE - 8; i2++) {
              bufferView.setUint8(i2, 0);
            }
            bufferView.setUint32(constants_1.BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);
            bufferView.setUint32(constants_1.BLOCK_SIZE - 4, bitsHashed);
            this.hashBuffer();
            this.finished = true;
          }
          var out = new Uint8Array(constants_1.DIGEST_LENGTH);
          for (var i2 = 0; i2 < 8; i2++) {
            out[i2 * 4] = this.state[i2] >>> 24 & 255;
            out[i2 * 4 + 1] = this.state[i2] >>> 16 & 255;
            out[i2 * 4 + 2] = this.state[i2] >>> 8 & 255;
            out[i2 * 4 + 3] = this.state[i2] >>> 0 & 255;
          }
          return out;
        };
        RawSha2562.prototype.hashBuffer = function() {
          var _a2 = this, buffer = _a2.buffer, state = _a2.state;
          var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
          for (var i2 = 0; i2 < constants_1.BLOCK_SIZE; i2++) {
            if (i2 < 16) {
              this.temp[i2] = (buffer[i2 * 4] & 255) << 24 | (buffer[i2 * 4 + 1] & 255) << 16 | (buffer[i2 * 4 + 2] & 255) << 8 | buffer[i2 * 4 + 3] & 255;
            } else {
              var u2 = this.temp[i2 - 2];
              var t1_1 = (u2 >>> 17 | u2 << 15) ^ (u2 >>> 19 | u2 << 13) ^ u2 >>> 10;
              u2 = this.temp[i2 - 15];
              var t2_1 = (u2 >>> 7 | u2 << 25) ^ (u2 >>> 18 | u2 << 14) ^ u2 >>> 3;
              this.temp[i2] = (t1_1 + this.temp[i2 - 7] | 0) + (t2_1 + this.temp[i2 - 16] | 0);
            }
            var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (constants_1.KEY[i2] + this.temp[i2] | 0) | 0) | 0;
            var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
            state7 = state6;
            state6 = state5;
            state5 = state4;
            state4 = state3 + t1 | 0;
            state3 = state2;
            state2 = state1;
            state1 = state0;
            state0 = t1 + t2 | 0;
          }
          state[0] += state0;
          state[1] += state1;
          state[2] += state2;
          state[3] += state3;
          state[4] += state4;
          state[5] += state5;
          state[6] += state6;
          state[7] += state7;
        };
        return RawSha2562;
      }()
    );
    exports.RawSha256 = RawSha256;
  }
});

// ../../node_modules/@aws-crypto/sha256-js/build/jsSha256.js
var require_jsSha256 = __commonJS({
  "../../node_modules/@aws-crypto/sha256-js/build/jsSha256.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha256 = void 0;
    var tslib_1 = require_tslib5();
    var constants_1 = require_constants3();
    var RawSha256_1 = require_RawSha256();
    var util_1 = require_build3();
    var Sha2562 = (
      /** @class */
      function() {
        function Sha2563(secret) {
          this.secret = secret;
          this.hash = new RawSha256_1.RawSha256();
          this.reset();
        }
        Sha2563.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash) || this.error) {
            return;
          }
          try {
            this.hash.update((0, util_1.convertToBuffer)(toHash));
          } catch (e2) {
            this.error = e2;
          }
        };
        Sha2563.prototype.digestSync = function() {
          if (this.error) {
            throw this.error;
          }
          if (this.outer) {
            if (!this.outer.finished) {
              this.outer.update(this.hash.digest());
            }
            return this.outer.digest();
          }
          return this.hash.digest();
        };
        Sha2563.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a2) {
              return [2, this.digestSync()];
            });
          });
        };
        Sha2563.prototype.reset = function() {
          this.hash = new RawSha256_1.RawSha256();
          if (this.secret) {
            this.outer = new RawSha256_1.RawSha256();
            var inner = bufferFromSecret(this.secret);
            var outer = new Uint8Array(constants_1.BLOCK_SIZE);
            outer.set(inner);
            for (var i2 = 0; i2 < constants_1.BLOCK_SIZE; i2++) {
              inner[i2] ^= 54;
              outer[i2] ^= 92;
            }
            this.hash.update(inner);
            this.outer.update(outer);
            for (var i2 = 0; i2 < inner.byteLength; i2++) {
              inner[i2] = 0;
            }
          }
        };
        return Sha2563;
      }()
    );
    exports.Sha256 = Sha2562;
    function bufferFromSecret(secret) {
      var input = (0, util_1.convertToBuffer)(secret);
      if (input.byteLength > constants_1.BLOCK_SIZE) {
        var bufferHash = new RawSha256_1.RawSha256();
        bufferHash.update(input);
        input = bufferHash.digest();
      }
      var buffer = new Uint8Array(constants_1.BLOCK_SIZE);
      buffer.set(input);
      return buffer;
    }
  }
});

// ../../node_modules/@aws-crypto/sha256-js/build/index.js
var require_build5 = __commonJS({
  "../../node_modules/@aws-crypto/sha256-js/build/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib5();
    tslib_1.__exportStar(require_jsSha256(), exports);
  }
});

// ../../node_modules/@aws-crypto/sha256-browser/build/crossPlatformSha256.js
var require_crossPlatformSha256 = __commonJS({
  "../../node_modules/@aws-crypto/sha256-browser/build/crossPlatformSha256.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha256 = void 0;
    var ie11Sha256_1 = require_ie11Sha256();
    var webCryptoSha256_1 = require_webCryptoSha256();
    var sha256_js_1 = require_build5();
    var supports_web_crypto_1 = require_build();
    var ie11_detection_1 = require_build2();
    var util_locate_window_1 = require_dist_cjs2();
    var util_1 = require_build3();
    var Sha2562 = (
      /** @class */
      function() {
        function Sha2563(secret) {
          if ((0, supports_web_crypto_1.supportsWebCrypto)((0, util_locate_window_1.locateWindow)())) {
            this.hash = new webCryptoSha256_1.Sha256(secret);
          } else if ((0, ie11_detection_1.isMsWindow)((0, util_locate_window_1.locateWindow)())) {
            this.hash = new ie11Sha256_1.Sha256(secret);
          } else {
            this.hash = new sha256_js_1.Sha256(secret);
          }
        }
        Sha2563.prototype.update = function(data, encoding) {
          this.hash.update((0, util_1.convertToBuffer)(data));
        };
        Sha2563.prototype.digest = function() {
          return this.hash.digest();
        };
        Sha2563.prototype.reset = function() {
          this.hash.reset();
        };
        return Sha2563;
      }()
    );
    exports.Sha256 = Sha2562;
  }
});

// ../../node_modules/@aws-crypto/sha256-browser/build/index.js
var require_build6 = __commonJS({
  "../../node_modules/@aws-crypto/sha256-browser/build/index.js"(exports) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebCryptoSha256 = exports.Ie11Sha256 = void 0;
    var tslib_1 = require_tslib4();
    tslib_1.__exportStar(require_crossPlatformSha256(), exports);
    var ie11Sha256_1 = require_ie11Sha256();
    Object.defineProperty(exports, "Ie11Sha256", { enumerable: true, get: function() {
      return ie11Sha256_1.Sha256;
    } });
    var webCryptoSha256_1 = require_webCryptoSha256();
    Object.defineProperty(exports, "WebCryptoSha256", { enumerable: true, get: function() {
      return webCryptoSha256_1.Sha256;
    } });
  }
});

// ../../node_modules/bowser/es5.js
var require_es5 = __commonJS({
  "../../node_modules/bowser/es5.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    !function(e2, t2) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t2() : "function" == typeof define && define.amd ? define([], t2) : "object" == typeof exports ? exports.bowser = t2() : e2.bowser = t2();
    }(exports, function() {
      return function(e2) {
        var t2 = {};
        function r2(n2) {
          if (t2[n2])
            return t2[n2].exports;
          var i2 = t2[n2] = { i: n2, l: false, exports: {} };
          return e2[n2].call(i2.exports, i2, i2.exports, r2), i2.l = true, i2.exports;
        }
        return r2.m = e2, r2.c = t2, r2.d = function(e3, t3, n2) {
          r2.o(e3, t3) || Object.defineProperty(e3, t3, { enumerable: true, get: n2 });
        }, r2.r = function(e3) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
        }, r2.t = function(e3, t3) {
          if (1 & t3 && (e3 = r2(e3)), 8 & t3)
            return e3;
          if (4 & t3 && "object" == typeof e3 && e3 && e3.__esModule)
            return e3;
          var n2 = /* @__PURE__ */ Object.create(null);
          if (r2.r(n2), Object.defineProperty(n2, "default", { enumerable: true, value: e3 }), 2 & t3 && "string" != typeof e3)
            for (var i2 in e3)
              r2.d(n2, i2, function(t4) {
                return e3[t4];
              }.bind(null, i2));
          return n2;
        }, r2.n = function(e3) {
          var t3 = e3 && e3.__esModule ? function() {
            return e3.default;
          } : function() {
            return e3;
          };
          return r2.d(t3, "a", t3), t3;
        }, r2.o = function(e3, t3) {
          return Object.prototype.hasOwnProperty.call(e3, t3);
        }, r2.p = "", r2(r2.s = 90);
      }({ 17: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2 = r2(18), i2 = function() {
          function e3() {
          }
          return e3.getFirstMatch = function(e4, t3) {
            var r3 = t3.match(e4);
            return r3 && r3.length > 0 && r3[1] || "";
          }, e3.getSecondMatch = function(e4, t3) {
            var r3 = t3.match(e4);
            return r3 && r3.length > 1 && r3[2] || "";
          }, e3.matchAndReturnConst = function(e4, t3, r3) {
            if (e4.test(t3))
              return r3;
          }, e3.getWindowsVersionName = function(e4) {
            switch (e4) {
              case "NT":
                return "NT";
              case "XP":
                return "XP";
              case "NT 5.0":
                return "2000";
              case "NT 5.1":
                return "XP";
              case "NT 5.2":
                return "2003";
              case "NT 6.0":
                return "Vista";
              case "NT 6.1":
                return "7";
              case "NT 6.2":
                return "8";
              case "NT 6.3":
                return "8.1";
              case "NT 10.0":
                return "10";
              default:
                return;
            }
          }, e3.getMacOSVersionName = function(e4) {
            var t3 = e4.split(".").splice(0, 2).map(function(e5) {
              return parseInt(e5, 10) || 0;
            });
            if (t3.push(0), 10 === t3[0])
              switch (t3[1]) {
                case 5:
                  return "Leopard";
                case 6:
                  return "Snow Leopard";
                case 7:
                  return "Lion";
                case 8:
                  return "Mountain Lion";
                case 9:
                  return "Mavericks";
                case 10:
                  return "Yosemite";
                case 11:
                  return "El Capitan";
                case 12:
                  return "Sierra";
                case 13:
                  return "High Sierra";
                case 14:
                  return "Mojave";
                case 15:
                  return "Catalina";
                default:
                  return;
              }
          }, e3.getAndroidVersionName = function(e4) {
            var t3 = e4.split(".").splice(0, 2).map(function(e5) {
              return parseInt(e5, 10) || 0;
            });
            if (t3.push(0), !(1 === t3[0] && t3[1] < 5))
              return 1 === t3[0] && t3[1] < 6 ? "Cupcake" : 1 === t3[0] && t3[1] >= 6 ? "Donut" : 2 === t3[0] && t3[1] < 2 ? "Eclair" : 2 === t3[0] && 2 === t3[1] ? "Froyo" : 2 === t3[0] && t3[1] > 2 ? "Gingerbread" : 3 === t3[0] ? "Honeycomb" : 4 === t3[0] && t3[1] < 1 ? "Ice Cream Sandwich" : 4 === t3[0] && t3[1] < 4 ? "Jelly Bean" : 4 === t3[0] && t3[1] >= 4 ? "KitKat" : 5 === t3[0] ? "Lollipop" : 6 === t3[0] ? "Marshmallow" : 7 === t3[0] ? "Nougat" : 8 === t3[0] ? "Oreo" : 9 === t3[0] ? "Pie" : void 0;
          }, e3.getVersionPrecision = function(e4) {
            return e4.split(".").length;
          }, e3.compareVersions = function(t3, r3, n3) {
            void 0 === n3 && (n3 = false);
            var i3 = e3.getVersionPrecision(t3), s2 = e3.getVersionPrecision(r3), a2 = Math.max(i3, s2), o2 = 0, u2 = e3.map([t3, r3], function(t4) {
              var r4 = a2 - e3.getVersionPrecision(t4), n4 = t4 + new Array(r4 + 1).join(".0");
              return e3.map(n4.split("."), function(e4) {
                return new Array(20 - e4.length).join("0") + e4;
              }).reverse();
            });
            for (n3 && (o2 = a2 - Math.min(i3, s2)), a2 -= 1; a2 >= o2; ) {
              if (u2[0][a2] > u2[1][a2])
                return 1;
              if (u2[0][a2] === u2[1][a2]) {
                if (a2 === o2)
                  return 0;
                a2 -= 1;
              } else if (u2[0][a2] < u2[1][a2])
                return -1;
            }
          }, e3.map = function(e4, t3) {
            var r3, n3 = [];
            if (Array.prototype.map)
              return Array.prototype.map.call(e4, t3);
            for (r3 = 0; r3 < e4.length; r3 += 1)
              n3.push(t3(e4[r3]));
            return n3;
          }, e3.find = function(e4, t3) {
            var r3, n3;
            if (Array.prototype.find)
              return Array.prototype.find.call(e4, t3);
            for (r3 = 0, n3 = e4.length; r3 < n3; r3 += 1) {
              var i3 = e4[r3];
              if (t3(i3, r3))
                return i3;
            }
          }, e3.assign = function(e4) {
            for (var t3, r3, n3 = e4, i3 = arguments.length, s2 = new Array(i3 > 1 ? i3 - 1 : 0), a2 = 1; a2 < i3; a2++)
              s2[a2 - 1] = arguments[a2];
            if (Object.assign)
              return Object.assign.apply(Object, [e4].concat(s2));
            var o2 = function() {
              var e5 = s2[t3];
              "object" == typeof e5 && null !== e5 && Object.keys(e5).forEach(function(t4) {
                n3[t4] = e5[t4];
              });
            };
            for (t3 = 0, r3 = s2.length; t3 < r3; t3 += 1)
              o2();
            return e4;
          }, e3.getBrowserAlias = function(e4) {
            return n2.BROWSER_ALIASES_MAP[e4];
          }, e3.getBrowserTypeByAlias = function(e4) {
            return n2.BROWSER_MAP[e4] || "";
          }, e3;
        }();
        t2.default = i2, e2.exports = t2.default;
      }, 18: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.ENGINE_MAP = t2.OS_MAP = t2.PLATFORMS_MAP = t2.BROWSER_MAP = t2.BROWSER_ALIASES_MAP = void 0;
        t2.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" };
        t2.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" };
        t2.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" };
        t2.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" };
        t2.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
      }, 90: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2, i2 = (n2 = r2(91)) && n2.__esModule ? n2 : { default: n2 }, s2 = r2(18);
        function a2(e3, t3) {
          for (var r3 = 0; r3 < t3.length; r3++) {
            var n3 = t3[r3];
            n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, n3.key, n3);
          }
        }
        var o2 = function() {
          function e3() {
          }
          var t3, r3, n3;
          return e3.getParser = function(e4, t4) {
            if (void 0 === t4 && (t4 = false), "string" != typeof e4)
              throw new Error("UserAgent should be a string");
            return new i2.default(e4, t4);
          }, e3.parse = function(e4) {
            return new i2.default(e4).getResult();
          }, t3 = e3, n3 = [{ key: "BROWSER_MAP", get: function() {
            return s2.BROWSER_MAP;
          } }, { key: "ENGINE_MAP", get: function() {
            return s2.ENGINE_MAP;
          } }, { key: "OS_MAP", get: function() {
            return s2.OS_MAP;
          } }, { key: "PLATFORMS_MAP", get: function() {
            return s2.PLATFORMS_MAP;
          } }], (r3 = null) && a2(t3.prototype, r3), n3 && a2(t3, n3), e3;
        }();
        t2.default = o2, e2.exports = t2.default;
      }, 91: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2 = u2(r2(92)), i2 = u2(r2(93)), s2 = u2(r2(94)), a2 = u2(r2(95)), o2 = u2(r2(17));
        function u2(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        var d2 = function() {
          function e3(e4, t4) {
            if (void 0 === t4 && (t4 = false), null == e4 || "" === e4)
              throw new Error("UserAgent parameter can't be empty");
            this._ua = e4, this.parsedResult = {}, true !== t4 && this.parse();
          }
          var t3 = e3.prototype;
          return t3.getUA = function() {
            return this._ua;
          }, t3.test = function(e4) {
            return e4.test(this._ua);
          }, t3.parseBrowser = function() {
            var e4 = this;
            this.parsedResult.browser = {};
            var t4 = o2.default.find(n2.default, function(t5) {
              if ("function" == typeof t5.test)
                return t5.test(e4);
              if (t5.test instanceof Array)
                return t5.test.some(function(t6) {
                  return e4.test(t6);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t4 && (this.parsedResult.browser = t4.describe(this.getUA())), this.parsedResult.browser;
          }, t3.getBrowser = function() {
            return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
          }, t3.getBrowserName = function(e4) {
            return e4 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
          }, t3.getBrowserVersion = function() {
            return this.getBrowser().version;
          }, t3.getOS = function() {
            return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
          }, t3.parseOS = function() {
            var e4 = this;
            this.parsedResult.os = {};
            var t4 = o2.default.find(i2.default, function(t5) {
              if ("function" == typeof t5.test)
                return t5.test(e4);
              if (t5.test instanceof Array)
                return t5.test.some(function(t6) {
                  return e4.test(t6);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t4 && (this.parsedResult.os = t4.describe(this.getUA())), this.parsedResult.os;
          }, t3.getOSName = function(e4) {
            var t4 = this.getOS().name;
            return e4 ? String(t4).toLowerCase() || "" : t4 || "";
          }, t3.getOSVersion = function() {
            return this.getOS().version;
          }, t3.getPlatform = function() {
            return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
          }, t3.getPlatformType = function(e4) {
            void 0 === e4 && (e4 = false);
            var t4 = this.getPlatform().type;
            return e4 ? String(t4).toLowerCase() || "" : t4 || "";
          }, t3.parsePlatform = function() {
            var e4 = this;
            this.parsedResult.platform = {};
            var t4 = o2.default.find(s2.default, function(t5) {
              if ("function" == typeof t5.test)
                return t5.test(e4);
              if (t5.test instanceof Array)
                return t5.test.some(function(t6) {
                  return e4.test(t6);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t4 && (this.parsedResult.platform = t4.describe(this.getUA())), this.parsedResult.platform;
          }, t3.getEngine = function() {
            return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
          }, t3.getEngineName = function(e4) {
            return e4 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
          }, t3.parseEngine = function() {
            var e4 = this;
            this.parsedResult.engine = {};
            var t4 = o2.default.find(a2.default, function(t5) {
              if ("function" == typeof t5.test)
                return t5.test(e4);
              if (t5.test instanceof Array)
                return t5.test.some(function(t6) {
                  return e4.test(t6);
                });
              throw new Error("Browser's test function is not valid");
            });
            return t4 && (this.parsedResult.engine = t4.describe(this.getUA())), this.parsedResult.engine;
          }, t3.parse = function() {
            return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
          }, t3.getResult = function() {
            return o2.default.assign({}, this.parsedResult);
          }, t3.satisfies = function(e4) {
            var t4 = this, r3 = {}, n3 = 0, i3 = {}, s3 = 0;
            if (Object.keys(e4).forEach(function(t5) {
              var a4 = e4[t5];
              "string" == typeof a4 ? (i3[t5] = a4, s3 += 1) : "object" == typeof a4 && (r3[t5] = a4, n3 += 1);
            }), n3 > 0) {
              var a3 = Object.keys(r3), u3 = o2.default.find(a3, function(e5) {
                return t4.isOS(e5);
              });
              if (u3) {
                var d3 = this.satisfies(r3[u3]);
                if (void 0 !== d3)
                  return d3;
              }
              var c2 = o2.default.find(a3, function(e5) {
                return t4.isPlatform(e5);
              });
              if (c2) {
                var f2 = this.satisfies(r3[c2]);
                if (void 0 !== f2)
                  return f2;
              }
            }
            if (s3 > 0) {
              var l2 = Object.keys(i3), h2 = o2.default.find(l2, function(e5) {
                return t4.isBrowser(e5, true);
              });
              if (void 0 !== h2)
                return this.compareVersion(i3[h2]);
            }
          }, t3.isBrowser = function(e4, t4) {
            void 0 === t4 && (t4 = false);
            var r3 = this.getBrowserName().toLowerCase(), n3 = e4.toLowerCase(), i3 = o2.default.getBrowserTypeByAlias(n3);
            return t4 && i3 && (n3 = i3.toLowerCase()), n3 === r3;
          }, t3.compareVersion = function(e4) {
            var t4 = [0], r3 = e4, n3 = false, i3 = this.getBrowserVersion();
            if ("string" == typeof i3)
              return ">" === e4[0] || "<" === e4[0] ? (r3 = e4.substr(1), "=" === e4[1] ? (n3 = true, r3 = e4.substr(2)) : t4 = [], ">" === e4[0] ? t4.push(1) : t4.push(-1)) : "=" === e4[0] ? r3 = e4.substr(1) : "~" === e4[0] && (n3 = true, r3 = e4.substr(1)), t4.indexOf(o2.default.compareVersions(i3, r3, n3)) > -1;
          }, t3.isOS = function(e4) {
            return this.getOSName(true) === String(e4).toLowerCase();
          }, t3.isPlatform = function(e4) {
            return this.getPlatformType(true) === String(e4).toLowerCase();
          }, t3.isEngine = function(e4) {
            return this.getEngineName(true) === String(e4).toLowerCase();
          }, t3.is = function(e4, t4) {
            return void 0 === t4 && (t4 = false), this.isBrowser(e4, t4) || this.isOS(e4) || this.isPlatform(e4);
          }, t3.some = function(e4) {
            var t4 = this;
            return void 0 === e4 && (e4 = []), e4.some(function(e5) {
              return t4.is(e5);
            });
          }, e3;
        }();
        t2.default = d2, e2.exports = t2.default;
      }, 92: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2, i2 = (n2 = r2(17)) && n2.__esModule ? n2 : { default: n2 };
        var s2 = /version\/(\d+(\.?_?\d+)+)/i, a2 = [{ test: [/googlebot/i], describe: function(e3) {
          var t3 = { name: "Googlebot" }, r3 = i2.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/opera/i], describe: function(e3) {
          var t3 = { name: "Opera" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/opr\/|opios/i], describe: function(e3) {
          var t3 = { name: "Opera" }, r3 = i2.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/SamsungBrowser/i], describe: function(e3) {
          var t3 = { name: "Samsung Internet for Android" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/Whale/i], describe: function(e3) {
          var t3 = { name: "NAVER Whale Browser" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/MZBrowser/i], describe: function(e3) {
          var t3 = { name: "MZ Browser" }, r3 = i2.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/focus/i], describe: function(e3) {
          var t3 = { name: "Focus" }, r3 = i2.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/swing/i], describe: function(e3) {
          var t3 = { name: "Swing" }, r3 = i2.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/coast/i], describe: function(e3) {
          var t3 = { name: "Opera Coast" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(e3) {
          var t3 = { name: "Opera Touch" }, r3 = i2.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/yabrowser/i], describe: function(e3) {
          var t3 = { name: "Yandex Browser" }, r3 = i2.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/ucbrowser/i], describe: function(e3) {
          var t3 = { name: "UC Browser" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/Maxthon|mxios/i], describe: function(e3) {
          var t3 = { name: "Maxthon" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/epiphany/i], describe: function(e3) {
          var t3 = { name: "Epiphany" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/puffin/i], describe: function(e3) {
          var t3 = { name: "Puffin" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/sleipnir/i], describe: function(e3) {
          var t3 = { name: "Sleipnir" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/k-meleon/i], describe: function(e3) {
          var t3 = { name: "K-Meleon" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/micromessenger/i], describe: function(e3) {
          var t3 = { name: "WeChat" }, r3 = i2.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/qqbrowser/i], describe: function(e3) {
          var t3 = { name: /qqbrowserlite/i.test(e3) ? "QQ Browser Lite" : "QQ Browser" }, r3 = i2.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/msie|trident/i], describe: function(e3) {
          var t3 = { name: "Internet Explorer" }, r3 = i2.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/\sedg\//i], describe: function(e3) {
          var t3 = { name: "Microsoft Edge" }, r3 = i2.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/edg([ea]|ios)/i], describe: function(e3) {
          var t3 = { name: "Microsoft Edge" }, r3 = i2.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/vivaldi/i], describe: function(e3) {
          var t3 = { name: "Vivaldi" }, r3 = i2.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/seamonkey/i], describe: function(e3) {
          var t3 = { name: "SeaMonkey" }, r3 = i2.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/sailfish/i], describe: function(e3) {
          var t3 = { name: "Sailfish" }, r3 = i2.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/silk/i], describe: function(e3) {
          var t3 = { name: "Amazon Silk" }, r3 = i2.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/phantom/i], describe: function(e3) {
          var t3 = { name: "PhantomJS" }, r3 = i2.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/slimerjs/i], describe: function(e3) {
          var t3 = { name: "SlimerJS" }, r3 = i2.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e3) {
          var t3 = { name: "BlackBerry" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/(web|hpw)[o0]s/i], describe: function(e3) {
          var t3 = { name: "WebOS Browser" }, r3 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/bada/i], describe: function(e3) {
          var t3 = { name: "Bada" }, r3 = i2.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/tizen/i], describe: function(e3) {
          var t3 = { name: "Tizen" }, r3 = i2.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/qupzilla/i], describe: function(e3) {
          var t3 = { name: "QupZilla" }, r3 = i2.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/firefox|iceweasel|fxios/i], describe: function(e3) {
          var t3 = { name: "Firefox" }, r3 = i2.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/electron/i], describe: function(e3) {
          var t3 = { name: "Electron" }, r3 = i2.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/MiuiBrowser/i], describe: function(e3) {
          var t3 = { name: "Miui" }, r3 = i2.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/chromium/i], describe: function(e3) {
          var t3 = { name: "Chromium" }, r3 = i2.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/chrome|crios|crmo/i], describe: function(e3) {
          var t3 = { name: "Chrome" }, r3 = i2.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/GSA/i], describe: function(e3) {
          var t3 = { name: "Google Search" }, r3 = i2.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: function(e3) {
          var t3 = !e3.test(/like android/i), r3 = e3.test(/android/i);
          return t3 && r3;
        }, describe: function(e3) {
          var t3 = { name: "Android Browser" }, r3 = i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/playstation 4/i], describe: function(e3) {
          var t3 = { name: "PlayStation 4" }, r3 = i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/safari|applewebkit/i], describe: function(e3) {
          var t3 = { name: "Safari" }, r3 = i2.default.getFirstMatch(s2, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/.*/i], describe: function(e3) {
          var t3 = -1 !== e3.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
          return { name: i2.default.getFirstMatch(t3, e3), version: i2.default.getSecondMatch(t3, e3) };
        } }];
        t2.default = a2, e2.exports = t2.default;
      }, 93: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2, i2 = (n2 = r2(17)) && n2.__esModule ? n2 : { default: n2 }, s2 = r2(18);
        var a2 = [{ test: [/Roku\/DVP/], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e3);
          return { name: s2.OS_MAP.Roku, version: t3 };
        } }, { test: [/windows phone/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e3);
          return { name: s2.OS_MAP.WindowsPhone, version: t3 };
        } }, { test: [/windows /i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e3), r3 = i2.default.getWindowsVersionName(t3);
          return { name: s2.OS_MAP.Windows, version: t3, versionName: r3 };
        } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(e3) {
          var t3 = { name: s2.OS_MAP.iOS }, r3 = i2.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/macintosh/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e3).replace(/[_\s]/g, "."), r3 = i2.default.getMacOSVersionName(t3), n3 = { name: s2.OS_MAP.MacOS, version: t3 };
          return r3 && (n3.versionName = r3), n3;
        } }, { test: [/(ipod|iphone|ipad)/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e3).replace(/[_\s]/g, ".");
          return { name: s2.OS_MAP.iOS, version: t3 };
        } }, { test: function(e3) {
          var t3 = !e3.test(/like android/i), r3 = e3.test(/android/i);
          return t3 && r3;
        }, describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e3), r3 = i2.default.getAndroidVersionName(t3), n3 = { name: s2.OS_MAP.Android, version: t3 };
          return r3 && (n3.versionName = r3), n3;
        } }, { test: [/(web|hpw)[o0]s/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e3), r3 = { name: s2.OS_MAP.WebOS };
          return t3 && t3.length && (r3.version = t3), r3;
        } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e3) || i2.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e3) || i2.default.getFirstMatch(/\bbb(\d+)/i, e3);
          return { name: s2.OS_MAP.BlackBerry, version: t3 };
        } }, { test: [/bada/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e3);
          return { name: s2.OS_MAP.Bada, version: t3 };
        } }, { test: [/tizen/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e3);
          return { name: s2.OS_MAP.Tizen, version: t3 };
        } }, { test: [/linux/i], describe: function() {
          return { name: s2.OS_MAP.Linux };
        } }, { test: [/CrOS/], describe: function() {
          return { name: s2.OS_MAP.ChromeOS };
        } }, { test: [/PlayStation 4/], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e3);
          return { name: s2.OS_MAP.PlayStation4, version: t3 };
        } }];
        t2.default = a2, e2.exports = t2.default;
      }, 94: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2, i2 = (n2 = r2(17)) && n2.__esModule ? n2 : { default: n2 }, s2 = r2(18);
        var a2 = [{ test: [/googlebot/i], describe: function() {
          return { type: "bot", vendor: "Google" };
        } }, { test: [/huawei/i], describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/(can-l01)/i, e3) && "Nova", r3 = { type: s2.PLATFORMS_MAP.mobile, vendor: "Huawei" };
          return t3 && (r3.model = t3), r3;
        } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Nexus" };
        } }, { test: [/ipad/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
        } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
        } }, { test: [/kftt build/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
        } }, { test: [/silk/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet, vendor: "Amazon" };
        } }, { test: [/tablet(?! pc)/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet };
        } }, { test: function(e3) {
          var t3 = e3.test(/ipod|iphone/i), r3 = e3.test(/like (ipod|iphone)/i);
          return t3 && !r3;
        }, describe: function(e3) {
          var t3 = i2.default.getFirstMatch(/(ipod|iphone)/i, e3);
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "Apple", model: t3 };
        } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "Nexus" };
        } }, { test: [/[^-]mobi/i], describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile };
        } }, { test: function(e3) {
          return "blackberry" === e3.getBrowserName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
        } }, { test: function(e3) {
          return "bada" === e3.getBrowserName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile };
        } }, { test: function(e3) {
          return "windows phone" === e3.getBrowserName();
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
        } }, { test: function(e3) {
          var t3 = Number(String(e3.getOSVersion()).split(".")[0]);
          return "android" === e3.getOSName(true) && t3 >= 3;
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.tablet };
        } }, { test: function(e3) {
          return "android" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.mobile };
        } }, { test: function(e3) {
          return "macos" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.desktop, vendor: "Apple" };
        } }, { test: function(e3) {
          return "windows" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.desktop };
        } }, { test: function(e3) {
          return "linux" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.desktop };
        } }, { test: function(e3) {
          return "playstation 4" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.tv };
        } }, { test: function(e3) {
          return "roku" === e3.getOSName(true);
        }, describe: function() {
          return { type: s2.PLATFORMS_MAP.tv };
        } }];
        t2.default = a2, e2.exports = t2.default;
      }, 95: function(e2, t2, r2) {
        "use strict";
        t2.__esModule = true, t2.default = void 0;
        var n2, i2 = (n2 = r2(17)) && n2.__esModule ? n2 : { default: n2 }, s2 = r2(18);
        var a2 = [{ test: function(e3) {
          return "microsoft edge" === e3.getBrowserName(true);
        }, describe: function(e3) {
          if (/\sedg\//i.test(e3))
            return { name: s2.ENGINE_MAP.Blink };
          var t3 = i2.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e3);
          return { name: s2.ENGINE_MAP.EdgeHTML, version: t3 };
        } }, { test: [/trident/i], describe: function(e3) {
          var t3 = { name: s2.ENGINE_MAP.Trident }, r3 = i2.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: function(e3) {
          return e3.test(/presto/i);
        }, describe: function(e3) {
          var t3 = { name: s2.ENGINE_MAP.Presto }, r3 = i2.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: function(e3) {
          var t3 = e3.test(/gecko/i), r3 = e3.test(/like gecko/i);
          return t3 && !r3;
        }, describe: function(e3) {
          var t3 = { name: s2.ENGINE_MAP.Gecko }, r3 = i2.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
          return { name: s2.ENGINE_MAP.Blink };
        } }, { test: [/(apple)?webkit/i], describe: function(e3) {
          var t3 = { name: s2.ENGINE_MAP.WebKit }, r3 = i2.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e3);
          return r3 && (t3.version = r3), t3;
        } }];
        t2.default = a2, e2.exports = t2.default;
      } });
    });
  }
});

// ../../node_modules/@prisma/debug/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/@prisma/debug/dist/index.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports2 = {};
    __export2(src_exports2, {
      Debug: () => Debug3,
      clearLogs: () => clearLogs,
      default: () => src_default2,
      getLogs: () => getLogs
    });
    module.exports = __toCommonJS2(src_exports2);
    var colors_exports = {};
    __export2(colors_exports, {
      $: () => $2,
      bgBlack: () => bgBlack2,
      bgBlue: () => bgBlue2,
      bgCyan: () => bgCyan2,
      bgGreen: () => bgGreen2,
      bgMagenta: () => bgMagenta2,
      bgRed: () => bgRed2,
      bgWhite: () => bgWhite2,
      bgYellow: () => bgYellow2,
      black: () => black2,
      blue: () => blue2,
      bold: () => bold2,
      cyan: () => cyan2,
      dim: () => dim2,
      gray: () => gray2,
      green: () => green2,
      grey: () => grey2,
      hidden: () => hidden2,
      inverse: () => inverse2,
      italic: () => italic2,
      magenta: () => magenta2,
      red: () => red2,
      reset: () => reset2,
      strikethrough: () => strikethrough2,
      underline: () => underline2,
      white: () => white2,
      yellow: () => yellow2
    });
    var FORCE_COLOR2;
    var NODE_DISABLE_COLORS2;
    var NO_COLOR2;
    var TERM2;
    var isTTY2 = true;
    if (typeof process !== "undefined") {
      ({ FORCE_COLOR: FORCE_COLOR2, NODE_DISABLE_COLORS: NODE_DISABLE_COLORS2, NO_COLOR: NO_COLOR2, TERM: TERM2 } = process.env || {});
      isTTY2 = process.stdout && process.stdout.isTTY;
    }
    var $2 = {
      enabled: !NODE_DISABLE_COLORS2 && NO_COLOR2 == null && TERM2 !== "dumb" && (FORCE_COLOR2 != null && FORCE_COLOR2 !== "0" || isTTY2)
    };
    function init2(x2, y2) {
      let rgx = new RegExp(`\\x1b\\[${y2}m`, "g");
      let open = `\x1B[${x2}m`, close = `\x1B[${y2}m`;
      return function(txt) {
        if (!$2.enabled || txt == null)
          return txt;
        return open + (!!~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
      };
    }
    var reset2 = init2(0, 0);
    var bold2 = init2(1, 22);
    var dim2 = init2(2, 22);
    var italic2 = init2(3, 23);
    var underline2 = init2(4, 24);
    var inverse2 = init2(7, 27);
    var hidden2 = init2(8, 28);
    var strikethrough2 = init2(9, 29);
    var black2 = init2(30, 39);
    var red2 = init2(31, 39);
    var green2 = init2(32, 39);
    var yellow2 = init2(33, 39);
    var blue2 = init2(34, 39);
    var magenta2 = init2(35, 39);
    var cyan2 = init2(36, 39);
    var white2 = init2(37, 39);
    var gray2 = init2(90, 39);
    var grey2 = init2(90, 39);
    var bgBlack2 = init2(40, 49);
    var bgRed2 = init2(41, 49);
    var bgGreen2 = init2(42, 49);
    var bgYellow2 = init2(43, 49);
    var bgBlue2 = init2(44, 49);
    var bgMagenta2 = init2(45, 49);
    var bgCyan2 = init2(46, 49);
    var bgWhite2 = init2(47, 49);
    var MAX_ARGS_HISTORY = 100;
    var COLORS = ["green", "yellow", "blue", "magenta", "cyan", "red"];
    var argsHistory = [];
    var lastTimestamp = Date.now();
    var lastColor = 0;
    var processEnv = typeof process !== "undefined" ? process.env : {};
    globalThis.DEBUG ?? (globalThis.DEBUG = processEnv.DEBUG ?? "");
    globalThis.DEBUG_COLORS ?? (globalThis.DEBUG_COLORS = processEnv.DEBUG_COLORS ? processEnv.DEBUG_COLORS === "true" : true);
    var topProps = {
      enable(namespace) {
        if (typeof namespace === "string") {
          globalThis.DEBUG = namespace;
        }
      },
      disable() {
        const prev = globalThis.DEBUG;
        globalThis.DEBUG = "";
        return prev;
      },
      // this is the core logic to check if logging should happen or not
      enabled(namespace) {
        const listenedNamespaces = globalThis.DEBUG.split(",").map((s2) => {
          return s2.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
        });
        const isListened = listenedNamespaces.some((listenedNamespace) => {
          if (listenedNamespace === "" || listenedNamespace[0] === "-")
            return false;
          return namespace.match(RegExp(listenedNamespace.split("*").join(".*") + "$"));
        });
        const isExcluded = listenedNamespaces.some((listenedNamespace) => {
          if (listenedNamespace === "" || listenedNamespace[0] !== "-")
            return false;
          return namespace.match(RegExp(listenedNamespace.slice(1).split("*").join(".*") + "$"));
        });
        return isListened && !isExcluded;
      },
      log: (...args) => {
        const [namespace, format, ...rest] = args;
        let logger2;
        if (typeof __require === "function" && typeof process !== "undefined" && typeof process.stderr !== "undefined" && typeof process.stderr.write === "function") {
          logger2 = (...args2) => {
            try {
              const util2 = __require(`${"util"}`);
              process.stderr.write(util2.format(...args2) + "\n");
            } catch (e2) {
              logger2 = console.warn ?? console.log;
            }
          };
        } else {
          logger2 = console.warn ?? console.log;
        }
        logger2(`${namespace} ${format}`, ...rest);
      },
      formatters: {}
      // not implemented
    };
    function debugCreate(namespace) {
      const instanceProps = {
        color: COLORS[lastColor++ % COLORS.length],
        enabled: topProps.enabled(namespace),
        namespace,
        log: topProps.log,
        extend: () => {
        }
        // not implemented
      };
      const debugCall = (...args) => {
        const { enabled, namespace: namespace2, color, log } = instanceProps;
        if (args.length !== 0) {
          argsHistory.push([namespace2, ...args]);
        }
        if (argsHistory.length > MAX_ARGS_HISTORY) {
          argsHistory.shift();
        }
        if (topProps.enabled(namespace2) || enabled) {
          const stringArgs = args.map((arg) => {
            if (typeof arg === "string") {
              return arg;
            }
            return safeStringify(arg);
          });
          const ms = `+${Date.now() - lastTimestamp}ms`;
          lastTimestamp = Date.now();
          if (globalThis.DEBUG_COLORS) {
            log(colors_exports[color](bold2(namespace2)), ...stringArgs, colors_exports[color](ms));
          } else {
            log(namespace2, ...stringArgs, ms);
          }
        }
      };
      return new Proxy(debugCall, {
        get: (_, prop) => instanceProps[prop],
        set: (_, prop, value) => instanceProps[prop] = value
      });
    }
    var Debug3 = new Proxy(debugCreate, {
      get: (_, prop) => topProps[prop],
      set: (_, prop, value) => topProps[prop] = value
    });
    function safeStringify(value, indent = 2) {
      const cache = /* @__PURE__ */ new Set();
      return JSON.stringify(
        value,
        (key, value2) => {
          if (typeof value2 === "object" && value2 !== null) {
            if (cache.has(value2)) {
              return `[Circular *]`;
            }
            cache.add(value2);
          } else if (typeof value2 === "bigint") {
            return value2.toString();
          }
          return value2;
        },
        indent
      );
    }
    function getLogs(numChars = 7500) {
      const logs = argsHistory.map(([namespace, ...args]) => {
        return `${namespace} ${args.map((arg) => {
          if (typeof arg === "string") {
            return arg;
          } else {
            return JSON.stringify(arg);
          }
        }).join(" ")}`;
      }).join("\n");
      if (logs.length < numChars) {
        return logs;
      }
      return logs.slice(-numChars);
    }
    function clearLogs() {
      argsHistory.length = 0;
    }
    var src_default2 = Debug3;
  }
});

// ../../node_modules/@prisma/client/runtime/wasm.js
var require_wasm = __commonJS({
  "../../node_modules/@prisma/client/runtime/wasm.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var ko = Object.create;
    var Et = Object.defineProperty;
    var Lo = Object.getOwnPropertyDescriptor;
    var Mo = Object.getOwnPropertyNames;
    var Io = Object.getPrototypeOf;
    var _o = Object.prototype.hasOwnProperty;
    var oe = (e2, t2) => () => (e2 && (t2 = e2(e2 = 0)), t2);
    var Te = (e2, t2) => () => (t2 || e2((t2 = { exports: {} }).exports, t2), t2.exports);
    var ze = (e2, t2) => {
      for (var r2 in t2)
        Et(e2, r2, { get: t2[r2], enumerable: true });
    };
    var Kr = (e2, t2, r2, n2) => {
      if (t2 && typeof t2 == "object" || typeof t2 == "function")
        for (let i2 of Mo(t2))
          !_o.call(e2, i2) && i2 !== r2 && Et(e2, i2, { get: () => t2[i2], enumerable: !(n2 = Lo(t2, i2)) || n2.enumerable });
      return e2;
    };
    var _e = (e2, t2, r2) => (r2 = e2 != null ? ko(Io(e2)) : {}, Kr(t2 || !e2 || !e2.__esModule ? Et(r2, "default", { value: e2, enumerable: true }) : r2, e2));
    var ar2 = (e2) => Kr(Et({}, "__esModule", { value: true }), e2);
    function lr(e2, t2) {
      if (t2 = t2.toLowerCase(), t2 === "utf8" || t2 === "utf-8")
        return new h2(Bo.encode(e2));
      if (t2 === "base64" || t2 === "base64url")
        return e2 = e2.replace(/-/g, "+").replace(/_/g, "/"), e2 = e2.replace(/[^A-Za-z0-9+/]/g, ""), new h2([...atob(e2)].map((r2) => r2.charCodeAt(0)));
      if (t2 === "binary" || t2 === "ascii" || t2 === "latin1" || t2 === "latin-1")
        return new h2([...e2].map((r2) => r2.charCodeAt(0)));
      if (t2 === "ucs2" || t2 === "ucs-2" || t2 === "utf16le" || t2 === "utf-16le") {
        let r2 = new h2(e2.length * 2), n2 = new DataView(r2.buffer);
        for (let i2 = 0; i2 < e2.length; i2++)
          n2.setUint16(i2 * 2, e2.charCodeAt(i2), true);
        return r2;
      }
      if (t2 === "hex") {
        let r2 = new h2(e2.length / 2);
        for (let n2 = 0, i2 = 0; i2 < e2.length; i2 += 2, n2++)
          r2[n2] = parseInt(e2.slice(i2, i2 + 2), 16);
        return r2;
      }
      zr(`encoding "${t2}"`);
    }
    function Do(e2) {
      let r2 = Object.getOwnPropertyNames(DataView.prototype).filter((a2) => a2.startsWith("get") || a2.startsWith("set")), n2 = r2.map((a2) => a2.replace("get", "read").replace("set", "write")), i2 = (a2, f2) => function(v2 = 0) {
        return $2(v2, "offset"), Y2(v2, "offset"), q2(v2, "offset", this.length - 1), new DataView(this.buffer)[r2[a2]](v2, f2);
      }, o2 = (a2, f2) => function(v2, C2 = 0) {
        let T2 = r2[a2].match(/set(\w+\d+)/)[1].toLowerCase(), O2 = No[T2];
        return $2(C2, "offset"), Y2(C2, "offset"), q2(C2, "offset", this.length - 1), Fo(v2, "value", O2[0], O2[1]), new DataView(this.buffer)[r2[a2]](C2, v2, f2), C2 + parseInt(r2[a2].match(/\d+/)[0]) / 8;
      }, s2 = (a2) => {
        a2.forEach((f2) => {
          f2.includes("Uint") && (e2[f2.replace("Uint", "UInt")] = e2[f2]), f2.includes("Float64") && (e2[f2.replace("Float64", "Double")] = e2[f2]), f2.includes("Float32") && (e2[f2.replace("Float32", "Float")] = e2[f2]);
        });
      };
      n2.forEach((a2, f2) => {
        a2.startsWith("read") && (e2[a2] = i2(f2, false), e2[a2 + "LE"] = i2(f2, true), e2[a2 + "BE"] = i2(f2, false)), a2.startsWith("write") && (e2[a2] = o2(f2, false), e2[a2 + "LE"] = o2(f2, true), e2[a2 + "BE"] = o2(f2, false)), s2([a2, a2 + "LE", a2 + "BE"]);
      });
    }
    function zr(e2) {
      throw new Error(`Buffer polyfill does not implement "${e2}"`);
    }
    function xt(e2, t2) {
      if (!(e2 instanceof Uint8Array))
        throw new TypeError(`The "${t2}" argument must be an instance of Buffer or Uint8Array`);
    }
    function q2(e2, t2, r2 = Vo + 1) {
      if (e2 < 0 || e2 > r2) {
        let n2 = new RangeError(`The value of "${t2}" is out of range. It must be >= 0 && <= ${r2}. Received ${e2}`);
        throw n2.code = "ERR_OUT_OF_RANGE", n2;
      }
    }
    function $2(e2, t2) {
      if (typeof e2 != "number") {
        let r2 = new TypeError(`The "${t2}" argument must be of type number. Received type ${typeof e2}.`);
        throw r2.code = "ERR_INVALID_ARG_TYPE", r2;
      }
    }
    function Y2(e2, t2) {
      if (!Number.isInteger(e2) || Number.isNaN(e2)) {
        let r2 = new RangeError(`The value of "${t2}" is out of range. It must be an integer. Received ${e2}`);
        throw r2.code = "ERR_OUT_OF_RANGE", r2;
      }
    }
    function Fo(e2, t2, r2, n2) {
      if (e2 < r2 || e2 > n2) {
        let i2 = new RangeError(`The value of "${t2}" is out of range. It must be >= ${r2} and <= ${n2}. Received ${e2}`);
        throw i2.code = "ERR_OUT_OF_RANGE", i2;
      }
    }
    function Hr(e2, t2) {
      if (typeof e2 != "string") {
        let r2 = new TypeError(`The "${t2}" argument must be of type string. Received type ${typeof e2}`);
        throw r2.code = "ERR_INVALID_ARG_TYPE", r2;
      }
    }
    function qo(e2, t2 = "utf8") {
      return h2.from(e2, t2);
    }
    var h2;
    var No;
    var Bo;
    var Uo;
    var $o;
    var Vo;
    var y2;
    var ur;
    var u2 = oe(() => {
      "use strict";
      h2 = class e2 extends Uint8Array {
        constructor() {
          super(...arguments);
          this._isBuffer = true;
        }
        get offset() {
          return this.byteOffset;
        }
        static alloc(r2, n2 = 0, i2 = "utf8") {
          return Hr(i2, "encoding"), e2.allocUnsafe(r2).fill(n2, i2);
        }
        static allocUnsafe(r2) {
          return e2.from(r2);
        }
        static allocUnsafeSlow(r2) {
          return e2.from(r2);
        }
        static isBuffer(r2) {
          return r2 && !!r2._isBuffer;
        }
        static byteLength(r2, n2 = "utf8") {
          if (typeof r2 == "string")
            return lr(r2, n2).byteLength;
          if (r2 && r2.byteLength)
            return r2.byteLength;
          let i2 = new TypeError('The "string" argument must be of type string or an instance of Buffer or ArrayBuffer.');
          throw i2.code = "ERR_INVALID_ARG_TYPE", i2;
        }
        static isEncoding(r2) {
          return $o.includes(r2);
        }
        static compare(r2, n2) {
          xt(r2, "buff1"), xt(n2, "buff2");
          for (let i2 = 0; i2 < r2.length; i2++) {
            if (r2[i2] < n2[i2])
              return -1;
            if (r2[i2] > n2[i2])
              return 1;
          }
          return r2.length === n2.length ? 0 : r2.length > n2.length ? 1 : -1;
        }
        static from(r2, n2 = "utf8") {
          if (r2 && typeof r2 == "object" && r2.type === "Buffer")
            return new e2(r2.data);
          if (typeof r2 == "number")
            return new e2(new Uint8Array(r2));
          if (typeof r2 == "string")
            return lr(r2, n2);
          if (ArrayBuffer.isView(r2)) {
            let { byteOffset: i2, byteLength: o2, buffer: s2 } = r2;
            return "map" in r2 && typeof r2.map == "function" ? new e2(r2.map((a2) => a2 % 256), i2, o2) : new e2(s2, i2, o2);
          }
          if (r2 && typeof r2 == "object" && ("length" in r2 || "byteLength" in r2 || "buffer" in r2))
            return new e2(r2);
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }
        static concat(r2, n2) {
          if (r2.length === 0)
            return e2.alloc(0);
          let i2 = [].concat(...r2.map((s2) => [...s2])), o2 = e2.alloc(n2 !== void 0 ? n2 : i2.length);
          return o2.set(n2 !== void 0 ? i2.slice(0, n2) : i2), o2;
        }
        slice(r2 = 0, n2 = this.length) {
          return this.subarray(r2, n2);
        }
        subarray(r2 = 0, n2 = this.length) {
          return Object.setPrototypeOf(super.subarray(r2, n2), e2.prototype);
        }
        reverse() {
          return super.reverse(), this;
        }
        readIntBE(r2, n2) {
          $2(r2, "offset"), Y2(r2, "offset"), q2(r2, "offset", this.length - 1), $2(n2, "byteLength"), Y2(n2, "byteLength");
          let i2 = new DataView(this.buffer, r2, n2), o2 = 0;
          for (let s2 = 0; s2 < n2; s2++)
            o2 = o2 * 256 + i2.getUint8(s2);
          return i2.getUint8(0) & 128 && (o2 -= Math.pow(256, n2)), o2;
        }
        readIntLE(r2, n2) {
          $2(r2, "offset"), Y2(r2, "offset"), q2(r2, "offset", this.length - 1), $2(n2, "byteLength"), Y2(n2, "byteLength");
          let i2 = new DataView(this.buffer, r2, n2), o2 = 0;
          for (let s2 = 0; s2 < n2; s2++)
            o2 += i2.getUint8(s2) * Math.pow(256, s2);
          return i2.getUint8(n2 - 1) & 128 && (o2 -= Math.pow(256, n2)), o2;
        }
        readUIntBE(r2, n2) {
          $2(r2, "offset"), Y2(r2, "offset"), q2(r2, "offset", this.length - 1), $2(n2, "byteLength"), Y2(n2, "byteLength");
          let i2 = new DataView(this.buffer, r2, n2), o2 = 0;
          for (let s2 = 0; s2 < n2; s2++)
            o2 = o2 * 256 + i2.getUint8(s2);
          return o2;
        }
        readUintBE(r2, n2) {
          return this.readUIntBE(r2, n2);
        }
        readUIntLE(r2, n2) {
          $2(r2, "offset"), Y2(r2, "offset"), q2(r2, "offset", this.length - 1), $2(n2, "byteLength"), Y2(n2, "byteLength");
          let i2 = new DataView(this.buffer, r2, n2), o2 = 0;
          for (let s2 = 0; s2 < n2; s2++)
            o2 += i2.getUint8(s2) * Math.pow(256, s2);
          return o2;
        }
        readUintLE(r2, n2) {
          return this.readUIntLE(r2, n2);
        }
        writeIntBE(r2, n2, i2) {
          return r2 = r2 < 0 ? r2 + Math.pow(256, i2) : r2, this.writeUIntBE(r2, n2, i2);
        }
        writeIntLE(r2, n2, i2) {
          return r2 = r2 < 0 ? r2 + Math.pow(256, i2) : r2, this.writeUIntLE(r2, n2, i2);
        }
        writeUIntBE(r2, n2, i2) {
          $2(n2, "offset"), Y2(n2, "offset"), q2(n2, "offset", this.length - 1), $2(i2, "byteLength"), Y2(i2, "byteLength");
          let o2 = new DataView(this.buffer, n2, i2);
          for (let s2 = i2 - 1; s2 >= 0; s2--)
            o2.setUint8(s2, r2 & 255), r2 = r2 / 256;
          return n2 + i2;
        }
        writeUintBE(r2, n2, i2) {
          return this.writeUIntBE(r2, n2, i2);
        }
        writeUIntLE(r2, n2, i2) {
          $2(n2, "offset"), Y2(n2, "offset"), q2(n2, "offset", this.length - 1), $2(i2, "byteLength"), Y2(i2, "byteLength");
          let o2 = new DataView(this.buffer, n2, i2);
          for (let s2 = 0; s2 < i2; s2++)
            o2.setUint8(s2, r2 & 255), r2 = r2 / 256;
          return n2 + i2;
        }
        writeUintLE(r2, n2, i2) {
          return this.writeUIntLE(r2, n2, i2);
        }
        toJSON() {
          return { type: "Buffer", data: Array.from(this) };
        }
        swap16() {
          let r2 = new DataView(this.buffer, this.byteOffset, this.byteLength);
          for (let n2 = 0; n2 < this.length; n2 += 2)
            r2.setUint16(n2, r2.getUint16(n2, true), false);
          return this;
        }
        swap32() {
          let r2 = new DataView(this.buffer, this.byteOffset, this.byteLength);
          for (let n2 = 0; n2 < this.length; n2 += 4)
            r2.setUint32(n2, r2.getUint32(n2, true), false);
          return this;
        }
        swap64() {
          let r2 = new DataView(this.buffer, this.byteOffset, this.byteLength);
          for (let n2 = 0; n2 < this.length; n2 += 8)
            r2.setBigUint64(n2, r2.getBigUint64(n2, true), false);
          return this;
        }
        compare(r2, n2 = 0, i2 = r2.length, o2 = 0, s2 = this.length) {
          return xt(r2, "target"), $2(n2, "targetStart"), $2(i2, "targetEnd"), $2(o2, "sourceStart"), $2(s2, "sourceEnd"), q2(n2, "targetStart"), q2(i2, "targetEnd", r2.length), q2(o2, "sourceStart"), q2(s2, "sourceEnd", this.length), e2.compare(this.slice(o2, s2), r2.slice(n2, i2));
        }
        equals(r2) {
          return xt(r2, "otherBuffer"), this.length === r2.length && this.every((n2, i2) => n2 === r2[i2]);
        }
        copy(r2, n2 = 0, i2 = 0, o2 = this.length) {
          q2(n2, "targetStart"), q2(i2, "sourceStart", this.length), q2(o2, "sourceEnd"), n2 >>>= 0, i2 >>>= 0, o2 >>>= 0;
          let s2 = 0;
          for (; i2 < o2 && !(this[i2] === void 0 || r2[n2] === void 0); )
            r2[n2] = this[i2], s2++, i2++, n2++;
          return s2;
        }
        write(r2, n2, i2, o2 = "utf8") {
          let s2 = typeof n2 == "string" ? 0 : n2 ?? 0, a2 = typeof i2 == "string" ? this.length - s2 : i2 ?? this.length - s2;
          return o2 = typeof n2 == "string" ? n2 : typeof i2 == "string" ? i2 : o2, $2(s2, "offset"), $2(a2, "length"), q2(s2, "offset", this.length), q2(a2, "length", this.length), (o2 === "ucs2" || o2 === "ucs-2" || o2 === "utf16le" || o2 === "utf-16le") && (a2 = a2 - a2 % 2), lr(r2, o2).copy(this, s2, 0, a2);
        }
        fill(r2 = 0, n2 = 0, i2 = this.length, o2 = "utf-8") {
          let s2 = typeof n2 == "string" ? 0 : n2, a2 = typeof i2 == "string" ? this.length : i2;
          if (o2 = typeof n2 == "string" ? n2 : typeof i2 == "string" ? i2 : o2, r2 = e2.from(typeof r2 == "number" ? [r2] : r2 ?? [], o2), Hr(o2, "encoding"), q2(s2, "offset", this.length), q2(a2, "end", this.length), r2.length !== 0)
            for (let f2 = s2; f2 < a2; f2 += r2.length)
              super.set(r2.slice(0, r2.length + f2 >= this.length ? this.length - f2 : r2.length), f2);
          return this;
        }
        includes(r2, n2 = null, i2 = "utf-8") {
          return this.indexOf(r2, n2, i2) !== -1;
        }
        lastIndexOf(r2, n2 = null, i2 = "utf-8") {
          return this.indexOf(r2, n2, i2, true);
        }
        indexOf(r2, n2 = null, i2 = "utf-8", o2 = false) {
          let s2 = o2 ? this.findLastIndex.bind(this) : this.findIndex.bind(this);
          i2 = typeof n2 == "string" ? n2 : i2;
          let a2 = e2.from(typeof r2 == "number" ? [r2] : r2, i2), f2 = typeof n2 == "string" ? 0 : n2;
          return f2 = typeof n2 == "number" ? f2 : null, f2 = Number.isNaN(f2) ? null : f2, f2 ??= o2 ? this.length : 0, f2 = f2 < 0 ? this.length + f2 : f2, a2.length === 0 && o2 === false ? f2 >= this.length ? this.length : f2 : a2.length === 0 && o2 === true ? (f2 >= this.length ? this.length : f2) || this.length : s2((v2, C2) => (o2 ? C2 <= f2 : C2 >= f2) && this[C2] === a2[0] && a2.every((O2, R2) => this[C2 + R2] === O2));
        }
        toString(r2 = "utf8", n2 = 0, i2 = this.length) {
          if (n2 = n2 < 0 ? 0 : n2, r2 = r2.toString().toLowerCase(), i2 <= 0)
            return "";
          if (r2 === "utf8" || r2 === "utf-8")
            return Uo.decode(this.slice(n2, i2));
          if (r2 === "base64" || r2 === "base64url") {
            let o2 = btoa(this.reduce((s2, a2) => s2 + ur(a2), ""));
            return r2 === "base64url" ? o2.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "") : o2;
          }
          if (r2 === "binary" || r2 === "ascii" || r2 === "latin1" || r2 === "latin-1")
            return this.slice(n2, i2).reduce((o2, s2) => o2 + ur(s2 & (r2 === "ascii" ? 127 : 255)), "");
          if (r2 === "ucs2" || r2 === "ucs-2" || r2 === "utf16le" || r2 === "utf-16le") {
            let o2 = new DataView(this.buffer.slice(n2, i2));
            return Array.from({ length: o2.byteLength / 2 }, (s2, a2) => a2 * 2 + 1 < o2.byteLength ? ur(o2.getUint16(a2 * 2, true)) : "").join("");
          }
          if (r2 === "hex")
            return this.slice(n2, i2).reduce((o2, s2) => o2 + s2.toString(16).padStart(2, "0"), "");
          zr(`encoding "${r2}"`);
        }
        toLocaleString() {
          return this.toString();
        }
        inspect() {
          return `<Buffer ${this.toString("hex").match(/.{1,2}/g).join(" ")}>`;
        }
      };
      No = { int8: [-128, 127], int16: [-32768, 32767], int32: [-2147483648, 2147483647], uint8: [0, 255], uint16: [0, 65535], uint32: [0, 4294967295], float32: [-1 / 0, 1 / 0], float64: [-1 / 0, 1 / 0], bigint64: [-0x8000000000000000n, 0x7fffffffffffffffn], biguint64: [0n, 0xffffffffffffffffn] }, Bo = new TextEncoder(), Uo = new TextDecoder(), $o = ["utf8", "utf-8", "hex", "base64", "ascii", "binary", "base64url", "ucs2", "ucs-2", "utf16le", "utf-16le", "latin1", "latin-1"], Vo = 4294967295;
      Do(h2.prototype);
      y2 = new Proxy(qo, { construct(e2, [t2, r2]) {
        return h2.from(t2, r2);
      }, get(e2, t2) {
        return h2[t2];
      } }), ur = String.fromCodePoint;
    });
    var g2;
    var c2 = oe(() => {
      "use strict";
      g2 = { nextTick: (e2, ...t2) => {
        setTimeout(() => {
          e2(...t2);
        }, 0);
      }, env: {}, version: "", cwd: () => "/", stderr: {}, argv: ["/bin/node"] };
    });
    var E2;
    var m2 = oe(() => {
      "use strict";
      E2 = globalThis.performance ?? (() => {
        let e2 = Date.now();
        return { now: () => Date.now() - e2 };
      })();
    });
    var w2;
    var p2 = oe(() => {
      "use strict";
      w2 = () => {
      };
      w2.prototype = w2;
    });
    var b2;
    var d2 = oe(() => {
      "use strict";
      b2 = class {
        constructor(t2) {
          this.value = t2;
        }
        deref() {
          return this.value;
        }
      };
    });
    function en(e2, t2) {
      var r2, n2, i2, o2, s2, a2, f2, v2, C2 = e2.constructor, T2 = C2.precision;
      if (!e2.s || !t2.s)
        return t2.s || (t2 = new C2(e2)), B2 ? _(t2, T2) : t2;
      if (f2 = e2.d, v2 = t2.d, s2 = e2.e, i2 = t2.e, f2 = f2.slice(), o2 = s2 - i2, o2) {
        for (o2 < 0 ? (n2 = f2, o2 = -o2, a2 = v2.length) : (n2 = v2, i2 = s2, a2 = f2.length), s2 = Math.ceil(T2 / F2), a2 = s2 > a2 ? s2 + 1 : a2 + 1, o2 > a2 && (o2 = a2, n2.length = 1), n2.reverse(); o2--; )
          n2.push(0);
        n2.reverse();
      }
      for (a2 = f2.length, o2 = v2.length, a2 - o2 < 0 && (o2 = a2, n2 = v2, v2 = f2, f2 = n2), r2 = 0; o2; )
        r2 = (f2[--o2] = f2[o2] + v2[o2] + r2) / j2 | 0, f2[o2] %= j2;
      for (r2 && (f2.unshift(r2), ++i2), a2 = f2.length; f2[--a2] == 0; )
        f2.pop();
      return t2.d = f2, t2.e = i2, B2 ? _(t2, T2) : t2;
    }
    function le(e2, t2, r2) {
      if (e2 !== ~~e2 || e2 < t2 || e2 > r2)
        throw Error(Re + e2);
    }
    function ae2(e2) {
      var t2, r2, n2, i2 = e2.length - 1, o2 = "", s2 = e2[0];
      if (i2 > 0) {
        for (o2 += s2, t2 = 1; t2 < i2; t2++)
          n2 = e2[t2] + "", r2 = F2 - n2.length, r2 && (o2 += we(r2)), o2 += n2;
        s2 = e2[t2], n2 = s2 + "", r2 = F2 - n2.length, r2 && (o2 += we(r2));
      } else if (s2 === 0)
        return "0";
      for (; s2 % 10 === 0; )
        s2 /= 10;
      return o2 + s2;
    }
    function tn(e2, t2) {
      var r2, n2, i2, o2, s2, a2, f2 = 0, v2 = 0, C2 = e2.constructor, T2 = C2.precision;
      if (V2(e2) > 16)
        throw Error(mr + V2(e2));
      if (!e2.s)
        return new C2(Z2);
      for (t2 == null ? (B2 = false, a2 = T2) : a2 = t2, s2 = new C2(0.03125); e2.abs().gte(0.1); )
        e2 = e2.times(s2), v2 += 5;
      for (n2 = Math.log(Ae(2, v2)) / Math.LN10 * 2 + 5 | 0, a2 += n2, r2 = i2 = o2 = new C2(Z2), C2.precision = a2; ; ) {
        if (i2 = _(i2.times(e2), a2), r2 = r2.times(++f2), s2 = o2.plus(ge(i2, r2, a2)), ae2(s2.d).slice(0, a2) === ae2(o2.d).slice(0, a2)) {
          for (; v2--; )
            o2 = _(o2.times(o2), a2);
          return C2.precision = T2, t2 == null ? (B2 = true, _(o2, T2)) : o2;
        }
        o2 = s2;
      }
    }
    function V2(e2) {
      for (var t2 = e2.e * F2, r2 = e2.d[0]; r2 >= 10; r2 /= 10)
        t2++;
      return t2;
    }
    function cr2(e2, t2, r2) {
      if (t2 > e2.LN10.sd())
        throw B2 = true, r2 && (e2.precision = r2), Error(te + "LN10 precision limit exceeded");
      return _(new e2(e2.LN10), t2);
    }
    function we(e2) {
      for (var t2 = ""; e2--; )
        t2 += "0";
      return t2;
    }
    function Ye(e2, t2) {
      var r2, n2, i2, o2, s2, a2, f2, v2, C2, T2 = 1, O2 = 10, R2 = e2, L2 = R2.d, S2 = R2.constructor, M2 = S2.precision;
      if (R2.s < 1)
        throw Error(te + (R2.s ? "NaN" : "-Infinity"));
      if (R2.eq(Z2))
        return new S2(0);
      if (t2 == null ? (B2 = false, v2 = M2) : v2 = t2, R2.eq(10))
        return t2 == null && (B2 = true), cr2(S2, v2);
      if (v2 += O2, S2.precision = v2, r2 = ae2(L2), n2 = r2.charAt(0), o2 = V2(R2), Math.abs(o2) < 15e14) {
        for (; n2 < 7 && n2 != 1 || n2 == 1 && r2.charAt(1) > 3; )
          R2 = R2.times(e2), r2 = ae2(R2.d), n2 = r2.charAt(0), T2++;
        o2 = V2(R2), n2 > 1 ? (R2 = new S2("0." + r2), o2++) : R2 = new S2(n2 + "." + r2.slice(1));
      } else
        return f2 = cr2(S2, v2 + 2, M2).times(o2 + ""), R2 = Ye(new S2(n2 + "." + r2.slice(1)), v2 - O2).plus(f2), S2.precision = M2, t2 == null ? (B2 = true, _(R2, M2)) : R2;
      for (a2 = s2 = R2 = ge(R2.minus(Z2), R2.plus(Z2), v2), C2 = _(R2.times(R2), v2), i2 = 3; ; ) {
        if (s2 = _(s2.times(C2), v2), f2 = a2.plus(ge(s2, new S2(i2), v2)), ae2(f2.d).slice(0, v2) === ae2(a2.d).slice(0, v2))
          return a2 = a2.times(2), o2 !== 0 && (a2 = a2.plus(cr2(S2, v2 + 2, M2).times(o2 + ""))), a2 = ge(a2, new S2(T2), v2), S2.precision = M2, t2 == null ? (B2 = true, _(a2, M2)) : a2;
        a2 = f2, i2 += 2;
      }
    }
    function Yr(e2, t2) {
      var r2, n2, i2;
      for ((r2 = t2.indexOf(".")) > -1 && (t2 = t2.replace(".", "")), (n2 = t2.search(/e/i)) > 0 ? (r2 < 0 && (r2 = n2), r2 += +t2.slice(n2 + 1), t2 = t2.substring(0, n2)) : r2 < 0 && (r2 = t2.length), n2 = 0; t2.charCodeAt(n2) === 48; )
        ++n2;
      for (i2 = t2.length; t2.charCodeAt(i2 - 1) === 48; )
        --i2;
      if (t2 = t2.slice(n2, i2), t2) {
        if (i2 -= n2, r2 = r2 - n2 - 1, e2.e = Fe(r2 / F2), e2.d = [], n2 = (r2 + 1) % F2, r2 < 0 && (n2 += F2), n2 < i2) {
          for (n2 && e2.d.push(+t2.slice(0, n2)), i2 -= F2; n2 < i2; )
            e2.d.push(+t2.slice(n2, n2 += F2));
          t2 = t2.slice(n2), n2 = F2 - t2.length;
        } else
          n2 -= i2;
        for (; n2--; )
          t2 += "0";
        if (e2.d.push(+t2), B2 && (e2.e > Pt || e2.e < -Pt))
          throw Error(mr + r2);
      } else
        e2.s = 0, e2.e = 0, e2.d = [0];
      return e2;
    }
    function _(e2, t2, r2) {
      var n2, i2, o2, s2, a2, f2, v2, C2, T2 = e2.d;
      for (s2 = 1, o2 = T2[0]; o2 >= 10; o2 /= 10)
        s2++;
      if (n2 = t2 - s2, n2 < 0)
        n2 += F2, i2 = t2, v2 = T2[C2 = 0];
      else {
        if (C2 = Math.ceil((n2 + 1) / F2), o2 = T2.length, C2 >= o2)
          return e2;
        for (v2 = o2 = T2[C2], s2 = 1; o2 >= 10; o2 /= 10)
          s2++;
        n2 %= F2, i2 = n2 - F2 + s2;
      }
      if (r2 !== void 0 && (o2 = Ae(10, s2 - i2 - 1), a2 = v2 / o2 % 10 | 0, f2 = t2 < 0 || T2[C2 + 1] !== void 0 || v2 % o2, f2 = r2 < 4 ? (a2 || f2) && (r2 == 0 || r2 == (e2.s < 0 ? 3 : 2)) : a2 > 5 || a2 == 5 && (r2 == 4 || f2 || r2 == 6 && (n2 > 0 ? i2 > 0 ? v2 / Ae(10, s2 - i2) : 0 : T2[C2 - 1]) % 10 & 1 || r2 == (e2.s < 0 ? 8 : 7))), t2 < 1 || !T2[0])
        return f2 ? (o2 = V2(e2), T2.length = 1, t2 = t2 - o2 - 1, T2[0] = Ae(10, (F2 - t2 % F2) % F2), e2.e = Fe(-t2 / F2) || 0) : (T2.length = 1, T2[0] = e2.e = e2.s = 0), e2;
      if (n2 == 0 ? (T2.length = C2, o2 = 1, C2--) : (T2.length = C2 + 1, o2 = Ae(10, F2 - n2), T2[C2] = i2 > 0 ? (v2 / Ae(10, s2 - i2) % Ae(10, i2) | 0) * o2 : 0), f2)
        for (; ; )
          if (C2 == 0) {
            (T2[0] += o2) == j2 && (T2[0] = 1, ++e2.e);
            break;
          } else {
            if (T2[C2] += o2, T2[C2] != j2)
              break;
            T2[C2--] = 0, o2 = 1;
          }
      for (n2 = T2.length; T2[--n2] === 0; )
        T2.pop();
      if (B2 && (e2.e > Pt || e2.e < -Pt))
        throw Error(mr + V2(e2));
      return e2;
    }
    function rn(e2, t2) {
      var r2, n2, i2, o2, s2, a2, f2, v2, C2, T2, O2 = e2.constructor, R2 = O2.precision;
      if (!e2.s || !t2.s)
        return t2.s ? t2.s = -t2.s : t2 = new O2(e2), B2 ? _(t2, R2) : t2;
      if (f2 = e2.d, T2 = t2.d, n2 = t2.e, v2 = e2.e, f2 = f2.slice(), s2 = v2 - n2, s2) {
        for (C2 = s2 < 0, C2 ? (r2 = f2, s2 = -s2, a2 = T2.length) : (r2 = T2, n2 = v2, a2 = f2.length), i2 = Math.max(Math.ceil(R2 / F2), a2) + 2, s2 > i2 && (s2 = i2, r2.length = 1), r2.reverse(), i2 = s2; i2--; )
          r2.push(0);
        r2.reverse();
      } else {
        for (i2 = f2.length, a2 = T2.length, C2 = i2 < a2, C2 && (a2 = i2), i2 = 0; i2 < a2; i2++)
          if (f2[i2] != T2[i2]) {
            C2 = f2[i2] < T2[i2];
            break;
          }
        s2 = 0;
      }
      for (C2 && (r2 = f2, f2 = T2, T2 = r2, t2.s = -t2.s), a2 = f2.length, i2 = T2.length - a2; i2 > 0; --i2)
        f2[a2++] = 0;
      for (i2 = T2.length; i2 > s2; ) {
        if (f2[--i2] < T2[i2]) {
          for (o2 = i2; o2 && f2[--o2] === 0; )
            f2[o2] = j2 - 1;
          --f2[o2], f2[i2] += j2;
        }
        f2[i2] -= T2[i2];
      }
      for (; f2[--a2] === 0; )
        f2.pop();
      for (; f2[0] === 0; f2.shift())
        --n2;
      return f2[0] ? (t2.d = f2, t2.e = n2, B2 ? _(t2, R2) : t2) : new O2(0);
    }
    function Se(e2, t2, r2) {
      var n2, i2 = V2(e2), o2 = ae2(e2.d), s2 = o2.length;
      return t2 ? (r2 && (n2 = r2 - s2) > 0 ? o2 = o2.charAt(0) + "." + o2.slice(1) + we(n2) : s2 > 1 && (o2 = o2.charAt(0) + "." + o2.slice(1)), o2 = o2 + (i2 < 0 ? "e" : "e+") + i2) : i2 < 0 ? (o2 = "0." + we(-i2 - 1) + o2, r2 && (n2 = r2 - s2) > 0 && (o2 += we(n2))) : i2 >= s2 ? (o2 += we(i2 + 1 - s2), r2 && (n2 = r2 - i2 - 1) > 0 && (o2 = o2 + "." + we(n2))) : ((n2 = i2 + 1) < s2 && (o2 = o2.slice(0, n2) + "." + o2.slice(n2)), r2 && (n2 = r2 - s2) > 0 && (i2 + 1 === s2 && (o2 += "."), o2 += we(n2))), e2.s < 0 ? "-" + o2 : o2;
    }
    function Xr(e2, t2) {
      if (e2.length > t2)
        return e2.length = t2, true;
    }
    function nn(e2) {
      var t2, r2, n2;
      function i2(o2) {
        var s2 = this;
        if (!(s2 instanceof i2))
          return new i2(o2);
        if (s2.constructor = i2, o2 instanceof i2) {
          s2.s = o2.s, s2.e = o2.e, s2.d = (o2 = o2.d) ? o2.slice() : o2;
          return;
        }
        if (typeof o2 == "number") {
          if (o2 * 0 !== 0)
            throw Error(Re + o2);
          if (o2 > 0)
            s2.s = 1;
          else if (o2 < 0)
            o2 = -o2, s2.s = -1;
          else {
            s2.s = 0, s2.e = 0, s2.d = [0];
            return;
          }
          if (o2 === ~~o2 && o2 < 1e7) {
            s2.e = 0, s2.d = [o2];
            return;
          }
          return Yr(s2, o2.toString());
        } else if (typeof o2 != "string")
          throw Error(Re + o2);
        if (o2.charCodeAt(0) === 45 ? (o2 = o2.slice(1), s2.s = -1) : s2.s = 1, Qo.test(o2))
          Yr(s2, o2);
        else
          throw Error(Re + o2);
      }
      if (i2.prototype = A2, i2.ROUND_UP = 0, i2.ROUND_DOWN = 1, i2.ROUND_CEIL = 2, i2.ROUND_FLOOR = 3, i2.ROUND_HALF_UP = 4, i2.ROUND_HALF_DOWN = 5, i2.ROUND_HALF_EVEN = 6, i2.ROUND_HALF_CEIL = 7, i2.ROUND_HALF_FLOOR = 8, i2.clone = nn, i2.config = i2.set = Jo, e2 === void 0 && (e2 = {}), e2)
        for (n2 = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], t2 = 0; t2 < n2.length; )
          e2.hasOwnProperty(r2 = n2[t2++]) || (e2[r2] = this[r2]);
      return i2.config(e2), i2;
    }
    function Jo(e2) {
      if (!e2 || typeof e2 != "object")
        throw Error(te + "Object expected");
      var t2, r2, n2, i2 = ["precision", 1, De, "rounding", 0, 8, "toExpNeg", -1 / 0, 0, "toExpPos", 0, 1 / 0];
      for (t2 = 0; t2 < i2.length; t2 += 3)
        if ((n2 = e2[r2 = i2[t2]]) !== void 0)
          if (Fe(n2) === n2 && n2 >= i2[t2 + 1] && n2 <= i2[t2 + 2])
            this[r2] = n2;
          else
            throw Error(Re + r2 + ": " + n2);
      if ((n2 = e2[r2 = "LN10"]) !== void 0)
        if (n2 == Math.LN10)
          this[r2] = new this(n2);
        else
          throw Error(Re + r2 + ": " + n2);
      return this;
    }
    var De;
    var jo;
    var pr;
    var B2;
    var te;
    var Re;
    var mr;
    var Fe;
    var Ae;
    var Qo;
    var Z2;
    var j2;
    var F2;
    var Zr;
    var Pt;
    var A2;
    var ge;
    var pr;
    var vt;
    var on = oe(() => {
      "use strict";
      u2();
      c2();
      m2();
      p2();
      d2();
      l2();
      De = 1e9, jo = { precision: 20, rounding: 4, toExpNeg: -7, toExpPos: 21, LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286" }, B2 = true, te = "[DecimalError] ", Re = te + "Invalid argument: ", mr = te + "Exponent out of range: ", Fe = Math.floor, Ae = Math.pow, Qo = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, j2 = 1e7, F2 = 7, Zr = 9007199254740991, Pt = Fe(Zr / F2), A2 = {};
      A2.absoluteValue = A2.abs = function() {
        var e2 = new this.constructor(this);
        return e2.s && (e2.s = 1), e2;
      };
      A2.comparedTo = A2.cmp = function(e2) {
        var t2, r2, n2, i2, o2 = this;
        if (e2 = new o2.constructor(e2), o2.s !== e2.s)
          return o2.s || -e2.s;
        if (o2.e !== e2.e)
          return o2.e > e2.e ^ o2.s < 0 ? 1 : -1;
        for (n2 = o2.d.length, i2 = e2.d.length, t2 = 0, r2 = n2 < i2 ? n2 : i2; t2 < r2; ++t2)
          if (o2.d[t2] !== e2.d[t2])
            return o2.d[t2] > e2.d[t2] ^ o2.s < 0 ? 1 : -1;
        return n2 === i2 ? 0 : n2 > i2 ^ o2.s < 0 ? 1 : -1;
      };
      A2.decimalPlaces = A2.dp = function() {
        var e2 = this, t2 = e2.d.length - 1, r2 = (t2 - e2.e) * F2;
        if (t2 = e2.d[t2], t2)
          for (; t2 % 10 == 0; t2 /= 10)
            r2--;
        return r2 < 0 ? 0 : r2;
      };
      A2.dividedBy = A2.div = function(e2) {
        return ge(this, new this.constructor(e2));
      };
      A2.dividedToIntegerBy = A2.idiv = function(e2) {
        var t2 = this, r2 = t2.constructor;
        return _(ge(t2, new r2(e2), 0, 1), r2.precision);
      };
      A2.equals = A2.eq = function(e2) {
        return !this.cmp(e2);
      };
      A2.exponent = function() {
        return V2(this);
      };
      A2.greaterThan = A2.gt = function(e2) {
        return this.cmp(e2) > 0;
      };
      A2.greaterThanOrEqualTo = A2.gte = function(e2) {
        return this.cmp(e2) >= 0;
      };
      A2.isInteger = A2.isint = function() {
        return this.e > this.d.length - 2;
      };
      A2.isNegative = A2.isneg = function() {
        return this.s < 0;
      };
      A2.isPositive = A2.ispos = function() {
        return this.s > 0;
      };
      A2.isZero = function() {
        return this.s === 0;
      };
      A2.lessThan = A2.lt = function(e2) {
        return this.cmp(e2) < 0;
      };
      A2.lessThanOrEqualTo = A2.lte = function(e2) {
        return this.cmp(e2) < 1;
      };
      A2.logarithm = A2.log = function(e2) {
        var t2, r2 = this, n2 = r2.constructor, i2 = n2.precision, o2 = i2 + 5;
        if (e2 === void 0)
          e2 = new n2(10);
        else if (e2 = new n2(e2), e2.s < 1 || e2.eq(Z2))
          throw Error(te + "NaN");
        if (r2.s < 1)
          throw Error(te + (r2.s ? "NaN" : "-Infinity"));
        return r2.eq(Z2) ? new n2(0) : (B2 = false, t2 = ge(Ye(r2, o2), Ye(e2, o2), o2), B2 = true, _(t2, i2));
      };
      A2.minus = A2.sub = function(e2) {
        var t2 = this;
        return e2 = new t2.constructor(e2), t2.s == e2.s ? rn(t2, e2) : en(t2, (e2.s = -e2.s, e2));
      };
      A2.modulo = A2.mod = function(e2) {
        var t2, r2 = this, n2 = r2.constructor, i2 = n2.precision;
        if (e2 = new n2(e2), !e2.s)
          throw Error(te + "NaN");
        return r2.s ? (B2 = false, t2 = ge(r2, e2, 0, 1).times(e2), B2 = true, r2.minus(t2)) : _(new n2(r2), i2);
      };
      A2.naturalExponential = A2.exp = function() {
        return tn(this);
      };
      A2.naturalLogarithm = A2.ln = function() {
        return Ye(this);
      };
      A2.negated = A2.neg = function() {
        var e2 = new this.constructor(this);
        return e2.s = -e2.s || 0, e2;
      };
      A2.plus = A2.add = function(e2) {
        var t2 = this;
        return e2 = new t2.constructor(e2), t2.s == e2.s ? en(t2, e2) : rn(t2, (e2.s = -e2.s, e2));
      };
      A2.precision = A2.sd = function(e2) {
        var t2, r2, n2, i2 = this;
        if (e2 !== void 0 && e2 !== !!e2 && e2 !== 1 && e2 !== 0)
          throw Error(Re + e2);
        if (t2 = V2(i2) + 1, n2 = i2.d.length - 1, r2 = n2 * F2 + 1, n2 = i2.d[n2], n2) {
          for (; n2 % 10 == 0; n2 /= 10)
            r2--;
          for (n2 = i2.d[0]; n2 >= 10; n2 /= 10)
            r2++;
        }
        return e2 && t2 > r2 ? t2 : r2;
      };
      A2.squareRoot = A2.sqrt = function() {
        var e2, t2, r2, n2, i2, o2, s2, a2 = this, f2 = a2.constructor;
        if (a2.s < 1) {
          if (!a2.s)
            return new f2(0);
          throw Error(te + "NaN");
        }
        for (e2 = V2(a2), B2 = false, i2 = Math.sqrt(+a2), i2 == 0 || i2 == 1 / 0 ? (t2 = ae2(a2.d), (t2.length + e2) % 2 == 0 && (t2 += "0"), i2 = Math.sqrt(t2), e2 = Fe((e2 + 1) / 2) - (e2 < 0 || e2 % 2), i2 == 1 / 0 ? t2 = "5e" + e2 : (t2 = i2.toExponential(), t2 = t2.slice(0, t2.indexOf("e") + 1) + e2), n2 = new f2(t2)) : n2 = new f2(i2.toString()), r2 = f2.precision, i2 = s2 = r2 + 3; ; )
          if (o2 = n2, n2 = o2.plus(ge(a2, o2, s2 + 2)).times(0.5), ae2(o2.d).slice(0, s2) === (t2 = ae2(n2.d)).slice(0, s2)) {
            if (t2 = t2.slice(s2 - 3, s2 + 1), i2 == s2 && t2 == "4999") {
              if (_(o2, r2 + 1, 0), o2.times(o2).eq(a2)) {
                n2 = o2;
                break;
              }
            } else if (t2 != "9999")
              break;
            s2 += 4;
          }
        return B2 = true, _(n2, r2);
      };
      A2.times = A2.mul = function(e2) {
        var t2, r2, n2, i2, o2, s2, a2, f2, v2, C2 = this, T2 = C2.constructor, O2 = C2.d, R2 = (e2 = new T2(e2)).d;
        if (!C2.s || !e2.s)
          return new T2(0);
        for (e2.s *= C2.s, r2 = C2.e + e2.e, f2 = O2.length, v2 = R2.length, f2 < v2 && (o2 = O2, O2 = R2, R2 = o2, s2 = f2, f2 = v2, v2 = s2), o2 = [], s2 = f2 + v2, n2 = s2; n2--; )
          o2.push(0);
        for (n2 = v2; --n2 >= 0; ) {
          for (t2 = 0, i2 = f2 + n2; i2 > n2; )
            a2 = o2[i2] + R2[n2] * O2[i2 - n2 - 1] + t2, o2[i2--] = a2 % j2 | 0, t2 = a2 / j2 | 0;
          o2[i2] = (o2[i2] + t2) % j2 | 0;
        }
        for (; !o2[--s2]; )
          o2.pop();
        return t2 ? ++r2 : o2.shift(), e2.d = o2, e2.e = r2, B2 ? _(e2, T2.precision) : e2;
      };
      A2.toDecimalPlaces = A2.todp = function(e2, t2) {
        var r2 = this, n2 = r2.constructor;
        return r2 = new n2(r2), e2 === void 0 ? r2 : (le(e2, 0, De), t2 === void 0 ? t2 = n2.rounding : le(t2, 0, 8), _(r2, e2 + V2(r2) + 1, t2));
      };
      A2.toExponential = function(e2, t2) {
        var r2, n2 = this, i2 = n2.constructor;
        return e2 === void 0 ? r2 = Se(n2, true) : (le(e2, 0, De), t2 === void 0 ? t2 = i2.rounding : le(t2, 0, 8), n2 = _(new i2(n2), e2 + 1, t2), r2 = Se(n2, true, e2 + 1)), r2;
      };
      A2.toFixed = function(e2, t2) {
        var r2, n2, i2 = this, o2 = i2.constructor;
        return e2 === void 0 ? Se(i2) : (le(e2, 0, De), t2 === void 0 ? t2 = o2.rounding : le(t2, 0, 8), n2 = _(new o2(i2), e2 + V2(i2) + 1, t2), r2 = Se(n2.abs(), false, e2 + V2(n2) + 1), i2.isneg() && !i2.isZero() ? "-" + r2 : r2);
      };
      A2.toInteger = A2.toint = function() {
        var e2 = this, t2 = e2.constructor;
        return _(new t2(e2), V2(e2) + 1, t2.rounding);
      };
      A2.toNumber = function() {
        return +this;
      };
      A2.toPower = A2.pow = function(e2) {
        var t2, r2, n2, i2, o2, s2, a2 = this, f2 = a2.constructor, v2 = 12, C2 = +(e2 = new f2(e2));
        if (!e2.s)
          return new f2(Z2);
        if (a2 = new f2(a2), !a2.s) {
          if (e2.s < 1)
            throw Error(te + "Infinity");
          return a2;
        }
        if (a2.eq(Z2))
          return a2;
        if (n2 = f2.precision, e2.eq(Z2))
          return _(a2, n2);
        if (t2 = e2.e, r2 = e2.d.length - 1, s2 = t2 >= r2, o2 = a2.s, s2) {
          if ((r2 = C2 < 0 ? -C2 : C2) <= Zr) {
            for (i2 = new f2(Z2), t2 = Math.ceil(n2 / F2 + 4), B2 = false; r2 % 2 && (i2 = i2.times(a2), Xr(i2.d, t2)), r2 = Fe(r2 / 2), r2 !== 0; )
              a2 = a2.times(a2), Xr(a2.d, t2);
            return B2 = true, e2.s < 0 ? new f2(Z2).div(i2) : _(i2, n2);
          }
        } else if (o2 < 0)
          throw Error(te + "NaN");
        return o2 = o2 < 0 && e2.d[Math.max(t2, r2)] & 1 ? -1 : 1, a2.s = 1, B2 = false, i2 = e2.times(Ye(a2, n2 + v2)), B2 = true, i2 = tn(i2), i2.s = o2, i2;
      };
      A2.toPrecision = function(e2, t2) {
        var r2, n2, i2 = this, o2 = i2.constructor;
        return e2 === void 0 ? (r2 = V2(i2), n2 = Se(i2, r2 <= o2.toExpNeg || r2 >= o2.toExpPos)) : (le(e2, 1, De), t2 === void 0 ? t2 = o2.rounding : le(t2, 0, 8), i2 = _(new o2(i2), e2, t2), r2 = V2(i2), n2 = Se(i2, e2 <= r2 || r2 <= o2.toExpNeg, e2)), n2;
      };
      A2.toSignificantDigits = A2.tosd = function(e2, t2) {
        var r2 = this, n2 = r2.constructor;
        return e2 === void 0 ? (e2 = n2.precision, t2 = n2.rounding) : (le(e2, 1, De), t2 === void 0 ? t2 = n2.rounding : le(t2, 0, 8)), _(new n2(r2), e2, t2);
      };
      A2.toString = A2.valueOf = A2.val = A2.toJSON = A2[Symbol.for("nodejs.util.inspect.custom")] = function() {
        var e2 = this, t2 = V2(e2), r2 = e2.constructor;
        return Se(e2, t2 <= r2.toExpNeg || t2 >= r2.toExpPos);
      };
      ge = function() {
        function e2(n2, i2) {
          var o2, s2 = 0, a2 = n2.length;
          for (n2 = n2.slice(); a2--; )
            o2 = n2[a2] * i2 + s2, n2[a2] = o2 % j2 | 0, s2 = o2 / j2 | 0;
          return s2 && n2.unshift(s2), n2;
        }
        function t2(n2, i2, o2, s2) {
          var a2, f2;
          if (o2 != s2)
            f2 = o2 > s2 ? 1 : -1;
          else
            for (a2 = f2 = 0; a2 < o2; a2++)
              if (n2[a2] != i2[a2]) {
                f2 = n2[a2] > i2[a2] ? 1 : -1;
                break;
              }
          return f2;
        }
        function r2(n2, i2, o2) {
          for (var s2 = 0; o2--; )
            n2[o2] -= s2, s2 = n2[o2] < i2[o2] ? 1 : 0, n2[o2] = s2 * j2 + n2[o2] - i2[o2];
          for (; !n2[0] && n2.length > 1; )
            n2.shift();
        }
        return function(n2, i2, o2, s2) {
          var a2, f2, v2, C2, T2, O2, R2, L2, S2, M2, ne, z5, Ie, k2, Ce, sr, ie, bt2, wt = n2.constructor, Oo = n2.s == i2.s ? 1 : -1, se = n2.d, U2 = i2.d;
          if (!n2.s)
            return new wt(n2);
          if (!i2.s)
            throw Error(te + "Division by zero");
          for (f2 = n2.e - i2.e, ie = U2.length, Ce = se.length, R2 = new wt(Oo), L2 = R2.d = [], v2 = 0; U2[v2] == (se[v2] || 0); )
            ++v2;
          if (U2[v2] > (se[v2] || 0) && --f2, o2 == null ? z5 = o2 = wt.precision : s2 ? z5 = o2 + (V2(n2) - V2(i2)) + 1 : z5 = o2, z5 < 0)
            return new wt(0);
          if (z5 = z5 / F2 + 2 | 0, v2 = 0, ie == 1)
            for (C2 = 0, U2 = U2[0], z5++; (v2 < Ce || C2) && z5--; v2++)
              Ie = C2 * j2 + (se[v2] || 0), L2[v2] = Ie / U2 | 0, C2 = Ie % U2 | 0;
          else {
            for (C2 = j2 / (U2[0] + 1) | 0, C2 > 1 && (U2 = e2(U2, C2), se = e2(se, C2), ie = U2.length, Ce = se.length), k2 = ie, S2 = se.slice(0, ie), M2 = S2.length; M2 < ie; )
              S2[M2++] = 0;
            bt2 = U2.slice(), bt2.unshift(0), sr = U2[0], U2[1] >= j2 / 2 && ++sr;
            do
              C2 = 0, a2 = t2(U2, S2, ie, M2), a2 < 0 ? (ne = S2[0], ie != M2 && (ne = ne * j2 + (S2[1] || 0)), C2 = ne / sr | 0, C2 > 1 ? (C2 >= j2 && (C2 = j2 - 1), T2 = e2(U2, C2), O2 = T2.length, M2 = S2.length, a2 = t2(T2, S2, O2, M2), a2 == 1 && (C2--, r2(T2, ie < O2 ? bt2 : U2, O2))) : (C2 == 0 && (a2 = C2 = 1), T2 = U2.slice()), O2 = T2.length, O2 < M2 && T2.unshift(0), r2(S2, T2, M2), a2 == -1 && (M2 = S2.length, a2 = t2(U2, S2, ie, M2), a2 < 1 && (C2++, r2(S2, ie < M2 ? bt2 : U2, M2))), M2 = S2.length) : a2 === 0 && (C2++, S2 = [0]), L2[v2++] = C2, a2 && S2[0] ? S2[M2++] = se[k2] || 0 : (S2 = [se[k2]], M2 = 1);
            while ((k2++ < Ce || S2[0] !== void 0) && z5--);
          }
          return L2[0] || L2.shift(), R2.e = f2, _(R2, s2 ? o2 + V2(R2) + 1 : o2);
        };
      }();
      pr = nn(jo);
      Z2 = new pr(1);
      vt = pr;
    });
    var P2;
    var ue;
    var l2 = oe(() => {
      "use strict";
      on();
      P2 = class extends vt {
        static isDecimal(t2) {
          return t2 instanceof vt;
        }
        static random(t2 = 20) {
          {
            let n2 = crypto.getRandomValues(new Uint8Array(t2)).reduce((i2, o2) => i2 + o2, "");
            return new vt(`0.${n2.slice(0, t2)}`);
          }
        }
      }, ue = P2;
    });
    function Wo() {
      return false;
    }
    var Go;
    var Ko;
    var un;
    var cn2 = oe(() => {
      "use strict";
      u2();
      c2();
      m2();
      p2();
      d2();
      l2();
      Go = {}, Ko = { existsSync: Wo, promises: Go }, un = Ko;
    });
    var xn = Te((Au, En) => {
      "use strict";
      u2();
      c2();
      m2();
      p2();
      d2();
      l2();
      En.exports = (yr(), ar2(hr)).format;
    });
    var hr = {};
    ze(hr, { default: () => Yo, deprecate: () => vn, format: () => Tn, inspect: () => Cn, promisify: () => Pn });
    function Pn(e2) {
      return (...t2) => new Promise((r2, n2) => {
        e2(...t2, (i2, o2) => {
          i2 ? n2(i2) : r2(o2);
        });
      });
    }
    function vn(e2, t2) {
      return (...r2) => (console.warn(t2), e2(...r2));
    }
    function Cn(e2) {
      return JSON.stringify(e2, (t2, r2) => typeof r2 == "function" ? r2.toString() : typeof r2 == "bigint" ? `${r2}n` : r2 instanceof Error ? { ...r2, message: r2.message, stack: r2.stack } : r2);
    }
    var Tn;
    var zo;
    var Yo;
    var yr = oe(() => {
      "use strict";
      u2();
      c2();
      m2();
      p2();
      d2();
      l2();
      Tn = xn(), zo = { promisify: Pn, deprecate: vn, inspect: Cn, format: Tn }, Yo = zo;
    });
    function rs(...e2) {
      return e2.join("/");
    }
    function ns(...e2) {
      return e2.join("/");
    }
    var On;
    var is;
    var os;
    var Ze;
    var kn = oe(() => {
      "use strict";
      u2();
      c2();
      m2();
      p2();
      d2();
      l2();
      On = "/", is = { sep: On }, os = { resolve: rs, posix: is, join: ns, sep: On }, Ze = os;
    });
    var St;
    var Mn = oe(() => {
      "use strict";
      u2();
      c2();
      m2();
      p2();
      d2();
      l2();
      St = class {
        constructor() {
          this.events = {};
        }
        on(t2, r2) {
          return this.events[t2] || (this.events[t2] = []), this.events[t2].push(r2), this;
        }
        emit(t2, ...r2) {
          return this.events[t2] ? (this.events[t2].forEach((n2) => {
            n2(...r2);
          }), true) : false;
        }
      };
    });
    var _n = Te((Kc, In) => {
      "use strict";
      u2();
      c2();
      m2();
      p2();
      d2();
      l2();
      In.exports = (e2, t2 = 1, r2) => {
        if (r2 = { indent: " ", includeEmptyLines: false, ...r2 }, typeof e2 != "string")
          throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e2}\``);
        if (typeof t2 != "number")
          throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t2}\``);
        if (typeof r2.indent != "string")
          throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r2.indent}\``);
        if (t2 === 0)
          return e2;
        let n2 = r2.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return e2.replace(n2, r2.indent.repeat(t2));
      };
    });
    var Nn = Te((lm, Fn) => {
      "use strict";
      u2();
      c2();
      m2();
      p2();
      d2();
      l2();
      Fn.exports = ({ onlyFirst: e2 = false } = {}) => {
        let t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
        return new RegExp(t2, e2 ? void 0 : "g");
      };
    });
    var Un = Te((gm, Bn) => {
      "use strict";
      u2();
      c2();
      m2();
      p2();
      d2();
      l2();
      var ms = Nn();
      Bn.exports = (e2) => typeof e2 == "string" ? e2.replace(ms(), "") : e2;
    });
    var jn = Te((Jf, gs) => {
      gs.exports = { name: "@prisma/engines-version", version: "5.14.0-25.e9771e62de70f79a5e1c604a2d7c8e2a0a874b48", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "e9771e62de70f79a5e1c604a2d7c8e2a0a874b48" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.19.32", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
    });
    var Qn = Te(() => {
      "use strict";
      u2();
      c2();
      m2();
      p2();
      d2();
      l2();
    });
    var Ur = Te((ST, Fi) => {
      "use strict";
      u2();
      c2();
      m2();
      p2();
      d2();
      l2();
      Fi.exports = function() {
        function e2(t2, r2, n2, i2, o2) {
          return t2 < r2 || n2 < r2 ? t2 > n2 ? n2 + 1 : t2 + 1 : i2 === o2 ? r2 : r2 + 1;
        }
        return function(t2, r2) {
          if (t2 === r2)
            return 0;
          if (t2.length > r2.length) {
            var n2 = t2;
            t2 = r2, r2 = n2;
          }
          for (var i2 = t2.length, o2 = r2.length; i2 > 0 && t2.charCodeAt(i2 - 1) === r2.charCodeAt(o2 - 1); )
            i2--, o2--;
          for (var s2 = 0; s2 < i2 && t2.charCodeAt(s2) === r2.charCodeAt(s2); )
            s2++;
          if (i2 -= s2, o2 -= s2, i2 === 0 || o2 < 3)
            return o2;
          var a2 = 0, f2, v2, C2, T2, O2, R2, L2, S2, M2, ne, z5, Ie, k2 = [];
          for (f2 = 0; f2 < i2; f2++)
            k2.push(f2 + 1), k2.push(t2.charCodeAt(s2 + f2));
          for (var Ce = k2.length - 1; a2 < o2 - 3; )
            for (M2 = r2.charCodeAt(s2 + (v2 = a2)), ne = r2.charCodeAt(s2 + (C2 = a2 + 1)), z5 = r2.charCodeAt(s2 + (T2 = a2 + 2)), Ie = r2.charCodeAt(s2 + (O2 = a2 + 3)), R2 = a2 += 4, f2 = 0; f2 < Ce; f2 += 2)
              L2 = k2[f2], S2 = k2[f2 + 1], v2 = e2(L2, v2, C2, M2, S2), C2 = e2(v2, C2, T2, ne, S2), T2 = e2(C2, T2, O2, z5, S2), R2 = e2(T2, O2, R2, Ie, S2), k2[f2] = R2, O2 = T2, T2 = C2, C2 = v2, v2 = L2;
          for (; a2 < o2; )
            for (M2 = r2.charCodeAt(s2 + (v2 = a2)), R2 = ++a2, f2 = 0; f2 < Ce; f2 += 2)
              L2 = k2[f2], k2[f2] = R2 = e2(L2, v2, R2, M2, k2[f2 + 1]), v2 = L2;
          return R2;
        };
      }();
    });
    var Ya = {};
    ze(Ya, { Debug: () => wr, Decimal: () => ue, Extensions: () => dr, MetricsClient: () => Ue, NotFoundError: () => he, PrismaClientInitializationError: () => I2, PrismaClientKnownRequestError: () => Q2, PrismaClientRustPanicError: () => ye, PrismaClientUnknownRequestError: () => J2, PrismaClientValidationError: () => W2, Public: () => fr, Sql: () => X2, defineDmmfProperty: () => qn, empty: () => Wn, getPrismaClient: () => Ao, getRuntime: () => Pe, join: () => Jn, makeStrictEnum: () => Ro, objectEnumValues: () => Lt, raw: () => kr, sqltag: () => Lr, warnEnvConflicts: () => void 0, warnOnce: () => nt });
    module.exports = ar2(Ya);
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var dr = {};
    ze(dr, { defineExtension: () => sn, getExtensionContext: () => an2 });
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function sn(e2) {
      return typeof e2 == "function" ? e2 : (t2) => t2.$extends(e2);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function an2(e2) {
      return e2;
    }
    var fr = {};
    ze(fr, { validator: () => ln });
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function ln(...e2) {
      return (t2) => t2;
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var gr;
    var mn;
    var pn;
    var dn;
    var fn = true;
    typeof g2 < "u" && ({ FORCE_COLOR: gr, NODE_DISABLE_COLORS: mn, NO_COLOR: pn, TERM: dn } = g2.env || {}, fn = g2.stdout && g2.stdout.isTTY);
    var Ho = { enabled: !mn && pn == null && dn !== "dumb" && (gr != null && gr !== "0" || fn) };
    function D2(e2, t2) {
      let r2 = new RegExp(`\\x1b\\[${t2}m`, "g"), n2 = `\x1B[${e2}m`, i2 = `\x1B[${t2}m`;
      return function(o2) {
        return !Ho.enabled || o2 == null ? o2 : n2 + (~("" + o2).indexOf(i2) ? o2.replace(r2, i2 + n2) : o2) + i2;
      };
    }
    var ru = D2(0, 0);
    var Ct = D2(1, 22);
    var Tt = D2(2, 22);
    var nu = D2(3, 23);
    var gn = D2(4, 24);
    var iu = D2(7, 27);
    var ou = D2(8, 28);
    var su = D2(9, 29);
    var au2 = D2(30, 39);
    var Ne = D2(31, 39);
    var hn = D2(32, 39);
    var At = D2(33, 39);
    var yn = D2(34, 39);
    var lu = D2(35, 39);
    var bn2 = D2(36, 39);
    var uu = D2(37, 39);
    var wn = D2(90, 39);
    var cu = D2(90, 39);
    var mu = D2(40, 49);
    var pu = D2(41, 49);
    var du = D2(42, 49);
    var fu = D2(43, 49);
    var gu = D2(44, 49);
    var hu = D2(45, 49);
    var yu = D2(46, 49);
    var bu2 = D2(47, 49);
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Xo = 100;
    var An = ["green", "yellow", "blue", "magenta", "cyan", "red"];
    var Rt = [];
    var Rn = Date.now();
    var Zo = 0;
    var br2 = typeof g2 < "u" ? g2.env : {};
    globalThis.DEBUG ??= br2.DEBUG ?? "";
    globalThis.DEBUG_COLORS ??= br2.DEBUG_COLORS ? br2.DEBUG_COLORS === "true" : true;
    var Xe = { enable(e2) {
      typeof e2 == "string" && (globalThis.DEBUG = e2);
    }, disable() {
      let e2 = globalThis.DEBUG;
      return globalThis.DEBUG = "", e2;
    }, enabled(e2) {
      let t2 = globalThis.DEBUG.split(",").map((i2) => i2.replace(/[.+?^${}()|[\]\\]/g, "\\$&")), r2 = t2.some((i2) => i2 === "" || i2[0] === "-" ? false : e2.match(RegExp(i2.split("*").join(".*") + "$"))), n2 = t2.some((i2) => i2 === "" || i2[0] !== "-" ? false : e2.match(RegExp(i2.slice(1).split("*").join(".*") + "$")));
      return r2 && !n2;
    }, log: (...e2) => {
      let [t2, r2, ...n2] = e2, i2;
      typeof __require == "function" && typeof g2 < "u" && typeof g2.stderr < "u" && typeof g2.stderr.write == "function" ? i2 = (...o2) => {
        try {
          let s2 = (yr(), ar2(hr));
          g2.stderr.write(s2.format(...o2) + `
`);
        } catch {
          i2 = console.warn ?? console.log;
        }
      } : i2 = console.warn ?? console.log, i2(`${t2} ${r2}`, ...n2);
    }, formatters: {} };
    function es(e2) {
      let t2 = { color: An[Zo++ % An.length], enabled: Xe.enabled(e2), namespace: e2, log: Xe.log, extend: () => {
      } }, r2 = (...n2) => {
        let { enabled: i2, namespace: o2, color: s2, log: a2 } = t2;
        if (n2.length !== 0 && Rt.push([o2, ...n2]), Rt.length > Xo && Rt.shift(), Xe.enabled(o2) || i2) {
          let f2 = n2.map((C2) => typeof C2 == "string" ? C2 : ts(C2)), v2 = `+${Date.now() - Rn}ms`;
          Rn = Date.now(), a2(o2, ...f2, v2);
        }
      };
      return new Proxy(r2, { get: (n2, i2) => t2[i2], set: (n2, i2, o2) => t2[i2] = o2 });
    }
    var wr = new Proxy(es, { get: (e2, t2) => Xe[t2], set: (e2, t2, r2) => Xe[t2] = r2 });
    function ts(e2, t2 = 2) {
      let r2 = /* @__PURE__ */ new Set();
      return JSON.stringify(e2, (n2, i2) => {
        if (typeof i2 == "object" && i2 !== null) {
          if (r2.has(i2))
            return "[Circular *]";
          r2.add(i2);
        } else if (typeof i2 == "bigint")
          return i2.toString();
        return i2;
      }, t2);
    }
    function Sn() {
      Rt.length = 0;
    }
    var ee = wr;
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Er = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "freebsd14", "freebsd15", "openbsd", "netbsd", "arm"];
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Ln = "library";
    function et(e2) {
      let t2 = ss();
      return t2 || (e2?.config.engineType === "library" ? "library" : e2?.config.engineType === "binary" ? "binary" : Ln);
    }
    function ss() {
      let e2 = g2.env.PRISMA_CLIENT_ENGINE_TYPE;
      return e2 === "library" ? "library" : e2 === "binary" ? "binary" : void 0;
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Oe;
    ((t2) => {
      let e2;
      ((k2) => (k2.findUnique = "findUnique", k2.findUniqueOrThrow = "findUniqueOrThrow", k2.findFirst = "findFirst", k2.findFirstOrThrow = "findFirstOrThrow", k2.findMany = "findMany", k2.create = "create", k2.createMany = "createMany", k2.createManyAndReturn = "createManyAndReturn", k2.update = "update", k2.updateMany = "updateMany", k2.upsert = "upsert", k2.delete = "delete", k2.deleteMany = "deleteMany", k2.groupBy = "groupBy", k2.count = "count", k2.aggregate = "aggregate", k2.findRaw = "findRaw", k2.aggregateRaw = "aggregateRaw"))(e2 = t2.ModelAction ||= {});
    })(Oe ||= {});
    var rt = {};
    ze(rt, { error: () => us, info: () => ls, log: () => as2, query: () => cs2, should: () => Dn, tags: () => tt, warn: () => xr });
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var tt = { error: Ne("prisma:error"), warn: At("prisma:warn"), info: bn2("prisma:info"), query: yn("prisma:query") };
    var Dn = { warn: () => !g2.env.PRISMA_DISABLE_WARNINGS };
    function as2(...e2) {
      console.log(...e2);
    }
    function xr(e2, ...t2) {
      Dn.warn() && console.warn(`${tt.warn} ${e2}`, ...t2);
    }
    function ls(e2, ...t2) {
      console.info(`${tt.info} ${e2}`, ...t2);
    }
    function us(e2, ...t2) {
      console.error(`${tt.error} ${e2}`, ...t2);
    }
    function cs2(e2, ...t2) {
      console.log(`${tt.query} ${e2}`, ...t2);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function Ot(e2, t2) {
      if (!e2)
        throw new Error(`${t2}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function ke(e2, t2) {
      throw new Error(t2);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function Pr(e2, t2) {
      return Object.prototype.hasOwnProperty.call(e2, t2);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var vr = (e2, t2) => e2.reduce((r2, n2) => (r2[t2(n2)] = n2, r2), {});
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function Be(e2, t2) {
      let r2 = {};
      for (let n2 of Object.keys(e2))
        r2[n2] = t2(e2[n2], n2);
      return r2;
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function Cr(e2, t2) {
      if (e2.length === 0)
        return;
      let r2 = e2[0];
      for (let n2 = 1; n2 < e2.length; n2++)
        t2(r2, e2[n2]) < 0 && (r2 = e2[n2]);
      return r2;
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function K2(e2, t2) {
      Object.defineProperty(e2, "name", { value: t2, configurable: true });
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var $n = /* @__PURE__ */ new Set();
    var nt = (e2, t2, ...r2) => {
      $n.has(e2) || ($n.add(e2), xr(t2, ...r2));
    };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Q2 = class extends Error {
      constructor(t2, { code: r2, clientVersion: n2, meta: i2, batchRequestIdx: o2 }) {
        super(t2), this.name = "PrismaClientKnownRequestError", this.code = r2, this.clientVersion = n2, this.meta = i2, Object.defineProperty(this, "batchRequestIdx", { value: o2, enumerable: false, writable: true });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientKnownRequestError";
      }
    };
    K2(Q2, "PrismaClientKnownRequestError");
    var he = class extends Q2 {
      constructor(t2, r2) {
        super(t2, { code: "P2025", clientVersion: r2 }), this.name = "NotFoundError";
      }
    };
    K2(he, "NotFoundError");
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var I2 = class e2 extends Error {
      constructor(t2, r2, n2) {
        super(t2), this.name = "PrismaClientInitializationError", this.clientVersion = r2, this.errorCode = n2, Error.captureStackTrace(e2);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientInitializationError";
      }
    };
    K2(I2, "PrismaClientInitializationError");
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var ye = class extends Error {
      constructor(t2, r2) {
        super(t2), this.name = "PrismaClientRustPanicError", this.clientVersion = r2;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustPanicError";
      }
    };
    K2(ye, "PrismaClientRustPanicError");
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var J2 = class extends Error {
      constructor(t2, { clientVersion: r2, batchRequestIdx: n2 }) {
        super(t2), this.name = "PrismaClientUnknownRequestError", this.clientVersion = r2, Object.defineProperty(this, "batchRequestIdx", { value: n2, writable: true, enumerable: false });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientUnknownRequestError";
      }
    };
    K2(J2, "PrismaClientUnknownRequestError");
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var W2 = class extends Error {
      constructor(r2, { clientVersion: n2 }) {
        super(r2);
        this.name = "PrismaClientValidationError";
        this.clientVersion = n2;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientValidationError";
      }
    };
    K2(W2, "PrismaClientValidationError");
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Ue = class {
      constructor(t2) {
        this._engine = t2;
      }
      prometheus(t2) {
        return this._engine.metrics({ format: "prometheus", ...t2 });
      }
      json(t2) {
        return this._engine.metrics({ format: "json", ...t2 });
      }
    };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function it(e2) {
      let t2;
      return { get() {
        return t2 || (t2 = { value: e2() }), t2.value;
      } };
    }
    function qn(e2, t2) {
      let r2 = it(() => ps(t2));
      Object.defineProperty(e2, "dmmf", { get: () => r2.get() });
    }
    function ps(e2) {
      throw new Error("Prisma.dmmf is not available when running in edge runtimes.");
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var kt = Symbol();
    var Ar = /* @__PURE__ */ new WeakMap();
    var be2 = class {
      constructor(t2) {
        t2 === kt ? Ar.set(this, `Prisma.${this._getName()}`) : Ar.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
      }
      _getName() {
        return this.constructor.name;
      }
      toString() {
        return Ar.get(this);
      }
    };
    var ot = class extends be2 {
      _getNamespace() {
        return "NullTypes";
      }
    };
    var st = class extends ot {
    };
    Rr(st, "DbNull");
    var at2 = class extends ot {
    };
    Rr(at2, "JsonNull");
    var lt = class extends ot {
    };
    Rr(lt, "AnyNull");
    var Lt = { classes: { DbNull: st, JsonNull: at2, AnyNull: lt }, instances: { DbNull: new st(kt), JsonNull: new at2(kt), AnyNull: new lt(kt) } };
    function Rr(e2, t2) {
      Object.defineProperty(e2, "name", { value: t2, configurable: true });
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function ut(e2) {
      return { ok: false, error: e2, map() {
        return ut(e2);
      }, flatMap() {
        return ut(e2);
      } };
    }
    var Sr = class {
      constructor() {
        this.registeredErrors = [];
      }
      consumeError(t2) {
        return this.registeredErrors[t2];
      }
      registerNewError(t2) {
        let r2 = 0;
        for (; this.registeredErrors[r2] !== void 0; )
          r2++;
        return this.registeredErrors[r2] = { error: t2 }, r2;
      }
    };
    var Or = (e2) => {
      let t2 = new Sr(), r2 = Le(t2, e2.startTransaction.bind(e2)), n2 = { adapterName: e2.adapterName, errorRegistry: t2, queryRaw: Le(t2, e2.queryRaw.bind(e2)), executeRaw: Le(t2, e2.executeRaw.bind(e2)), provider: e2.provider, startTransaction: async (...i2) => (await r2(...i2)).map((s2) => ds(t2, s2)) };
      return e2.getConnectionInfo && (n2.getConnectionInfo = fs(t2, e2.getConnectionInfo.bind(e2))), n2;
    };
    var ds = (e2, t2) => ({ adapterName: t2.adapterName, provider: t2.provider, options: t2.options, queryRaw: Le(e2, t2.queryRaw.bind(t2)), executeRaw: Le(e2, t2.executeRaw.bind(t2)), commit: Le(e2, t2.commit.bind(t2)), rollback: Le(e2, t2.rollback.bind(t2)) });
    function Le(e2, t2) {
      return async (...r2) => {
        try {
          return await t2(...r2);
        } catch (n2) {
          let i2 = e2.registerNewError(n2);
          return ut({ kind: "GenericJs", id: i2 });
        }
      };
    }
    function fs(e2, t2) {
      return (...r2) => {
        try {
          return t2(...r2);
        } catch (n2) {
          let i2 = e2.registerNewError(n2);
          return ut({ kind: "GenericJs", id: i2 });
        }
      };
    }
    var To = _e(jn());
    var cO = _e(Qn());
    Mn();
    cn2();
    kn();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var X2 = class e2 {
      constructor(t2, r2) {
        if (t2.length - 1 !== r2.length)
          throw t2.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${t2.length} strings to have ${t2.length - 1} values`);
        let n2 = r2.reduce((s2, a2) => s2 + (a2 instanceof e2 ? a2.values.length : 1), 0);
        this.values = new Array(n2), this.strings = new Array(n2 + 1), this.strings[0] = t2[0];
        let i2 = 0, o2 = 0;
        for (; i2 < r2.length; ) {
          let s2 = r2[i2++], a2 = t2[i2];
          if (s2 instanceof e2) {
            this.strings[o2] += s2.strings[0];
            let f2 = 0;
            for (; f2 < s2.values.length; )
              this.values[o2++] = s2.values[f2++], this.strings[o2] = s2.strings[f2];
            this.strings[o2] += a2;
          } else
            this.values[o2++] = s2, this.strings[o2] = a2;
        }
      }
      get sql() {
        let t2 = this.strings.length, r2 = 1, n2 = this.strings[0];
        for (; r2 < t2; )
          n2 += `?${this.strings[r2++]}`;
        return n2;
      }
      get statement() {
        let t2 = this.strings.length, r2 = 1, n2 = this.strings[0];
        for (; r2 < t2; )
          n2 += `:${r2}${this.strings[r2++]}`;
        return n2;
      }
      get text() {
        let t2 = this.strings.length, r2 = 1, n2 = this.strings[0];
        for (; r2 < t2; )
          n2 += `$${r2}${this.strings[r2++]}`;
        return n2;
      }
      inspect() {
        return { sql: this.sql, statement: this.statement, text: this.text, values: this.values };
      }
    };
    function Jn(e2, t2 = ",", r2 = "", n2 = "") {
      if (e2.length === 0)
        throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
      return new X2([r2, ...Array(e2.length - 1).fill(t2), n2], e2);
    }
    function kr(e2) {
      return new X2([e2], []);
    }
    var Wn = kr("");
    function Lr(e2, ...t2) {
      return new X2(e2, t2);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function ct2(e2) {
      return { getKeys() {
        return Object.keys(e2);
      }, getPropertyValue(t2) {
        return e2[t2];
      } };
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function H2(e2, t2) {
      return { getKeys() {
        return [e2];
      }, getPropertyValue() {
        return t2();
      } };
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var ce2 = class {
      constructor() {
        this._map = /* @__PURE__ */ new Map();
      }
      get(t2) {
        return this._map.get(t2)?.value;
      }
      set(t2, r2) {
        this._map.set(t2, { value: r2 });
      }
      getOrCreate(t2, r2) {
        let n2 = this._map.get(t2);
        if (n2)
          return n2.value;
        let i2 = r2();
        return this.set(t2, i2), i2;
      }
    };
    function Me(e2) {
      let t2 = new ce2();
      return { getKeys() {
        return e2.getKeys();
      }, getPropertyValue(r2) {
        return t2.getOrCreate(r2, () => e2.getPropertyValue(r2));
      }, getPropertyDescriptor(r2) {
        return e2.getPropertyDescriptor?.(r2);
      } };
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Mt = { enumerable: true, configurable: true, writable: true };
    function It(e2) {
      let t2 = new Set(e2);
      return { getOwnPropertyDescriptor: () => Mt, has: (r2, n2) => t2.has(n2), set: (r2, n2, i2) => t2.add(n2) && Reflect.set(r2, n2, i2), ownKeys: () => [...t2] };
    }
    var Gn = Symbol.for("nodejs.util.inspect.custom");
    function me(e2, t2) {
      let r2 = hs(t2), n2 = /* @__PURE__ */ new Set(), i2 = new Proxy(e2, { get(o2, s2) {
        if (n2.has(s2))
          return o2[s2];
        let a2 = r2.get(s2);
        return a2 ? a2.getPropertyValue(s2) : o2[s2];
      }, has(o2, s2) {
        if (n2.has(s2))
          return true;
        let a2 = r2.get(s2);
        return a2 ? a2.has?.(s2) ?? true : Reflect.has(o2, s2);
      }, ownKeys(o2) {
        let s2 = Kn(Reflect.ownKeys(o2), r2), a2 = Kn(Array.from(r2.keys()), r2);
        return [.../* @__PURE__ */ new Set([...s2, ...a2, ...n2])];
      }, set(o2, s2, a2) {
        return r2.get(s2)?.getPropertyDescriptor?.(s2)?.writable === false ? false : (n2.add(s2), Reflect.set(o2, s2, a2));
      }, getOwnPropertyDescriptor(o2, s2) {
        let a2 = Reflect.getOwnPropertyDescriptor(o2, s2);
        if (a2 && !a2.configurable)
          return a2;
        let f2 = r2.get(s2);
        return f2 ? f2.getPropertyDescriptor ? { ...Mt, ...f2?.getPropertyDescriptor(s2) } : Mt : a2;
      }, defineProperty(o2, s2, a2) {
        return n2.add(s2), Reflect.defineProperty(o2, s2, a2);
      } });
      return i2[Gn] = function() {
        let o2 = { ...this };
        return delete o2[Gn], o2;
      }, i2;
    }
    function hs(e2) {
      let t2 = /* @__PURE__ */ new Map();
      for (let r2 of e2) {
        let n2 = r2.getKeys();
        for (let i2 of n2)
          t2.set(i2, r2);
      }
      return t2;
    }
    function Kn(e2, t2) {
      return e2.filter((r2) => t2.get(r2)?.has?.(r2) ?? true);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function $e(e2) {
      return { getKeys() {
        return e2;
      }, has() {
        return false;
      }, getPropertyValue() {
      } };
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function _t(e2, t2) {
      return { batch: e2, transaction: t2?.kind === "batch" ? { isolationLevel: t2.options.isolationLevel } : void 0 };
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Ve = class {
      constructor(t2 = 0, r2) {
        this.context = r2;
        this.lines = [];
        this.currentLine = "";
        this.currentIndent = 0;
        this.currentIndent = t2;
      }
      write(t2) {
        return typeof t2 == "string" ? this.currentLine += t2 : t2.write(this), this;
      }
      writeJoined(t2, r2) {
        let n2 = r2.length - 1;
        for (let i2 = 0; i2 < r2.length; i2++)
          this.write(r2[i2]), i2 !== n2 && this.write(t2);
        return this;
      }
      writeLine(t2) {
        return this.write(t2).newLine();
      }
      newLine() {
        this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = void 0;
        let t2 = this.afterNextNewLineCallback;
        return this.afterNextNewLineCallback = void 0, t2?.(), this;
      }
      withIndent(t2) {
        return this.indent(), t2(this), this.unindent(), this;
      }
      afterNextNewline(t2) {
        return this.afterNextNewLineCallback = t2, this;
      }
      indent() {
        return this.currentIndent++, this;
      }
      unindent() {
        return this.currentIndent > 0 && this.currentIndent--, this;
      }
      addMarginSymbol(t2) {
        return this.marginSymbol = t2, this;
      }
      toString() {
        return this.lines.concat(this.indentedCurrentLine()).join(`
`);
      }
      getCurrentLineLength() {
        return this.currentLine.length;
      }
      indentedCurrentLine() {
        let t2 = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
        return this.marginSymbol ? this.marginSymbol + t2.slice(1) : t2;
      }
    };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function Hn(e2) {
      return e2.substring(0, 1).toLowerCase() + e2.substring(1);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function qe(e2) {
      return e2 instanceof Date || Object.prototype.toString.call(e2) === "[object Date]";
    }
    function Dt(e2) {
      return e2.toString() !== "Invalid Date";
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    l2();
    function je(e2) {
      return P2.isDecimal(e2) ? true : e2 !== null && typeof e2 == "object" && typeof e2.s == "number" && typeof e2.e == "number" && typeof e2.toFixed == "function" && Array.isArray(e2.d);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var mt = class {
      constructor(t2, r2, n2, i2, o2) {
        this.modelName = t2, this.name = r2, this.typeName = n2, this.isList = i2, this.isEnum = o2;
      }
      _toGraphQLInputType() {
        let t2 = this.isList ? "List" : "", r2 = this.isEnum ? "Enum" : "";
        return `${t2}${r2}${this.typeName}FieldRefInput<${this.modelName}>`;
      }
    };
    function Qe(e2) {
      return e2 instanceof mt;
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Ft = class {
      constructor(t2) {
        this.value = t2;
      }
      write(t2) {
        t2.write(this.value);
      }
      markAsError() {
        this.value.markAsError();
      }
    };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Nt = (e2) => e2;
    var Bt = { bold: Nt, red: Nt, green: Nt, dim: Nt, enabled: false };
    var zn = { bold: Ct, red: Ne, green: hn, dim: Tt, enabled: true };
    var Je = { write(e2) {
      e2.writeLine(",");
    } };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var pe = class {
      constructor(t2) {
        this.contents = t2;
        this.isUnderlined = false;
        this.color = (t3) => t3;
      }
      underline() {
        return this.isUnderlined = true, this;
      }
      setColor(t2) {
        return this.color = t2, this;
      }
      write(t2) {
        let r2 = t2.getCurrentLineLength();
        t2.write(this.color(this.contents)), this.isUnderlined && t2.afterNextNewline(() => {
          t2.write(" ".repeat(r2)).writeLine(this.color("~".repeat(this.contents.length)));
        });
      }
    };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Ee = class {
      constructor() {
        this.hasError = false;
      }
      markAsError() {
        return this.hasError = true, this;
      }
    };
    var We = class extends Ee {
      constructor() {
        super(...arguments);
        this.items = [];
      }
      addItem(r2) {
        return this.items.push(new Ft(r2)), this;
      }
      getField(r2) {
        return this.items[r2];
      }
      getPrintWidth() {
        return this.items.length === 0 ? 2 : Math.max(...this.items.map((n2) => n2.value.getPrintWidth())) + 2;
      }
      write(r2) {
        if (this.items.length === 0) {
          this.writeEmpty(r2);
          return;
        }
        this.writeWithItems(r2);
      }
      writeEmpty(r2) {
        let n2 = new pe("[]");
        this.hasError && n2.setColor(r2.context.colors.red).underline(), r2.write(n2);
      }
      writeWithItems(r2) {
        let { colors: n2 } = r2.context;
        r2.writeLine("[").withIndent(() => r2.writeJoined(Je, this.items).newLine()).write("]"), this.hasError && r2.afterNextNewline(() => {
          r2.writeLine(n2.red("~".repeat(this.getPrintWidth())));
        });
      }
      asObject() {
      }
    };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Yn = ": ";
    var Ut = class {
      constructor(t2, r2) {
        this.name = t2;
        this.value = r2;
        this.hasError = false;
      }
      markAsError() {
        this.hasError = true;
      }
      getPrintWidth() {
        return this.name.length + this.value.getPrintWidth() + Yn.length;
      }
      write(t2) {
        let r2 = new pe(this.name);
        this.hasError && r2.underline().setColor(t2.context.colors.red), t2.write(r2).write(Yn).write(this.value);
      }
    };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var $t = class e2 extends Ee {
      constructor() {
        super(...arguments);
        this.fields = {};
        this.suggestions = [];
      }
      addField(r2) {
        this.fields[r2.name] = r2;
      }
      addSuggestion(r2) {
        this.suggestions.push(r2);
      }
      getField(r2) {
        return this.fields[r2];
      }
      getDeepField(r2) {
        let [n2, ...i2] = r2, o2 = this.getField(n2);
        if (!o2)
          return;
        let s2 = o2;
        for (let a2 of i2) {
          let f2;
          if (s2.value instanceof e2 ? f2 = s2.value.getField(a2) : s2.value instanceof We && (f2 = s2.value.getField(Number(a2))), !f2)
            return;
          s2 = f2;
        }
        return s2;
      }
      getDeepFieldValue(r2) {
        return r2.length === 0 ? this : this.getDeepField(r2)?.value;
      }
      hasField(r2) {
        return !!this.getField(r2);
      }
      removeAllFields() {
        this.fields = {};
      }
      removeField(r2) {
        delete this.fields[r2];
      }
      getFields() {
        return this.fields;
      }
      isEmpty() {
        return Object.keys(this.fields).length === 0;
      }
      getFieldValue(r2) {
        return this.getField(r2)?.value;
      }
      getDeepSubSelectionValue(r2) {
        let n2 = this;
        for (let i2 of r2) {
          if (!(n2 instanceof e2))
            return;
          let o2 = n2.getSubSelectionValue(i2);
          if (!o2)
            return;
          n2 = o2;
        }
        return n2;
      }
      getDeepSelectionParent(r2) {
        let n2 = this.getSelectionParent();
        if (!n2)
          return;
        let i2 = n2;
        for (let o2 of r2) {
          let s2 = i2.value.getFieldValue(o2);
          if (!s2 || !(s2 instanceof e2))
            return;
          let a2 = s2.getSelectionParent();
          if (!a2)
            return;
          i2 = a2;
        }
        return i2;
      }
      getSelectionParent() {
        let r2 = this.getField("select")?.value.asObject();
        if (r2)
          return { kind: "select", value: r2 };
        let n2 = this.getField("include")?.value.asObject();
        if (n2)
          return { kind: "include", value: n2 };
      }
      getSubSelectionValue(r2) {
        return this.getSelectionParent()?.value.fields[r2].value;
      }
      getPrintWidth() {
        let r2 = Object.values(this.fields);
        return r2.length == 0 ? 2 : Math.max(...r2.map((i2) => i2.getPrintWidth())) + 2;
      }
      write(r2) {
        let n2 = Object.values(this.fields);
        if (n2.length === 0 && this.suggestions.length === 0) {
          this.writeEmpty(r2);
          return;
        }
        this.writeWithContents(r2, n2);
      }
      asObject() {
        return this;
      }
      writeEmpty(r2) {
        let n2 = new pe("{}");
        this.hasError && n2.setColor(r2.context.colors.red).underline(), r2.write(n2);
      }
      writeWithContents(r2, n2) {
        r2.writeLine("{").withIndent(() => {
          r2.writeJoined(Je, [...n2, ...this.suggestions]).newLine();
        }), r2.write("}"), this.hasError && r2.afterNextNewline(() => {
          r2.writeLine(r2.context.colors.red("~".repeat(this.getPrintWidth())));
        });
      }
    };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var G2 = class extends Ee {
      constructor(r2) {
        super();
        this.text = r2;
      }
      getPrintWidth() {
        return this.text.length;
      }
      write(r2) {
        let n2 = new pe(this.text);
        this.hasError && n2.underline().setColor(r2.context.colors.red), r2.write(n2);
      }
      asObject() {
      }
    };
    var Mr = class {
      constructor(t2) {
        this.errorMessages = [];
        this.arguments = t2;
      }
      write(t2) {
        t2.write(this.arguments);
      }
      addErrorMessage(t2) {
        this.errorMessages.push(t2);
      }
      renderAllMessages(t2) {
        return this.errorMessages.map((r2) => r2(t2)).join(`
`);
      }
    };
    function Vt(e2) {
      return new Mr(Xn(e2));
    }
    function Xn(e2) {
      let t2 = new $t();
      for (let [r2, n2] of Object.entries(e2)) {
        let i2 = new Ut(r2, Zn(n2));
        t2.addField(i2);
      }
      return t2;
    }
    function Zn(e2) {
      if (typeof e2 == "string")
        return new G2(JSON.stringify(e2));
      if (typeof e2 == "number" || typeof e2 == "boolean")
        return new G2(String(e2));
      if (typeof e2 == "bigint")
        return new G2(`${e2}n`);
      if (e2 === null)
        return new G2("null");
      if (e2 === void 0)
        return new G2("undefined");
      if (je(e2))
        return new G2(`new Prisma.Decimal("${e2.toFixed()}")`);
      if (e2 instanceof Uint8Array)
        return y2.isBuffer(e2) ? new G2(`Buffer.alloc(${e2.byteLength})`) : new G2(`new Uint8Array(${e2.byteLength})`);
      if (e2 instanceof Date) {
        let t2 = Dt(e2) ? e2.toISOString() : "Invalid Date";
        return new G2(`new Date("${t2}")`);
      }
      return e2 instanceof be2 ? new G2(`Prisma.${e2._getName()}`) : Qe(e2) ? new G2(`prisma.${Hn(e2.modelName)}.$fields.${e2.name}`) : Array.isArray(e2) ? bs2(e2) : typeof e2 == "object" ? Xn(e2) : new G2(Object.prototype.toString.call(e2));
    }
    function bs2(e2) {
      let t2 = new We();
      for (let r2 of e2)
        t2.addItem(Zn(r2));
      return t2;
    }
    function ei(e2) {
      if (e2 === void 0)
        return "";
      let t2 = Vt(e2);
      return new Ve(0, { colors: Bt }).write(t2).toString();
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var ws = "P2037";
    function qt({ error: e2, user_facing_error: t2 }, r2, n2) {
      return t2.error_code ? new Q2(Es(t2, n2), { code: t2.error_code, clientVersion: r2, meta: t2.meta, batchRequestIdx: t2.batch_request_idx }) : new J2(e2, { clientVersion: r2, batchRequestIdx: t2.batch_request_idx });
    }
    function Es(e2, t2) {
      let r2 = e2.message;
      return (t2 === "postgresql" || t2 === "postgres" || t2 === "mysql") && e2.error_code === ws && (r2 += `
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`), r2;
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Ir = class {
      getLocation() {
        return null;
      }
    };
    function xe(e2) {
      return typeof $EnabledCallSite == "function" && e2 !== "minimal" ? new $EnabledCallSite() : new Ir();
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var ti = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
    function Ge(e2 = {}) {
      let t2 = Ps(e2);
      return Object.entries(t2).reduce((n2, [i2, o2]) => (ti[i2] !== void 0 ? n2.select[i2] = { select: o2 } : n2[i2] = o2, n2), { select: {} });
    }
    function Ps(e2 = {}) {
      return typeof e2._count == "boolean" ? { ...e2, _count: { _all: e2._count } } : e2;
    }
    function jt(e2 = {}) {
      return (t2) => (typeof e2._count == "boolean" && (t2._count = t2._count._all), t2);
    }
    function ri(e2, t2) {
      let r2 = jt(e2);
      return t2({ action: "aggregate", unpacker: r2, argsMapper: Ge })(e2);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function vs(e2 = {}) {
      let { select: t2, ...r2 } = e2;
      return typeof t2 == "object" ? Ge({ ...r2, _count: t2 }) : Ge({ ...r2, _count: { _all: true } });
    }
    function Cs(e2 = {}) {
      return typeof e2.select == "object" ? (t2) => jt(e2)(t2)._count : (t2) => jt(e2)(t2)._count._all;
    }
    function ni(e2, t2) {
      return t2({ action: "count", unpacker: Cs(e2), argsMapper: vs })(e2);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function Ts(e2 = {}) {
      let t2 = Ge(e2);
      if (Array.isArray(t2.by))
        for (let r2 of t2.by)
          typeof r2 == "string" && (t2.select[r2] = true);
      else
        typeof t2.by == "string" && (t2.select[t2.by] = true);
      return t2;
    }
    function As(e2 = {}) {
      return (t2) => (typeof e2?._count == "boolean" && t2.forEach((r2) => {
        r2._count = r2._count._all;
      }), t2);
    }
    function ii2(e2, t2) {
      return t2({ action: "groupBy", unpacker: As(e2), argsMapper: Ts })(e2);
    }
    function oi(e2, t2, r2) {
      if (t2 === "aggregate")
        return (n2) => ri(n2, r2);
      if (t2 === "count")
        return (n2) => ni(n2, r2);
      if (t2 === "groupBy")
        return (n2) => ii2(n2, r2);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function si(e2, t2) {
      let r2 = t2.fields.filter((i2) => !i2.relationName), n2 = vr(r2, (i2) => i2.name);
      return new Proxy({}, { get(i2, o2) {
        if (o2 in i2 || typeof o2 == "symbol")
          return i2[o2];
        let s2 = n2[o2];
        if (s2)
          return new mt(e2, o2, s2.type, s2.isList, s2.kind === "enum");
      }, ...It(Object.keys(n2)) });
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var ai2 = (e2) => Array.isArray(e2) ? e2 : e2.split(".");
    var _r = (e2, t2) => ai2(t2).reduce((r2, n2) => r2 && r2[n2], e2);
    var li = (e2, t2, r2) => ai2(t2).reduceRight((n2, i2, o2, s2) => Object.assign({}, _r(e2, s2.slice(0, o2)), { [i2]: n2 }), r2);
    function Rs(e2, t2) {
      return e2 === void 0 || t2 === void 0 ? [] : [...t2, "select", e2];
    }
    function Ss(e2, t2, r2) {
      return t2 === void 0 ? e2 ?? {} : li(t2, r2, e2 || true);
    }
    function Dr(e2, t2, r2, n2, i2, o2) {
      let a2 = e2._runtimeDataModel.models[t2].fields.reduce((f2, v2) => ({ ...f2, [v2.name]: v2 }), {});
      return (f2) => {
        let v2 = xe(e2._errorFormat), C2 = Rs(n2, i2), T2 = Ss(f2, o2, C2), O2 = r2({ dataPath: C2, callsite: v2 })(T2), R2 = Os(e2, t2);
        return new Proxy(O2, { get(L2, S2) {
          if (!R2.includes(S2))
            return L2[S2];
          let ne = [a2[S2].type, r2, S2], z5 = [C2, T2];
          return Dr(e2, ...ne, ...z5);
        }, ...It([...R2, ...Object.getOwnPropertyNames(O2)]) });
      };
    }
    function Os(e2, t2) {
      return e2._runtimeDataModel.models[t2].fields.filter((r2) => r2.kind === "object").map((r2) => r2.name);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var ks = _e(_n());
    var Ls = { red: Ne, gray: wn, dim: Tt, bold: Ct, underline: gn, highlightSource: (e2) => e2.highlight() };
    var Ms = { red: (e2) => e2, gray: (e2) => e2, dim: (e2) => e2, bold: (e2) => e2, underline: (e2) => e2, highlightSource: (e2) => e2 };
    function Is({ message: e2, originalMethod: t2, isPanic: r2, callArguments: n2 }) {
      return { functionName: `prisma.${t2}()`, message: e2, isPanic: r2 ?? false, callArguments: n2 };
    }
    function _s2({ functionName: e2, location: t2, message: r2, isPanic: n2, contextLines: i2, callArguments: o2 }, s2) {
      let a2 = [""], f2 = t2 ? " in" : ":";
      if (n2 ? (a2.push(s2.red(`Oops, an unknown error occurred! This is ${s2.bold("on us")}, you did nothing wrong.`)), a2.push(s2.red(`It occurred in the ${s2.bold(`\`${e2}\``)} invocation${f2}`))) : a2.push(s2.red(`Invalid ${s2.bold(`\`${e2}\``)} invocation${f2}`)), t2 && a2.push(s2.underline(Ds(t2))), i2) {
        a2.push("");
        let v2 = [i2.toString()];
        o2 && (v2.push(o2), v2.push(s2.dim(")"))), a2.push(v2.join("")), o2 && a2.push("");
      } else
        a2.push(""), o2 && a2.push(o2), a2.push("");
      return a2.push(r2), a2.join(`
`);
    }
    function Ds(e2) {
      let t2 = [e2.fileName];
      return e2.lineNumber && t2.push(String(e2.lineNumber)), e2.columnNumber && t2.push(String(e2.columnNumber)), t2.join(":");
    }
    function Ke(e2) {
      let t2 = e2.showColors ? Ls : Ms, r2;
      return typeof $getTemplateParameters < "u" ? r2 = $getTemplateParameters(e2, t2) : r2 = Is(e2), _s2(r2, t2);
    }
    function ui(e2, t2, r2, n2) {
      return e2 === Oe.ModelAction.findFirstOrThrow || e2 === Oe.ModelAction.findUniqueOrThrow ? Fs(t2, r2, n2) : n2;
    }
    function Fs(e2, t2, r2) {
      return async (n2) => {
        if ("rejectOnNotFound" in n2.args) {
          let o2 = Ke({ originalMethod: n2.clientMethod, callsite: n2.callsite, message: "'rejectOnNotFound' option is not supported" });
          throw new W2(o2, { clientVersion: t2 });
        }
        return await r2(n2).catch((o2) => {
          throw o2 instanceof Q2 && o2.code === "P2025" ? new he(`No ${e2} found`, t2) : o2;
        });
      };
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function de(e2) {
      return e2.replace(/^./, (t2) => t2.toLowerCase());
    }
    var Ns = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
    var Bs = ["aggregate", "count", "groupBy"];
    function Fr(e2, t2) {
      let r2 = e2._extensions.getAllModelExtensions(t2) ?? {}, n2 = [Us(e2, t2), Vs(e2, t2), ct2(r2), H2("name", () => t2), H2("$name", () => t2), H2("$parent", () => e2._appliedParent)];
      return me({}, n2);
    }
    function Us(e2, t2) {
      let r2 = de(t2), n2 = Object.keys(Oe.ModelAction).concat("count");
      return { getKeys() {
        return n2;
      }, getPropertyValue(i2) {
        let o2 = i2, s2 = (f2) => e2._request(f2);
        s2 = ui(o2, t2, e2._clientVersion, s2);
        let a2 = (f2) => (v2) => {
          let C2 = xe(e2._errorFormat);
          return e2._createPrismaPromise((T2) => {
            let O2 = { args: v2, dataPath: [], action: o2, model: t2, clientMethod: `${r2}.${i2}`, jsModelName: r2, transaction: T2, callsite: C2 };
            return s2({ ...O2, ...f2 });
          });
        };
        return Ns.includes(o2) ? Dr(e2, t2, a2) : $s(i2) ? oi(e2, i2, a2) : a2({});
      } };
    }
    function $s(e2) {
      return Bs.includes(e2);
    }
    function Vs(e2, t2) {
      return Me(H2("fields", () => {
        let r2 = e2._runtimeDataModel.models[t2];
        return si(t2, r2);
      }));
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function ci2(e2) {
      return e2.replace(/^./, (t2) => t2.toUpperCase());
    }
    var Nr = Symbol();
    function pt(e2) {
      let t2 = [qs(e2), H2(Nr, () => e2), H2("$parent", () => e2._appliedParent)], r2 = e2._extensions.getAllClientExtensions();
      return r2 && t2.push(ct2(r2)), me(e2, t2);
    }
    function qs(e2) {
      let t2 = Object.keys(e2._runtimeDataModel.models), r2 = t2.map(de), n2 = [...new Set(t2.concat(r2))];
      return Me({ getKeys() {
        return n2;
      }, getPropertyValue(i2) {
        let o2 = ci2(i2);
        if (e2._runtimeDataModel.models[o2] !== void 0)
          return Fr(e2, o2);
        if (e2._runtimeDataModel.models[i2] !== void 0)
          return Fr(e2, i2);
      }, getPropertyDescriptor(i2) {
        if (!r2.includes(i2))
          return { enumerable: false };
      } });
    }
    function mi(e2) {
      return e2[Nr] ? e2[Nr] : e2;
    }
    function pi(e2) {
      if (typeof e2 == "function")
        return e2(this);
      if (e2.client?.__AccelerateEngine) {
        let r2 = e2.client.__AccelerateEngine;
        this._originalClient._engine = new r2(this._originalClient._accelerateEngineConfig);
      }
      let t2 = Object.create(this._originalClient, { _extensions: { value: this._extensions.append(e2) }, _appliedParent: { value: this, configurable: true }, $use: { value: void 0 }, $on: { value: void 0 } });
      return pt(t2);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function di({ result: e2, modelName: t2, select: r2, omit: n2, extensions: i2 }) {
      let o2 = i2.getAllComputedFields(t2);
      if (!o2)
        return e2;
      let s2 = [], a2 = [];
      for (let f2 of Object.values(o2)) {
        if (n2) {
          if (n2[f2.name])
            continue;
          let v2 = f2.needs.filter((C2) => n2[C2]);
          v2.length > 0 && a2.push($e(v2));
        } else if (r2) {
          if (!r2[f2.name])
            continue;
          let v2 = f2.needs.filter((C2) => !r2[C2]);
          v2.length > 0 && a2.push($e(v2));
        }
        js(e2, f2.needs) && s2.push(Qs(f2, me(e2, s2)));
      }
      return s2.length > 0 || a2.length > 0 ? me(e2, [...s2, ...a2]) : e2;
    }
    function js(e2, t2) {
      return t2.every((r2) => Pr(e2, r2));
    }
    function Qs(e2, t2) {
      return Me(H2(e2.name, () => e2.compute(t2)));
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function Qt({ visitor: e2, result: t2, args: r2, runtimeDataModel: n2, modelName: i2 }) {
      if (Array.isArray(t2)) {
        for (let s2 = 0; s2 < t2.length; s2++)
          t2[s2] = Qt({ result: t2[s2], args: r2, modelName: i2, runtimeDataModel: n2, visitor: e2 });
        return t2;
      }
      let o2 = e2(t2, i2, r2) ?? t2;
      return r2.include && fi({ includeOrSelect: r2.include, result: o2, parentModelName: i2, runtimeDataModel: n2, visitor: e2 }), r2.select && fi({ includeOrSelect: r2.select, result: o2, parentModelName: i2, runtimeDataModel: n2, visitor: e2 }), o2;
    }
    function fi({ includeOrSelect: e2, result: t2, parentModelName: r2, runtimeDataModel: n2, visitor: i2 }) {
      for (let [o2, s2] of Object.entries(e2)) {
        if (!s2 || t2[o2] == null)
          continue;
        let f2 = n2.models[r2].fields.find((C2) => C2.name === o2);
        if (!f2 || f2.kind !== "object" || !f2.relationName)
          continue;
        let v2 = typeof s2 == "object" ? s2 : {};
        t2[o2] = Qt({ visitor: i2, result: t2[o2], args: v2, modelName: f2.type, runtimeDataModel: n2 });
      }
    }
    function gi({ result: e2, modelName: t2, args: r2, extensions: n2, runtimeDataModel: i2 }) {
      return n2.isEmpty() || e2 == null || typeof e2 != "object" || !i2.models[t2] ? e2 : Qt({ result: e2, args: r2 ?? {}, modelName: t2, runtimeDataModel: i2, visitor: (s2, a2, f2) => di({ result: s2, modelName: de(a2), select: f2.select, omit: f2.omit, extensions: n2 }) });
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    l2();
    function hi(e2) {
      if (e2 instanceof X2)
        return Js(e2);
      if (Array.isArray(e2)) {
        let r2 = [e2[0]];
        for (let n2 = 1; n2 < e2.length; n2++)
          r2[n2] = dt(e2[n2]);
        return r2;
      }
      let t2 = {};
      for (let r2 in e2)
        t2[r2] = dt(e2[r2]);
      return t2;
    }
    function Js(e2) {
      return new X2(e2.strings, e2.values);
    }
    function dt(e2) {
      if (typeof e2 != "object" || e2 == null || e2 instanceof be2 || Qe(e2))
        return e2;
      if (je(e2))
        return new ue(e2.toFixed());
      if (qe(e2))
        return /* @__PURE__ */ new Date(+e2);
      if (ArrayBuffer.isView(e2))
        return e2.slice(0);
      if (Array.isArray(e2)) {
        let t2 = e2.length, r2;
        for (r2 = Array(t2); t2--; )
          r2[t2] = dt(e2[t2]);
        return r2;
      }
      if (typeof e2 == "object") {
        let t2 = {};
        for (let r2 in e2)
          r2 === "__proto__" ? Object.defineProperty(t2, r2, { value: dt(e2[r2]), configurable: true, enumerable: true, writable: true }) : t2[r2] = dt(e2[r2]);
        return t2;
      }
      ke(e2, "Unknown value");
    }
    function bi2(e2, t2, r2, n2 = 0) {
      return e2._createPrismaPromise((i2) => {
        let o2 = t2.customDataProxyFetch;
        return "transaction" in t2 && i2 !== void 0 && (t2.transaction?.kind === "batch" && t2.transaction.lock.then(), t2.transaction = i2), n2 === r2.length ? e2._executeRequest(t2) : r2[n2]({ model: t2.model, operation: t2.model ? t2.action : t2.clientMethod, args: hi(t2.args ?? {}), __internalParams: t2, query: (s2, a2 = t2) => {
          let f2 = a2.customDataProxyFetch;
          return a2.customDataProxyFetch = Pi(o2, f2), a2.args = s2, bi2(e2, a2, r2, n2 + 1);
        } });
      });
    }
    function wi(e2, t2) {
      let { jsModelName: r2, action: n2, clientMethod: i2 } = t2, o2 = r2 ? n2 : i2;
      if (e2._extensions.isEmpty())
        return e2._executeRequest(t2);
      let s2 = e2._extensions.getAllQueryCallbacks(r2 ?? "$none", o2);
      return bi2(e2, t2, s2);
    }
    function Ei(e2) {
      return (t2) => {
        let r2 = { requests: t2 }, n2 = t2[0].extensions.getAllBatchQueryCallbacks();
        return n2.length ? xi(r2, n2, 0, e2) : e2(r2);
      };
    }
    function xi(e2, t2, r2, n2) {
      if (r2 === t2.length)
        return n2(e2);
      let i2 = e2.customDataProxyFetch, o2 = e2.requests[0].transaction;
      return t2[r2]({ args: { queries: e2.requests.map((s2) => ({ model: s2.modelName, operation: s2.action, args: s2.args })), transaction: o2 ? { isolationLevel: o2.kind === "batch" ? o2.isolationLevel : void 0 } : void 0 }, __internalParams: e2, query(s2, a2 = e2) {
        let f2 = a2.customDataProxyFetch;
        return a2.customDataProxyFetch = Pi(i2, f2), xi(a2, t2, r2 + 1, n2);
      } });
    }
    var yi = (e2) => e2;
    function Pi(e2 = yi, t2 = yi) {
      return (r2) => e2(t2(r2));
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function Ci(e2, t2, r2) {
      let n2 = de(r2);
      return !t2.result || !(t2.result.$allModels || t2.result[n2]) ? e2 : Ws({ ...e2, ...vi(t2.name, e2, t2.result.$allModels), ...vi(t2.name, e2, t2.result[n2]) });
    }
    function Ws(e2) {
      let t2 = new ce2(), r2 = (n2, i2) => t2.getOrCreate(n2, () => i2.has(n2) ? [n2] : (i2.add(n2), e2[n2] ? e2[n2].needs.flatMap((o2) => r2(o2, i2)) : [n2]));
      return Be(e2, (n2) => ({ ...n2, needs: r2(n2.name, /* @__PURE__ */ new Set()) }));
    }
    function vi(e2, t2, r2) {
      return r2 ? Be(r2, ({ needs: n2, compute: i2 }, o2) => ({ name: o2, needs: n2 ? Object.keys(n2).filter((s2) => n2[s2]) : [], compute: Gs(t2, o2, i2) })) : {};
    }
    function Gs(e2, t2, r2) {
      let n2 = e2?.[t2]?.compute;
      return n2 ? (i2) => r2({ ...i2, [t2]: n2(i2) }) : r2;
    }
    function Ti(e2, t2) {
      if (!t2)
        return e2;
      let r2 = { ...e2 };
      for (let n2 of Object.values(t2))
        if (e2[n2.name])
          for (let i2 of n2.needs)
            r2[i2] = true;
      return r2;
    }
    function Ai(e2, t2) {
      if (!t2)
        return e2;
      let r2 = { ...e2 };
      for (let n2 of Object.values(t2))
        if (!e2[n2.name])
          for (let i2 of n2.needs)
            delete r2[i2];
      return r2;
    }
    var Jt = class {
      constructor(t2, r2) {
        this.extension = t2;
        this.previous = r2;
        this.computedFieldsCache = new ce2();
        this.modelExtensionsCache = new ce2();
        this.queryCallbacksCache = new ce2();
        this.clientExtensions = it(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
        this.batchCallbacks = it(() => {
          let t3 = this.previous?.getAllBatchQueryCallbacks() ?? [], r3 = this.extension.query?.$__internalBatch;
          return r3 ? t3.concat(r3) : t3;
        });
      }
      getAllComputedFields(t2) {
        return this.computedFieldsCache.getOrCreate(t2, () => Ci(this.previous?.getAllComputedFields(t2), this.extension, t2));
      }
      getAllClientExtensions() {
        return this.clientExtensions.get();
      }
      getAllModelExtensions(t2) {
        return this.modelExtensionsCache.getOrCreate(t2, () => {
          let r2 = de(t2);
          return !this.extension.model || !(this.extension.model[r2] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(t2) : { ...this.previous?.getAllModelExtensions(t2), ...this.extension.model.$allModels, ...this.extension.model[r2] };
        });
      }
      getAllQueryCallbacks(t2, r2) {
        return this.queryCallbacksCache.getOrCreate(`${t2}:${r2}`, () => {
          let n2 = this.previous?.getAllQueryCallbacks(t2, r2) ?? [], i2 = [], o2 = this.extension.query;
          return !o2 || !(o2[t2] || o2.$allModels || o2[r2] || o2.$allOperations) ? n2 : (o2[t2] !== void 0 && (o2[t2][r2] !== void 0 && i2.push(o2[t2][r2]), o2[t2].$allOperations !== void 0 && i2.push(o2[t2].$allOperations)), t2 !== "$none" && o2.$allModels !== void 0 && (o2.$allModels[r2] !== void 0 && i2.push(o2.$allModels[r2]), o2.$allModels.$allOperations !== void 0 && i2.push(o2.$allModels.$allOperations)), o2[r2] !== void 0 && i2.push(o2[r2]), o2.$allOperations !== void 0 && i2.push(o2.$allOperations), n2.concat(i2));
        });
      }
      getAllBatchQueryCallbacks() {
        return this.batchCallbacks.get();
      }
    };
    var Wt = class e2 {
      constructor(t2) {
        this.head = t2;
      }
      static empty() {
        return new e2();
      }
      static single(t2) {
        return new e2(new Jt(t2));
      }
      isEmpty() {
        return this.head === void 0;
      }
      append(t2) {
        return new e2(new Jt(t2, this.head));
      }
      getAllComputedFields(t2) {
        return this.head?.getAllComputedFields(t2);
      }
      getAllClientExtensions() {
        return this.head?.getAllClientExtensions();
      }
      getAllModelExtensions(t2) {
        return this.head?.getAllModelExtensions(t2);
      }
      getAllQueryCallbacks(t2, r2) {
        return this.head?.getAllQueryCallbacks(t2, r2) ?? [];
      }
      getAllBatchQueryCallbacks() {
        return this.head?.getAllBatchQueryCallbacks() ?? [];
      }
    };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Ri = ee("prisma:client");
    var Si = { Vercel: "vercel", "Netlify CI": "netlify" };
    function Oi({ postinstall: e2, ciName: t2, clientVersion: r2 }) {
      if (Ri("checkPlatformCaching:postinstall", e2), Ri("checkPlatformCaching:ciName", t2), e2 === true && t2 && t2 in Si) {
        let n2 = `Prisma has detected that this project was built on ${t2}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${Si[t2]}-build`;
        throw console.error(n2), new I2(n2, r2);
      }
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function ki(e2, t2) {
      return e2 ? e2.datasources ? e2.datasources : e2.datasourceUrl ? { [t2[0]]: { url: e2.datasourceUrl } } : {} : {};
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Ks = "Cloudflare-Workers";
    var Hs = "node";
    function Li() {
      return typeof Netlify == "object" ? "netlify" : typeof EdgeRuntime == "string" ? "edge-light" : globalThis.navigator?.userAgent === Ks ? "workerd" : globalThis.Deno ? "deno" : globalThis.__lagon__ ? "lagon" : globalThis.process?.release?.name === Hs ? "node" : globalThis.Bun ? "bun" : globalThis.fastly ? "fastly" : "unknown";
    }
    var zs = { node: "Node.js", workerd: "Cloudflare Workers", deno: "Deno and Deno Deploy", netlify: "Netlify Edge Functions", "edge-light": "Vercel Edge Functions or Edge Middleware" };
    function Pe() {
      let e2 = Li();
      return { id: e2, prettyName: zs[e2] || e2, isEdge: ["workerd", "deno", "netlify", "edge-light"].includes(e2) };
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function Gt({ inlineDatasources: e2, overrideDatasources: t2, env: r2, clientVersion: n2 }) {
      let i2, o2 = Object.keys(e2)[0], s2 = e2[o2]?.url, a2 = t2[o2]?.url;
      if (o2 === void 0 ? i2 = void 0 : a2 ? i2 = a2 : s2?.value ? i2 = s2.value : s2?.fromEnvVar && (i2 = r2[s2.fromEnvVar]), s2?.fromEnvVar !== void 0 && i2 === void 0)
        throw Pe().id === "workerd" ? new I2(`error: Environment variable not found: ${s2.fromEnvVar}.

In Cloudflare module Workers, environment variables are available only in the Worker's \`env\` parameter of \`fetch\`.
To solve this, provide the connection string directly: https://pris.ly/d/cloudflare-datasource-url`, n2) : new I2(`error: Environment variable not found: ${s2.fromEnvVar}.`, n2);
      if (i2 === void 0)
        throw new I2("error: Missing URL environment variable, value, or override.", n2);
      return i2;
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function Mi(e2) {
      if (e2?.kind === "itx")
        return e2.options.id;
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Br;
    var Ii = { async loadLibrary(e2) {
      let { clientVersion: t2, adapter: r2, engineWasm: n2 } = e2;
      if (r2 === void 0)
        throw new I2(`The \`adapter\` option for \`PrismaClient\` is required in this context (${Pe().prettyName})`, t2);
      if (n2 === void 0)
        throw new I2("WASM engine was unexpectedly `undefined`", t2);
      Br === void 0 && (Br = (async () => {
        let o2 = n2.getRuntime(), s2 = await n2.getQueryEngineWasmModule();
        if (s2 == null)
          throw new I2("The loaded wasm module was unexpectedly `undefined` or `null` once loaded", t2);
        let a2 = { "./query_engine_bg.js": o2 }, f2 = new WebAssembly.Instance(s2, a2);
        return o2.__wbg_set_wasm(f2.exports), o2.QueryEngine;
      })());
      let i2 = await Br;
      return { debugPanic() {
        return Promise.reject("{}");
      }, dmmf() {
        return Promise.resolve("{}");
      }, version() {
        return { commit: "unknown", version: "unknown" };
      }, QueryEngine: i2 };
    } };
    var Ys = "P2036";
    var fe = ee("prisma:client:libraryEngine");
    function Xs(e2) {
      return e2.item_type === "query" && "query" in e2;
    }
    function Zs(e2) {
      return "level" in e2 ? e2.level === "error" && e2.message === "PANIC" : false;
    }
    var MC = [...Er, "native"];
    var _i = 0;
    var ft = class {
      constructor(t2, r2) {
        this.name = "LibraryEngine";
        this.libraryLoader = r2 ?? Ii, this.config = t2, this.libraryStarted = false, this.logQueries = t2.logQueries ?? false, this.logLevel = t2.logLevel ?? "error", this.logEmitter = t2.logEmitter, this.datamodel = t2.inlineSchema, t2.enableDebugLogs && (this.logLevel = "debug");
        let n2 = Object.keys(t2.overrideDatasources)[0], i2 = t2.overrideDatasources[n2]?.url;
        n2 !== void 0 && i2 !== void 0 && (this.datasourceOverrides = { [n2]: i2 }), this.libraryInstantiationPromise = this.instantiateLibrary(), this.checkForTooManyEngines();
      }
      checkForTooManyEngines() {
        _i === 10 && console.warn(`${At("warn(prisma-client)")} This is the 10th instance of Prisma Client being started. Make sure this is intentional.`);
      }
      async applyPendingMigrations() {
        throw new Error("Cannot call this method from this type of engine instance");
      }
      async transaction(t2, r2, n2) {
        await this.start();
        let i2 = JSON.stringify(r2), o2;
        if (t2 === "start") {
          let a2 = JSON.stringify({ max_wait: n2.maxWait, timeout: n2.timeout, isolation_level: n2.isolationLevel });
          o2 = await this.engine?.startTransaction(a2, i2);
        } else
          t2 === "commit" ? o2 = await this.engine?.commitTransaction(n2.id, i2) : t2 === "rollback" && (o2 = await this.engine?.rollbackTransaction(n2.id, i2));
        let s2 = this.parseEngineResponse(o2);
        if (ea(s2)) {
          let a2 = this.getExternalAdapterError(s2);
          throw a2 ? a2.error : new Q2(s2.message, { code: s2.error_code, clientVersion: this.config.clientVersion, meta: s2.meta });
        }
        return s2;
      }
      async instantiateLibrary() {
        if (fe("internalSetup"), this.libraryInstantiationPromise)
          return this.libraryInstantiationPromise;
        this.binaryTarget = await this.getCurrentBinaryTarget(), await this.loadEngine(), this.version();
      }
      async getCurrentBinaryTarget() {
      }
      parseEngineResponse(t2) {
        if (!t2)
          throw new J2("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
        try {
          return JSON.parse(t2);
        } catch {
          throw new J2("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
        }
      }
      async loadEngine() {
        if (!this.engine) {
          this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(this.config), this.QueryEngineConstructor = this.library.QueryEngine);
          try {
            let t2 = new b2(this), { adapter: r2 } = this.config;
            r2 && fe("Using driver adapter: %O", r2), this.engine = new this.QueryEngineConstructor({ datamodel: this.datamodel, env: g2.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json" }, (n2) => {
              t2.deref()?.logger(n2);
            }, r2), _i++;
          } catch (t2) {
            let r2 = t2, n2 = this.parseInitError(r2.message);
            throw typeof n2 == "string" ? r2 : new I2(n2.message, this.config.clientVersion, n2.error_code);
          }
        }
      }
      logger(t2) {
        let r2 = this.parseEngineResponse(t2);
        if (r2) {
          if ("span" in r2) {
            this.config.tracingHelper.createEngineSpan(r2);
            return;
          }
          r2.level = r2?.level.toLowerCase() ?? "unknown", Xs(r2) ? this.logEmitter.emit("query", { timestamp: /* @__PURE__ */ new Date(), query: r2.query, params: r2.params, duration: Number(r2.duration_ms), target: r2.module_path }) : (Zs(r2), this.logEmitter.emit(r2.level, { timestamp: /* @__PURE__ */ new Date(), message: r2.message, target: r2.module_path }));
        }
      }
      parseInitError(t2) {
        try {
          return JSON.parse(t2);
        } catch {
        }
        return t2;
      }
      parseRequestError(t2) {
        try {
          return JSON.parse(t2);
        } catch {
        }
        return t2;
      }
      onBeforeExit() {
        throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
      }
      async start() {
        if (await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise)
          return fe(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
        if (this.libraryStarted)
          return;
        let t2 = async () => {
          fe("library starting");
          try {
            let r2 = { traceparent: this.config.tracingHelper.getTraceParent() };
            await this.engine?.connect(JSON.stringify(r2)), this.libraryStarted = true, fe("library started");
          } catch (r2) {
            let n2 = this.parseInitError(r2.message);
            throw typeof n2 == "string" ? r2 : new I2(n2.message, this.config.clientVersion, n2.error_code);
          } finally {
            this.libraryStartingPromise = void 0;
          }
        };
        return this.libraryStartingPromise = this.config.tracingHelper.runInChildSpan("connect", t2), this.libraryStartingPromise;
      }
      async stop() {
        if (await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise)
          return fe("library is already stopping"), this.libraryStoppingPromise;
        if (!this.libraryStarted)
          return;
        let t2 = async () => {
          await new Promise((n2) => setTimeout(n2, 5)), fe("library stopping");
          let r2 = { traceparent: this.config.tracingHelper.getTraceParent() };
          await this.engine?.disconnect(JSON.stringify(r2)), this.libraryStarted = false, this.libraryStoppingPromise = void 0, fe("library stopped");
        };
        return this.libraryStoppingPromise = this.config.tracingHelper.runInChildSpan("disconnect", t2), this.libraryStoppingPromise;
      }
      version() {
        return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
      }
      debugPanic(t2) {
        return this.library?.debugPanic(t2);
      }
      async request(t2, { traceparent: r2, interactiveTransaction: n2 }) {
        fe(`sending request, this.libraryStarted: ${this.libraryStarted}`);
        let i2 = JSON.stringify({ traceparent: r2 }), o2 = JSON.stringify(t2);
        try {
          await this.start(), this.executingQueryPromise = this.engine?.query(o2, i2, n2?.id), this.lastQuery = o2;
          let s2 = this.parseEngineResponse(await this.executingQueryPromise);
          if (s2.errors)
            throw s2.errors.length === 1 ? this.buildQueryError(s2.errors[0]) : new J2(JSON.stringify(s2.errors), { clientVersion: this.config.clientVersion });
          if (this.loggerRustPanic)
            throw this.loggerRustPanic;
          return { data: s2, elapsed: 0 };
        } catch (s2) {
          if (s2 instanceof I2)
            throw s2;
          s2.code === "GenericFailure" && s2.message?.startsWith("PANIC:");
          let a2 = this.parseRequestError(s2.message);
          throw typeof a2 == "string" ? s2 : new J2(`${a2.message}
${a2.backtrace}`, { clientVersion: this.config.clientVersion });
        }
      }
      async requestBatch(t2, { transaction: r2, traceparent: n2 }) {
        fe("requestBatch");
        let i2 = _t(t2, r2);
        await this.start(), this.lastQuery = JSON.stringify(i2), this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify({ traceparent: n2 }), Mi(r2));
        let o2 = await this.executingQueryPromise, s2 = this.parseEngineResponse(o2);
        if (s2.errors)
          throw s2.errors.length === 1 ? this.buildQueryError(s2.errors[0]) : new J2(JSON.stringify(s2.errors), { clientVersion: this.config.clientVersion });
        let { batchResult: a2, errors: f2 } = s2;
        if (Array.isArray(a2))
          return a2.map((v2) => v2.errors && v2.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(v2.errors[0]) : { data: v2, elapsed: 0 });
        throw f2 && f2.length === 1 ? new Error(f2[0].error) : new Error(JSON.stringify(s2));
      }
      buildQueryError(t2) {
        t2.user_facing_error.is_panic;
        let r2 = this.getExternalAdapterError(t2.user_facing_error);
        return r2 ? r2.error : qt(t2, this.config.clientVersion, this.config.activeProvider);
      }
      getExternalAdapterError(t2) {
        if (t2.error_code === Ys && this.config.adapter) {
          let r2 = t2.meta?.id;
          Ot(typeof r2 == "number", "Malformed external JS error received from the engine");
          let n2 = this.config.adapter.errorRegistry.consumeError(r2);
          return Ot(n2, "External error with reported id was not registered"), n2;
        }
      }
      async metrics(t2) {
        await this.start();
        let r2 = await this.engine.metrics(JSON.stringify(t2));
        return t2.format === "prometheus" ? r2 : this.parseEngineResponse(r2);
      }
    };
    function ea(e2) {
      return typeof e2 == "object" && e2 !== null && e2.error_code !== void 0;
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var gt = "Accelerate has not been setup correctly. Make sure your client is using `.$extends(withAccelerate())`. See https://pris.ly/d/accelerate-getting-started";
    var Kt = class {
      constructor(t2) {
        this.config = t2;
        this.name = "AccelerateEngine";
        this.resolveDatasourceUrl = this.config.accelerateUtils?.resolveDatasourceUrl;
        this.getBatchRequestPayload = this.config.accelerateUtils?.getBatchRequestPayload;
        this.prismaGraphQLToJSError = this.config.accelerateUtils?.prismaGraphQLToJSError;
        this.PrismaClientUnknownRequestError = this.config.accelerateUtils?.PrismaClientUnknownRequestError;
        this.PrismaClientInitializationError = this.config.accelerateUtils?.PrismaClientInitializationError;
        this.PrismaClientKnownRequestError = this.config.accelerateUtils?.PrismaClientKnownRequestError;
        this.debug = this.config.accelerateUtils?.debug;
        this.engineVersion = this.config.accelerateUtils?.engineVersion;
        this.clientVersion = this.config.accelerateUtils?.clientVersion;
      }
      onBeforeExit(t2) {
      }
      async start() {
      }
      async stop() {
      }
      version(t2) {
        return "unknown";
      }
      transaction(t2, r2, n2) {
        throw new I2(gt, this.config.clientVersion);
      }
      metrics(t2) {
        throw new I2(gt, this.config.clientVersion);
      }
      request(t2, r2) {
        throw new I2(gt, this.config.clientVersion);
      }
      requestBatch(t2, r2) {
        throw new I2(gt, this.config.clientVersion);
      }
      applyPendingMigrations() {
        throw new I2(gt, this.config.clientVersion);
      }
    };
    function Di({ copyEngine: e2 = true }, t2) {
      let r2;
      try {
        r2 = Gt({ inlineDatasources: t2.inlineDatasources, overrideDatasources: t2.overrideDatasources, env: { ...t2.env, ...g2.env }, clientVersion: t2.clientVersion });
      } catch {
      }
      e2 && r2?.startsWith("prisma://") && nt("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
      let n2 = et(t2.generator), i2 = !!(r2?.startsWith("prisma://") || !e2), o2 = !!t2.adapter, s2 = n2 === "library", a2 = n2 === "binary";
      if (i2 && o2 || o2 && false) {
        let f2;
        throw e2 ? r2?.startsWith("prisma://") ? f2 = ["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.", "Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."] : f2 = ["Prisma Client was configured to use both the `adapter` and Accelerate, please chose one."] : f2 = ["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.", "Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."], new W2(f2.join(`
`), { clientVersion: t2.clientVersion });
      }
      if (o2)
        return new ft(t2);
      if (i2)
        return new Kt(t2);
      {
        let f2 = [`PrismaClient failed to initialize because it wasn't configured to run in this environment (${Pe().prettyName}).`, "In order to run Prisma Client in an edge runtime, you will need to configure one of the following options:", "- Enable Driver Adapters: https://pris.ly/d/driver-adapters", "- Enable Accelerate: https://pris.ly/d/accelerate"];
        throw new W2(f2.join(`
`), { clientVersion: t2.clientVersion });
      }
      throw new W2("Invalid client engine type, please use `library` or `binary`", { clientVersion: t2.clientVersion });
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function Ht({ generator: e2 }) {
      return e2?.previewFeatures ?? [];
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Vi = _e(Ur());
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function Ui(e2, t2) {
      let r2 = $i(e2), n2 = ta(r2), i2 = na(n2);
      i2 ? zt(i2, t2) : t2.addErrorMessage(() => "Unknown error");
    }
    function $i(e2) {
      return e2.errors.flatMap((t2) => t2.kind === "Union" ? $i(t2) : [t2]);
    }
    function ta(e2) {
      let t2 = /* @__PURE__ */ new Map(), r2 = [];
      for (let n2 of e2) {
        if (n2.kind !== "InvalidArgumentType") {
          r2.push(n2);
          continue;
        }
        let i2 = `${n2.selectionPath.join(".")}:${n2.argumentPath.join(".")}`, o2 = t2.get(i2);
        o2 ? t2.set(i2, { ...n2, argument: { ...n2.argument, typeNames: ra(o2.argument.typeNames, n2.argument.typeNames) } }) : t2.set(i2, n2);
      }
      return r2.push(...t2.values()), r2;
    }
    function ra(e2, t2) {
      return [...new Set(e2.concat(t2))];
    }
    function na(e2) {
      return Cr(e2, (t2, r2) => {
        let n2 = Ni(t2), i2 = Ni(r2);
        return n2 !== i2 ? n2 - i2 : Bi(t2) - Bi(r2);
      });
    }
    function Ni(e2) {
      let t2 = 0;
      return Array.isArray(e2.selectionPath) && (t2 += e2.selectionPath.length), Array.isArray(e2.argumentPath) && (t2 += e2.argumentPath.length), t2;
    }
    function Bi(e2) {
      switch (e2.kind) {
        case "InvalidArgumentValue":
        case "ValueTooLarge":
          return 20;
        case "InvalidArgumentType":
          return 10;
        case "RequiredArgumentMissing":
          return -10;
        default:
          return 0;
      }
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var re = class {
      constructor(t2, r2) {
        this.name = t2;
        this.value = r2;
        this.isRequired = false;
      }
      makeRequired() {
        return this.isRequired = true, this;
      }
      write(t2) {
        let { colors: { green: r2 } } = t2.context;
        t2.addMarginSymbol(r2(this.isRequired ? "+" : "?")), t2.write(r2(this.name)), this.isRequired || t2.write(r2("?")), t2.write(r2(": ")), typeof this.value == "string" ? t2.write(r2(this.value)) : t2.write(this.value);
      }
    };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Yt = class {
      constructor() {
        this.fields = [];
      }
      addField(t2, r2) {
        return this.fields.push({ write(n2) {
          let { green: i2, dim: o2 } = n2.context.colors;
          n2.write(i2(o2(`${t2}: ${r2}`))).addMarginSymbol(i2(o2("+")));
        } }), this;
      }
      write(t2) {
        let { colors: { green: r2 } } = t2.context;
        t2.writeLine(r2("{")).withIndent(() => {
          t2.writeJoined(Je, this.fields).newLine();
        }).write(r2("}")).addMarginSymbol(r2("+"));
      }
    };
    function zt(e2, t2) {
      switch (e2.kind) {
        case "MutuallyExclusiveFields":
          ia(e2, t2);
          break;
        case "IncludeOnScalar":
          oa(e2, t2);
          break;
        case "EmptySelection":
          sa(e2, t2);
          break;
        case "UnknownSelectionField":
          ua(e2, t2);
          break;
        case "UnknownArgument":
          ca2(e2, t2);
          break;
        case "UnknownInputField":
          ma(e2, t2);
          break;
        case "RequiredArgumentMissing":
          pa(e2, t2);
          break;
        case "InvalidArgumentType":
          da(e2, t2);
          break;
        case "InvalidArgumentValue":
          fa(e2, t2);
          break;
        case "ValueTooLarge":
          ga(e2, t2);
          break;
        case "SomeFieldsMissing":
          ha(e2, t2);
          break;
        case "TooManyFieldsGiven":
          ya(e2, t2);
          break;
        case "Union":
          Ui(e2, t2);
          break;
        default:
          throw new Error("not implemented: " + e2.kind);
      }
    }
    function ia(e2, t2) {
      let r2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath)?.asObject();
      r2 && (r2.getField(e2.firstField)?.markAsError(), r2.getField(e2.secondField)?.markAsError()), t2.addErrorMessage((n2) => `Please ${n2.bold("either")} use ${n2.green(`\`${e2.firstField}\``)} or ${n2.green(`\`${e2.secondField}\``)}, but ${n2.red("not both")} at the same time.`);
    }
    function oa(e2, t2) {
      let [r2, n2] = Xt(e2.selectionPath), i2 = e2.outputType, o2 = t2.arguments.getDeepSelectionParent(r2)?.value;
      if (o2 && (o2.getField(n2)?.markAsError(), i2))
        for (let s2 of i2.fields)
          s2.isRelation && o2.addSuggestion(new re(s2.name, "true"));
      t2.addErrorMessage((s2) => {
        let a2 = `Invalid scalar field ${s2.red(`\`${n2}\``)} for ${s2.bold("include")} statement`;
        return i2 ? a2 += ` on model ${s2.bold(i2.name)}. ${ht(s2)}` : a2 += ".", a2 += `
Note that ${s2.bold("include")} statements only accept relation fields.`, a2;
      });
    }
    function sa(e2, t2) {
      let r2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath)?.asObject();
      if (r2) {
        let n2 = r2.getField("omit")?.value.asObject();
        if (n2) {
          aa2(e2, t2, n2);
          return;
        }
      }
      la(e2, t2);
    }
    function aa2(e2, t2, r2) {
      r2.removeAllFields();
      for (let n2 of e2.outputType.fields)
        r2.addSuggestion(new re(n2.name, "false"));
      t2.addErrorMessage((n2) => `The ${n2.red("omit")} statement includes every field of the model ${n2.bold(e2.outputType.name)}. At least one field must be included in the result`);
    }
    function la(e2, t2) {
      let r2 = e2.outputType, n2 = t2.arguments.getDeepSelectionParent(e2.selectionPath)?.value, i2 = n2?.isEmpty() ?? false;
      n2 && (n2.removeAllFields(), Qi(n2, r2)), t2.addErrorMessage((o2) => i2 ? `The ${o2.red("`select`")} statement for type ${o2.bold(r2.name)} must not be empty. ${ht(o2)}` : `The ${o2.red("`select`")} statement for type ${o2.bold(r2.name)} needs ${o2.bold("at least one truthy value")}.`);
    }
    function ua(e2, t2) {
      let [r2, n2] = Xt(e2.selectionPath), i2 = t2.arguments.getDeepSubSelectionValue(r2)?.asObject(), o2;
      if (i2) {
        let s2 = i2.getFieldValue("select")?.asObject(), a2 = i2.getFieldValue("include")?.asObject(), f2 = i2.getFieldValue("omit")?.asObject();
        s2?.hasField(n2) ? (o2 = "select", s2.getField(n2)?.markAsError(), Qi(s2, e2.outputType)) : a2?.hasField(n2) ? (o2 = "include", a2.getField(n2)?.markAsError(), ba2(a2, e2.outputType)) : f2?.hasField(n2) && (o2 = "omit", f2.getField(n2)?.markAsError(), wa(f2, e2.outputType));
      }
      t2.addErrorMessage((s2) => {
        let a2 = [`Unknown field ${s2.red(`\`${n2}\``)}`];
        return o2 && a2.push(`for ${s2.bold(o2)} statement`), a2.push(`on model ${s2.bold(`\`${e2.outputType.name}\``)}.`), a2.push(ht(s2)), a2.join(" ");
      });
    }
    function ca2(e2, t2) {
      let r2 = e2.argumentPath[0], n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath)?.asObject();
      n2 && (n2.getField(r2)?.markAsError(), Ea(n2, e2.arguments)), t2.addErrorMessage((i2) => qi(i2, r2, e2.arguments.map((o2) => o2.name)));
    }
    function ma(e2, t2) {
      let [r2, n2] = Xt(e2.argumentPath), i2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath)?.asObject();
      if (i2) {
        i2.getDeepField(e2.argumentPath)?.markAsError();
        let o2 = i2.getDeepFieldValue(r2)?.asObject();
        o2 && Ji(o2, e2.inputType);
      }
      t2.addErrorMessage((o2) => qi(o2, n2, e2.inputType.fields.map((s2) => s2.name)));
    }
    function qi(e2, t2, r2) {
      let n2 = [`Unknown argument \`${e2.red(t2)}\`.`], i2 = Pa(t2, r2);
      return i2 && n2.push(`Did you mean \`${e2.green(i2)}\`?`), r2.length > 0 && n2.push(ht(e2)), n2.join(" ");
    }
    function pa(e2, t2) {
      let r2;
      t2.addErrorMessage((f2) => r2?.value instanceof G2 && r2.value.text === "null" ? `Argument \`${f2.green(o2)}\` must not be ${f2.red("null")}.` : `Argument \`${f2.green(o2)}\` is missing.`);
      let n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath)?.asObject();
      if (!n2)
        return;
      let [i2, o2] = Xt(e2.argumentPath), s2 = new Yt(), a2 = n2.getDeepFieldValue(i2)?.asObject();
      if (a2)
        if (r2 = a2.getField(o2), r2 && a2.removeField(o2), e2.inputTypes.length === 1 && e2.inputTypes[0].kind === "object") {
          for (let f2 of e2.inputTypes[0].fields)
            s2.addField(f2.name, f2.typeNames.join(" | "));
          a2.addSuggestion(new re(o2, s2).makeRequired());
        } else {
          let f2 = e2.inputTypes.map(ji).join(" | ");
          a2.addSuggestion(new re(o2, f2).makeRequired());
        }
    }
    function ji(e2) {
      return e2.kind === "list" ? `${ji(e2.elementType)}[]` : e2.name;
    }
    function da(e2, t2) {
      let r2 = e2.argument.name, n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath)?.asObject();
      n2 && n2.getDeepFieldValue(e2.argumentPath)?.markAsError(), t2.addErrorMessage((i2) => {
        let o2 = Zt("or", e2.argument.typeNames.map((s2) => i2.green(s2)));
        return `Argument \`${i2.bold(r2)}\`: Invalid value provided. Expected ${o2}, provided ${i2.red(e2.inferredType)}.`;
      });
    }
    function fa(e2, t2) {
      let r2 = e2.argument.name, n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath)?.asObject();
      n2 && n2.getDeepFieldValue(e2.argumentPath)?.markAsError(), t2.addErrorMessage((i2) => {
        let o2 = [`Invalid value for argument \`${i2.bold(r2)}\``];
        if (e2.underlyingError && o2.push(`: ${e2.underlyingError}`), o2.push("."), e2.argument.typeNames.length > 0) {
          let s2 = Zt("or", e2.argument.typeNames.map((a2) => i2.green(a2)));
          o2.push(` Expected ${s2}.`);
        }
        return o2.join("");
      });
    }
    function ga(e2, t2) {
      let r2 = e2.argument.name, n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath)?.asObject(), i2;
      if (n2) {
        let s2 = n2.getDeepField(e2.argumentPath)?.value;
        s2?.markAsError(), s2 instanceof G2 && (i2 = s2.text);
      }
      t2.addErrorMessage((o2) => {
        let s2 = ["Unable to fit value"];
        return i2 && s2.push(o2.red(i2)), s2.push(`into a 64-bit signed integer for field \`${o2.bold(r2)}\``), s2.join(" ");
      });
    }
    function ha(e2, t2) {
      let r2 = e2.argumentPath[e2.argumentPath.length - 1], n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath)?.asObject();
      if (n2) {
        let i2 = n2.getDeepFieldValue(e2.argumentPath)?.asObject();
        i2 && Ji(i2, e2.inputType);
      }
      t2.addErrorMessage((i2) => {
        let o2 = [`Argument \`${i2.bold(r2)}\` of type ${i2.bold(e2.inputType.name)} needs`];
        return e2.constraints.minFieldCount === 1 ? e2.constraints.requiredFields ? o2.push(`${i2.green("at least one of")} ${Zt("or", e2.constraints.requiredFields.map((s2) => `\`${i2.bold(s2)}\``))} arguments.`) : o2.push(`${i2.green("at least one")} argument.`) : o2.push(`${i2.green(`at least ${e2.constraints.minFieldCount}`)} arguments.`), o2.push(ht(i2)), o2.join(" ");
      });
    }
    function ya(e2, t2) {
      let r2 = e2.argumentPath[e2.argumentPath.length - 1], n2 = t2.arguments.getDeepSubSelectionValue(e2.selectionPath)?.asObject(), i2 = [];
      if (n2) {
        let o2 = n2.getDeepFieldValue(e2.argumentPath)?.asObject();
        o2 && (o2.markAsError(), i2 = Object.keys(o2.getFields()));
      }
      t2.addErrorMessage((o2) => {
        let s2 = [`Argument \`${o2.bold(r2)}\` of type ${o2.bold(e2.inputType.name)} needs`];
        return e2.constraints.minFieldCount === 1 && e2.constraints.maxFieldCount == 1 ? s2.push(`${o2.green("exactly one")} argument,`) : e2.constraints.maxFieldCount == 1 ? s2.push(`${o2.green("at most one")} argument,`) : s2.push(`${o2.green(`at most ${e2.constraints.maxFieldCount}`)} arguments,`), s2.push(`but you provided ${Zt("and", i2.map((a2) => o2.red(a2)))}. Please choose`), e2.constraints.maxFieldCount === 1 ? s2.push("one.") : s2.push(`${e2.constraints.maxFieldCount}.`), s2.join(" ");
      });
    }
    function Qi(e2, t2) {
      for (let r2 of t2.fields)
        e2.hasField(r2.name) || e2.addSuggestion(new re(r2.name, "true"));
    }
    function ba2(e2, t2) {
      for (let r2 of t2.fields)
        r2.isRelation && !e2.hasField(r2.name) && e2.addSuggestion(new re(r2.name, "true"));
    }
    function wa(e2, t2) {
      for (let r2 of t2.fields)
        !e2.hasField(r2.name) && !r2.isRelation && e2.addSuggestion(new re(r2.name, "true"));
    }
    function Ea(e2, t2) {
      for (let r2 of t2)
        e2.hasField(r2.name) || e2.addSuggestion(new re(r2.name, r2.typeNames.join(" | ")));
    }
    function Ji(e2, t2) {
      if (t2.kind === "object")
        for (let r2 of t2.fields)
          e2.hasField(r2.name) || e2.addSuggestion(new re(r2.name, r2.typeNames.join(" | ")));
    }
    function Xt(e2) {
      let t2 = [...e2], r2 = t2.pop();
      if (!r2)
        throw new Error("unexpected empty path");
      return [t2, r2];
    }
    function ht({ green: e2, enabled: t2 }) {
      return "Available options are " + (t2 ? `listed in ${e2("green")}` : "marked with ?") + ".";
    }
    function Zt(e2, t2) {
      if (t2.length === 1)
        return t2[0];
      let r2 = [...t2], n2 = r2.pop();
      return `${r2.join(", ")} ${e2} ${n2}`;
    }
    var xa = 3;
    function Pa(e2, t2) {
      let r2 = 1 / 0, n2;
      for (let i2 of t2) {
        let o2 = (0, Vi.default)(e2, i2);
        o2 > xa || o2 < r2 && (r2 = o2, n2 = i2);
      }
      return n2;
    }
    function er({ args: e2, errors: t2, errorFormat: r2, callsite: n2, originalMethod: i2, clientVersion: o2 }) {
      let s2 = Vt(e2);
      for (let T2 of t2)
        zt(T2, s2);
      let a2 = r2 === "pretty" ? zn : Bt, f2 = s2.renderAllMessages(a2), v2 = new Ve(0, { colors: a2 }).write(s2).toString(), C2 = Ke({ message: f2, callsite: n2, originalMethod: i2, showColors: r2 === "pretty", callArguments: v2 });
      throw new W2(C2, { clientVersion: o2 });
    }
    var va = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", createManyAndReturn: "createManyAndReturn", update: "updateOne", updateMany: "updateMany", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
    function Wi({ modelName: e2, action: t2, args: r2, runtimeDataModel: n2, extensions: i2, callsite: o2, clientMethod: s2, errorFormat: a2, clientVersion: f2, previewFeatures: v2 }) {
      let C2 = new $r({ runtimeDataModel: n2, modelName: e2, action: t2, rootArgs: r2, callsite: o2, extensions: i2, selectionPath: [], argumentPath: [], originalMethod: s2, errorFormat: a2, clientVersion: f2, previewFeatures: v2 });
      return { modelName: e2, action: va[t2], query: Vr(r2, C2) };
    }
    function Vr({ select: e2, include: t2, ...r2 } = {}, n2) {
      let i2;
      return n2.isPreviewFeatureOn("omitApi") && (i2 = r2.omit, delete r2.omit), { arguments: Ki(r2, n2), selection: Ca(e2, t2, i2, n2) };
    }
    function Ca(e2, t2, r2, n2) {
      return e2 ? (t2 ? n2.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "include", secondField: "select", selectionPath: n2.getSelectionPath() }) : r2 && n2.isPreviewFeatureOn("omitApi") && n2.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "omit", secondField: "select", selectionPath: n2.getSelectionPath() }), Sa(e2, n2)) : Ta(n2, t2, r2);
    }
    function Ta(e2, t2, r2) {
      let n2 = {};
      return e2.model && !e2.isRawAction() && (n2.$composites = true, n2.$scalars = true), t2 && Aa(n2, t2, e2), r2 && e2.isPreviewFeatureOn("omitApi") && Ra(n2, r2, e2), n2;
    }
    function Aa(e2, t2, r2) {
      for (let [n2, i2] of Object.entries(t2)) {
        let o2 = r2.findField(n2);
        o2 && o2?.kind !== "object" && r2.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r2.getSelectionPath().concat(n2), outputType: r2.getOutputTypeDescription() }), i2 === true ? e2[n2] = true : typeof i2 == "object" && (e2[n2] = Vr(i2, r2.nestSelection(n2)));
      }
    }
    function Ra(e2, t2, r2) {
      let n2 = r2.getComputedFields(), i2 = Ai(t2, n2);
      for (let [o2, s2] of Object.entries(i2)) {
        let a2 = r2.findField(o2);
        n2?.[o2] && !a2 || (e2[o2] = !s2);
      }
    }
    function Sa(e2, t2) {
      let r2 = {}, n2 = t2.getComputedFields(), i2 = Ti(e2, n2);
      for (let [o2, s2] of Object.entries(i2)) {
        let a2 = t2.findField(o2);
        n2?.[o2] && !a2 || (s2 === true ? r2[o2] = true : typeof s2 == "object" && (r2[o2] = Vr(s2, t2.nestSelection(o2))));
      }
      return r2;
    }
    function Gi(e2, t2) {
      if (e2 === null)
        return null;
      if (typeof e2 == "string" || typeof e2 == "number" || typeof e2 == "boolean")
        return e2;
      if (typeof e2 == "bigint")
        return { $type: "BigInt", value: String(e2) };
      if (qe(e2)) {
        if (Dt(e2))
          return { $type: "DateTime", value: e2.toISOString() };
        t2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t2.getSelectionPath(), argumentPath: t2.getArgumentPath(), argument: { name: t2.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
      }
      if (Qe(e2))
        return { $type: "FieldRef", value: { _ref: e2.name, _container: e2.modelName } };
      if (Array.isArray(e2))
        return Oa(e2, t2);
      if (ArrayBuffer.isView(e2))
        return { $type: "Bytes", value: y2.from(e2).toString("base64") };
      if (ka(e2))
        return e2.values;
      if (je(e2))
        return { $type: "Decimal", value: e2.toFixed() };
      if (e2 instanceof be2) {
        if (e2 !== Lt.instances[e2._getName()])
          throw new Error("Invalid ObjectEnumValue");
        return { $type: "Enum", value: e2._getName() };
      }
      if (La(e2))
        return e2.toJSON();
      if (typeof e2 == "object")
        return Ki(e2, t2);
      t2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t2.getSelectionPath(), argumentPath: t2.getArgumentPath(), argument: { name: t2.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e2)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
    }
    function Ki(e2, t2) {
      if (e2.$type)
        return { $type: "Raw", value: e2 };
      let r2 = {};
      for (let n2 in e2) {
        let i2 = e2[n2];
        i2 !== void 0 && (r2[n2] = Gi(i2, t2.nestArgument(n2)));
      }
      return r2;
    }
    function Oa(e2, t2) {
      let r2 = [];
      for (let n2 = 0; n2 < e2.length; n2++) {
        let i2 = t2.nestArgument(String(n2)), o2 = e2[n2];
        o2 === void 0 && t2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i2.getSelectionPath(), argumentPath: i2.getArgumentPath(), argument: { name: `${t2.getArgumentName()}[${n2}]`, typeNames: [] }, underlyingError: "Can not use `undefined` value within array. Use `null` or filter out `undefined` values" }), r2.push(Gi(o2, i2));
      }
      return r2;
    }
    function ka(e2) {
      return typeof e2 == "object" && e2 !== null && e2.__prismaRawParameters__ === true;
    }
    function La(e2) {
      return typeof e2 == "object" && e2 !== null && typeof e2.toJSON == "function";
    }
    var $r = class e2 {
      constructor(t2) {
        this.params = t2;
        this.params.modelName && (this.model = this.params.runtimeDataModel.models[this.params.modelName]);
      }
      throwValidationError(t2) {
        er({ errors: [t2], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion });
      }
      getSelectionPath() {
        return this.params.selectionPath;
      }
      getArgumentPath() {
        return this.params.argumentPath;
      }
      getArgumentName() {
        return this.params.argumentPath[this.params.argumentPath.length - 1];
      }
      getOutputTypeDescription() {
        if (!(!this.params.modelName || !this.model))
          return { name: this.params.modelName, fields: this.model.fields.map((t2) => ({ name: t2.name, typeName: "boolean", isRelation: t2.kind === "object" })) };
      }
      isRawAction() {
        return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
      }
      isPreviewFeatureOn(t2) {
        return this.params.previewFeatures.includes(t2);
      }
      getComputedFields() {
        if (this.params.modelName)
          return this.params.extensions.getAllComputedFields(this.params.modelName);
      }
      findField(t2) {
        return this.model?.fields.find((r2) => r2.name === t2);
      }
      nestSelection(t2) {
        let r2 = this.findField(t2), n2 = r2?.kind === "object" ? r2.type : void 0;
        return new e2({ ...this.params, modelName: n2, selectionPath: this.params.selectionPath.concat(t2) });
      }
      nestArgument(t2) {
        return new e2({ ...this.params, argumentPath: this.params.argumentPath.concat(t2) });
      }
    };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Hi = (e2) => ({ command: e2 });
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var zi = (e2) => e2.strings.reduce((t2, r2, n2) => `${t2}@P${n2}${r2}`);
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    l2();
    function yt(e2) {
      try {
        return Yi(e2, "fast");
      } catch {
        return Yi(e2, "slow");
      }
    }
    function Yi(e2, t2) {
      return JSON.stringify(e2.map((r2) => Ma(r2, t2)));
    }
    function Ma(e2, t2) {
      return typeof e2 == "bigint" ? { prisma__type: "bigint", prisma__value: e2.toString() } : qe(e2) ? { prisma__type: "date", prisma__value: e2.toJSON() } : ue.isDecimal(e2) ? { prisma__type: "decimal", prisma__value: e2.toJSON() } : y2.isBuffer(e2) ? { prisma__type: "bytes", prisma__value: e2.toString("base64") } : Ia(e2) || ArrayBuffer.isView(e2) ? { prisma__type: "bytes", prisma__value: y2.from(e2).toString("base64") } : typeof e2 == "object" && t2 === "slow" ? Zi(e2) : e2;
    }
    function Ia(e2) {
      return e2 instanceof ArrayBuffer || e2 instanceof SharedArrayBuffer ? true : typeof e2 == "object" && e2 !== null ? e2[Symbol.toStringTag] === "ArrayBuffer" || e2[Symbol.toStringTag] === "SharedArrayBuffer" : false;
    }
    function Zi(e2) {
      if (typeof e2 != "object" || e2 === null)
        return e2;
      if (typeof e2.toJSON == "function")
        return e2.toJSON();
      if (Array.isArray(e2))
        return e2.map(Xi);
      let t2 = {};
      for (let r2 of Object.keys(e2))
        t2[r2] = Xi(e2[r2]);
      return t2;
    }
    function Xi(e2) {
      return typeof e2 == "bigint" ? e2.toString() : Zi(e2);
    }
    var _a2 = /^(\s*alter\s)/i;
    var eo = ee("prisma:client");
    function qr(e2, t2, r2, n2) {
      if (!(e2 !== "postgresql" && e2 !== "cockroachdb") && r2.length > 0 && _a2.exec(t2))
        throw new Error(`Running ALTER using ${n2} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
    }
    var jr = ({ clientMethod: e2, activeProvider: t2 }) => (r2) => {
      let n2 = "", i2;
      if (Array.isArray(r2)) {
        let [o2, ...s2] = r2;
        n2 = o2, i2 = { values: yt(s2 || []), __prismaRawParameters__: true };
      } else
        switch (t2) {
          case "sqlite":
          case "mysql": {
            n2 = r2.sql, i2 = { values: yt(r2.values), __prismaRawParameters__: true };
            break;
          }
          case "cockroachdb":
          case "postgresql":
          case "postgres": {
            n2 = r2.text, i2 = { values: yt(r2.values), __prismaRawParameters__: true };
            break;
          }
          case "sqlserver": {
            n2 = zi(r2), i2 = { values: yt(r2.values), __prismaRawParameters__: true };
            break;
          }
          default:
            throw new Error(`The ${t2} provider does not support ${e2}`);
        }
      return i2?.values ? eo(`prisma.${e2}(${n2}, ${i2.values})`) : eo(`prisma.${e2}(${n2})`), { query: n2, parameters: i2 };
    };
    var to = { requestArgsToMiddlewareArgs(e2) {
      return [e2.strings, ...e2.values];
    }, middlewareArgsToRequestArgs(e2) {
      let [t2, ...r2] = e2;
      return new X2(t2, r2);
    } };
    var ro = { requestArgsToMiddlewareArgs(e2) {
      return [e2];
    }, middlewareArgsToRequestArgs(e2) {
      return e2[0];
    } };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function Qr(e2) {
      return function(r2) {
        let n2, i2 = (o2 = e2) => {
          try {
            return o2 === void 0 || o2?.kind === "itx" ? n2 ??= no(r2(o2)) : no(r2(o2));
          } catch (s2) {
            return Promise.reject(s2);
          }
        };
        return { then(o2, s2) {
          return i2().then(o2, s2);
        }, catch(o2) {
          return i2().catch(o2);
        }, finally(o2) {
          return i2().finally(o2);
        }, requestTransaction(o2) {
          let s2 = i2(o2);
          return s2.requestTransaction ? s2.requestTransaction(o2) : s2;
        }, [Symbol.toStringTag]: "PrismaPromise" };
      };
    }
    function no(e2) {
      return typeof e2.then == "function" ? e2 : Promise.resolve(e2);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var io = { isEnabled() {
      return false;
    }, getTraceParent() {
      return "00-10-10-00";
    }, async createEngineSpan() {
    }, getActiveContext() {
    }, runInChildSpan(e2, t2) {
      return t2();
    } };
    var Jr = class {
      isEnabled() {
        return this.getGlobalTracingHelper().isEnabled();
      }
      getTraceParent(t2) {
        return this.getGlobalTracingHelper().getTraceParent(t2);
      }
      createEngineSpan(t2) {
        return this.getGlobalTracingHelper().createEngineSpan(t2);
      }
      getActiveContext() {
        return this.getGlobalTracingHelper().getActiveContext();
      }
      runInChildSpan(t2, r2) {
        return this.getGlobalTracingHelper().runInChildSpan(t2, r2);
      }
      getGlobalTracingHelper() {
        return globalThis.PRISMA_INSTRUMENTATION?.helper ?? io;
      }
    };
    function oo(e2) {
      return e2.includes("tracing") ? new Jr() : io;
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function so(e2, t2 = () => {
    }) {
      let r2, n2 = new Promise((i2) => r2 = i2);
      return { then(i2) {
        return --e2 === 0 && r2(t2()), i2?.(n2);
      } };
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Da = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
    var ao2 = Da;
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function lo(e2) {
      return typeof e2 == "string" ? e2 : e2.reduce((t2, r2) => {
        let n2 = typeof r2 == "string" ? r2 : r2.level;
        return n2 === "query" ? t2 : t2 && (r2 === "info" || t2 === "info") ? "info" : n2;
      }, void 0);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var tr = class {
      constructor() {
        this._middlewares = [];
      }
      use(t2) {
        this._middlewares.push(t2);
      }
      get(t2) {
        return this._middlewares[t2];
      }
      has(t2) {
        return !!this._middlewares[t2];
      }
      length() {
        return this._middlewares.length;
      }
    };
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var co2 = _e(Un());
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function rr(e2) {
      return typeof e2.batchRequestIdx == "number";
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    l2();
    function nr(e2) {
      return e2 === null ? e2 : Array.isArray(e2) ? e2.map(nr) : typeof e2 == "object" ? Fa(e2) ? Na(e2) : Be(e2, nr) : e2;
    }
    function Fa(e2) {
      return e2 !== null && typeof e2 == "object" && typeof e2.$type == "string";
    }
    function Na({ $type: e2, value: t2 }) {
      switch (e2) {
        case "BigInt":
          return BigInt(t2);
        case "Bytes":
          return y2.from(t2, "base64");
        case "DateTime":
          return new Date(t2);
        case "Decimal":
          return new ue(t2);
        case "Json":
          return JSON.parse(t2);
        default:
          ke(t2, "Unknown tagged value");
      }
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function uo(e2) {
      if (e2.action !== "findUnique" && e2.action !== "findUniqueOrThrow")
        return;
      let t2 = [];
      return e2.modelName && t2.push(e2.modelName), e2.query.arguments && t2.push(Wr(e2.query.arguments)), t2.push(Wr(e2.query.selection)), t2.join("");
    }
    function Wr(e2) {
      return `(${Object.keys(e2).sort().map((r2) => {
        let n2 = e2[r2];
        return typeof n2 == "object" && n2 !== null ? `(${r2} ${Wr(n2)})` : r2;
      }).join(" ")})`;
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var Ba = { aggregate: false, aggregateRaw: false, createMany: true, createManyAndReturn: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateOne: true, upsertOne: true };
    function Gr(e2) {
      return Ba[e2];
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var ir = class {
      constructor(t2) {
        this.options = t2;
        this.tickActive = false;
        this.batches = {};
      }
      request(t2) {
        let r2 = this.options.batchBy(t2);
        return r2 ? (this.batches[r2] || (this.batches[r2] = [], this.tickActive || (this.tickActive = true, g2.nextTick(() => {
          this.dispatchBatches(), this.tickActive = false;
        }))), new Promise((n2, i2) => {
          this.batches[r2].push({ request: t2, resolve: n2, reject: i2 });
        })) : this.options.singleLoader(t2);
      }
      dispatchBatches() {
        for (let t2 in this.batches) {
          let r2 = this.batches[t2];
          delete this.batches[t2], r2.length === 1 ? this.options.singleLoader(r2[0].request).then((n2) => {
            n2 instanceof Error ? r2[0].reject(n2) : r2[0].resolve(n2);
          }).catch((n2) => {
            r2[0].reject(n2);
          }) : (r2.sort((n2, i2) => this.options.batchOrder(n2.request, i2.request)), this.options.batchLoader(r2.map((n2) => n2.request)).then((n2) => {
            if (n2 instanceof Error)
              for (let i2 = 0; i2 < r2.length; i2++)
                r2[i2].reject(n2);
            else
              for (let i2 = 0; i2 < r2.length; i2++) {
                let o2 = n2[i2];
                o2 instanceof Error ? r2[i2].reject(o2) : r2[i2].resolve(o2);
              }
          }).catch((n2) => {
            for (let i2 = 0; i2 < r2.length; i2++)
              r2[i2].reject(n2);
          }));
        }
      }
      get [Symbol.toStringTag]() {
        return "DataLoader";
      }
    };
    var Ua = ee("prisma:client:request_handler");
    var or = class {
      constructor(t2, r2) {
        this.logEmitter = r2, this.client = t2, this.dataloader = new ir({ batchLoader: Ei(async ({ requests: n2, customDataProxyFetch: i2 }) => {
          let { transaction: o2, otelParentCtx: s2 } = n2[0], a2 = n2.map((T2) => T2.protocolQuery), f2 = this.client._tracingHelper.getTraceParent(s2), v2 = n2.some((T2) => Gr(T2.protocolQuery.action));
          return (await this.client._engine.requestBatch(a2, { traceparent: f2, transaction: $a(o2), containsWrite: v2, customDataProxyFetch: i2 })).map((T2, O2) => {
            if (T2 instanceof Error)
              return T2;
            try {
              return this.mapQueryEngineResult(n2[O2], T2);
            } catch (R2) {
              return R2;
            }
          });
        }), singleLoader: async (n2) => {
          let i2 = n2.transaction?.kind === "itx" ? mo(n2.transaction) : void 0, o2 = await this.client._engine.request(n2.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i2, isWrite: Gr(n2.protocolQuery.action), customDataProxyFetch: n2.customDataProxyFetch });
          return this.mapQueryEngineResult(n2, o2);
        }, batchBy: (n2) => n2.transaction?.id ? `transaction-${n2.transaction.id}` : uo(n2.protocolQuery), batchOrder(n2, i2) {
          return n2.transaction?.kind === "batch" && i2.transaction?.kind === "batch" ? n2.transaction.index - i2.transaction.index : 0;
        } });
      }
      async request(t2) {
        try {
          return await this.dataloader.request(t2);
        } catch (r2) {
          let { clientMethod: n2, callsite: i2, transaction: o2, args: s2, modelName: a2 } = t2;
          this.handleAndLogRequestError({ error: r2, clientMethod: n2, callsite: i2, transaction: o2, args: s2, modelName: a2 });
        }
      }
      mapQueryEngineResult({ dataPath: t2, unpacker: r2 }, n2) {
        let i2 = n2?.data, o2 = n2?.elapsed, s2 = this.unpack(i2, t2, r2);
        return g2.env.PRISMA_CLIENT_GET_TIME ? { data: s2, elapsed: o2 } : s2;
      }
      handleAndLogRequestError(t2) {
        try {
          this.handleRequestError(t2);
        } catch (r2) {
          throw this.logEmitter && this.logEmitter.emit("error", { message: r2.message, target: t2.clientMethod, timestamp: /* @__PURE__ */ new Date() }), r2;
        }
      }
      handleRequestError({ error: t2, clientMethod: r2, callsite: n2, transaction: i2, args: o2, modelName: s2 }) {
        if (Ua(t2), Va(t2, i2) || t2 instanceof he)
          throw t2;
        if (t2 instanceof Q2 && qa(t2)) {
          let f2 = po(t2.meta);
          er({ args: o2, errors: [f2], callsite: n2, errorFormat: this.client._errorFormat, originalMethod: r2, clientVersion: this.client._clientVersion });
        }
        let a2 = t2.message;
        if (n2 && (a2 = Ke({ callsite: n2, originalMethod: r2, isPanic: t2.isPanic, showColors: this.client._errorFormat === "pretty", message: a2 })), a2 = this.sanitizeMessage(a2), t2.code) {
          let f2 = s2 ? { modelName: s2, ...t2.meta } : t2.meta;
          throw new Q2(a2, { code: t2.code, clientVersion: this.client._clientVersion, meta: f2, batchRequestIdx: t2.batchRequestIdx });
        } else {
          if (t2.isPanic)
            throw new ye(a2, this.client._clientVersion);
          if (t2 instanceof J2)
            throw new J2(a2, { clientVersion: this.client._clientVersion, batchRequestIdx: t2.batchRequestIdx });
          if (t2 instanceof I2)
            throw new I2(a2, this.client._clientVersion);
          if (t2 instanceof ye)
            throw new ye(a2, this.client._clientVersion);
        }
        throw t2.clientVersion = this.client._clientVersion, t2;
      }
      sanitizeMessage(t2) {
        return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, co2.default)(t2) : t2;
      }
      unpack(t2, r2, n2) {
        if (!t2 || (t2.data && (t2 = t2.data), !t2))
          return t2;
        let i2 = Object.values(t2)[0], o2 = r2.filter((a2) => a2 !== "select" && a2 !== "include"), s2 = nr(_r(i2, o2));
        return n2 ? n2(s2) : s2;
      }
      get [Symbol.toStringTag]() {
        return "RequestHandler";
      }
    };
    function $a(e2) {
      if (e2) {
        if (e2.kind === "batch")
          return { kind: "batch", options: { isolationLevel: e2.isolationLevel } };
        if (e2.kind === "itx")
          return { kind: "itx", options: mo(e2) };
        ke(e2, "Unknown transaction kind");
      }
    }
    function mo(e2) {
      return { id: e2.id, payload: e2.payload };
    }
    function Va(e2, t2) {
      return rr(e2) && t2?.kind === "batch" && e2.batchRequestIdx !== t2.index;
    }
    function qa(e2) {
      return e2.code === "P2009" || e2.code === "P2012";
    }
    function po(e2) {
      if (e2.kind === "Union")
        return { kind: "Union", errors: e2.errors.map(po) };
      if (Array.isArray(e2.selectionPath)) {
        let [, ...t2] = e2.selectionPath;
        return { ...e2, selectionPath: t2 };
      }
      return e2;
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var fo = "5.14.0";
    var go = fo;
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    l2();
    function ho(e2) {
      return e2.map((t2) => {
        let r2 = {};
        for (let n2 of Object.keys(t2))
          r2[n2] = yo(t2[n2]);
        return r2;
      });
    }
    function yo({ prisma__type: e2, prisma__value: t2 }) {
      switch (e2) {
        case "bigint":
          return BigInt(t2);
        case "bytes":
          return y2.from(t2, "base64");
        case "decimal":
          return new ue(t2);
        case "datetime":
        case "date":
          return new Date(t2);
        case "time":
          return /* @__PURE__ */ new Date(`1970-01-01T${t2}Z`);
        case "array":
          return t2.map(yo);
        default:
          return t2;
      }
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var xo = _e(Ur());
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var N2 = class extends Error {
      constructor(t2) {
        super(t2 + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientConstructorValidationError";
      }
    };
    K2(N2, "PrismaClientConstructorValidationError");
    var bo2 = ["datasources", "datasourceUrl", "errorFormat", "adapter", "log", "transactionOptions", "__internal"];
    var wo = ["pretty", "colorless", "minimal"];
    var Eo = ["info", "query", "warn", "error"];
    var Qa = { datasources: (e2, { datasourceNames: t2 }) => {
      if (e2) {
        if (typeof e2 != "object" || Array.isArray(e2))
          throw new N2(`Invalid value ${JSON.stringify(e2)} for "datasources" provided to PrismaClient constructor`);
        for (let [r2, n2] of Object.entries(e2)) {
          if (!t2.includes(r2)) {
            let i2 = He(r2, t2) || ` Available datasources: ${t2.join(", ")}`;
            throw new N2(`Unknown datasource ${r2} provided to PrismaClient constructor.${i2}`);
          }
          if (typeof n2 != "object" || Array.isArray(n2))
            throw new N2(`Invalid value ${JSON.stringify(e2)} for datasource "${r2}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          if (n2 && typeof n2 == "object")
            for (let [i2, o2] of Object.entries(n2)) {
              if (i2 !== "url")
                throw new N2(`Invalid value ${JSON.stringify(e2)} for datasource "${r2}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
              if (typeof o2 != "string")
                throw new N2(`Invalid value ${JSON.stringify(o2)} for datasource "${r2}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            }
        }
      }
    }, adapter: (e2, t2) => {
      if (e2 === null)
        return;
      if (e2 === void 0)
        throw new N2('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');
      if (!Ht(t2).includes("driverAdapters"))
        throw new N2('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');
      if (et() === "binary")
        throw new N2('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.');
    }, datasourceUrl: (e2) => {
      if (typeof e2 < "u" && typeof e2 != "string")
        throw new N2(`Invalid value ${JSON.stringify(e2)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
    }, errorFormat: (e2) => {
      if (e2) {
        if (typeof e2 != "string")
          throw new N2(`Invalid value ${JSON.stringify(e2)} for "errorFormat" provided to PrismaClient constructor.`);
        if (!wo.includes(e2)) {
          let t2 = He(e2, wo);
          throw new N2(`Invalid errorFormat ${e2} provided to PrismaClient constructor.${t2}`);
        }
      }
    }, log: (e2) => {
      if (!e2)
        return;
      if (!Array.isArray(e2))
        throw new N2(`Invalid value ${JSON.stringify(e2)} for "log" provided to PrismaClient constructor.`);
      function t2(r2) {
        if (typeof r2 == "string" && !Eo.includes(r2)) {
          let n2 = He(r2, Eo);
          throw new N2(`Invalid log level "${r2}" provided to PrismaClient constructor.${n2}`);
        }
      }
      for (let r2 of e2) {
        t2(r2);
        let n2 = { level: t2, emit: (i2) => {
          let o2 = ["stdout", "event"];
          if (!o2.includes(i2)) {
            let s2 = He(i2, o2);
            throw new N2(`Invalid value ${JSON.stringify(i2)} for "emit" in logLevel provided to PrismaClient constructor.${s2}`);
          }
        } };
        if (r2 && typeof r2 == "object")
          for (let [i2, o2] of Object.entries(r2))
            if (n2[i2])
              n2[i2](o2);
            else
              throw new N2(`Invalid property ${i2} for "log" provided to PrismaClient constructor`);
      }
    }, transactionOptions: (e2) => {
      if (!e2)
        return;
      let t2 = e2.maxWait;
      if (t2 != null && t2 <= 0)
        throw new N2(`Invalid value ${t2} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);
      let r2 = e2.timeout;
      if (r2 != null && r2 <= 0)
        throw new N2(`Invalid value ${r2} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`);
    }, __internal: (e2) => {
      if (!e2)
        return;
      let t2 = ["debug", "engine", "configOverride"];
      if (typeof e2 != "object")
        throw new N2(`Invalid value ${JSON.stringify(e2)} for "__internal" to PrismaClient constructor`);
      for (let [r2] of Object.entries(e2))
        if (!t2.includes(r2)) {
          let n2 = He(r2, t2);
          throw new N2(`Invalid property ${JSON.stringify(r2)} for "__internal" provided to PrismaClient constructor.${n2}`);
        }
    } };
    function Po(e2, t2) {
      for (let [r2, n2] of Object.entries(e2)) {
        if (!bo2.includes(r2)) {
          let i2 = He(r2, bo2);
          throw new N2(`Unknown property ${r2} provided to PrismaClient constructor.${i2}`);
        }
        Qa[r2](n2, t2);
      }
      if (e2.datasourceUrl && e2.datasources)
        throw new N2('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
    }
    function He(e2, t2) {
      if (t2.length === 0 || typeof e2 != "string")
        return "";
      let r2 = Ja(e2, t2);
      return r2 ? ` Did you mean "${r2}"?` : "";
    }
    function Ja(e2, t2) {
      if (t2.length === 0)
        return null;
      let r2 = t2.map((i2) => ({ value: i2, distance: (0, xo.default)(e2, i2) }));
      r2.sort((i2, o2) => i2.distance < o2.distance ? -1 : 1);
      let n2 = r2[0];
      return n2.distance < 3 ? n2.value : null;
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    function vo(e2) {
      return e2.length === 0 ? Promise.resolve([]) : new Promise((t2, r2) => {
        let n2 = new Array(e2.length), i2 = null, o2 = false, s2 = 0, a2 = () => {
          o2 || (s2++, s2 === e2.length && (o2 = true, i2 ? r2(i2) : t2(n2)));
        }, f2 = (v2) => {
          o2 || (o2 = true, r2(v2));
        };
        for (let v2 = 0; v2 < e2.length; v2++)
          e2[v2].then((C2) => {
            n2[v2] = C2, a2();
          }, (C2) => {
            if (!rr(C2)) {
              f2(C2);
              return;
            }
            C2.batchRequestIdx === v2 ? f2(C2) : (i2 || (i2 = C2), a2());
          });
      });
    }
    var ve = ee("prisma:client");
    typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
    var Wa = { requestArgsToMiddlewareArgs: (e2) => e2, middlewareArgsToRequestArgs: (e2) => e2 };
    var Ga = Symbol.for("prisma.client.transaction.id");
    var Ka = { id: 0, nextId() {
      return ++this.id;
    } };
    function Ao(e2) {
      class t2 {
        constructor(n2) {
          this._originalClient = this;
          this._middlewares = new tr();
          this._createPrismaPromise = Qr();
          this.$extends = pi;
          e2 = n2?.__internal?.configOverride?.(e2) ?? e2, Oi(e2), n2 && Po(n2, e2);
          let i2 = n2?.adapter ? Or(n2.adapter) : void 0, o2 = new St().on("error", () => {
          });
          this._extensions = Wt.empty(), this._previewFeatures = Ht(e2), this._clientVersion = e2.clientVersion ?? go, this._activeProvider = e2.activeProvider, this._tracingHelper = oo(this._previewFeatures);
          let s2 = { rootEnvPath: e2.relativeEnvPaths.rootEnvPath && Ze.resolve(e2.dirname, e2.relativeEnvPaths.rootEnvPath), schemaEnvPath: e2.relativeEnvPaths.schemaEnvPath && Ze.resolve(e2.dirname, e2.relativeEnvPaths.schemaEnvPath) }, a2 = e2.injectableEdgeEnv?.();
          try {
            let f2 = n2 ?? {}, v2 = f2.__internal ?? {}, C2 = v2.debug === true;
            C2 && ee.enable("prisma:client");
            let T2 = Ze.resolve(e2.dirname, e2.relativePath);
            un.existsSync(T2) || (T2 = e2.dirname), ve("dirname", e2.dirname), ve("relativePath", e2.relativePath), ve("cwd", T2);
            let O2 = v2.engine || {};
            if (f2.errorFormat ? this._errorFormat = f2.errorFormat : g2.env.NODE_ENV === "production" ? this._errorFormat = "minimal" : g2.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e2.runtimeDataModel, this._engineConfig = { cwd: T2, dirname: e2.dirname, enableDebugLogs: C2, allowTriggerPanic: O2.allowTriggerPanic, datamodelPath: Ze.join(e2.dirname, e2.filename ?? "schema.prisma"), prismaPath: O2.binaryPath ?? void 0, engineEndpoint: O2.endpoint, generator: e2.generator, showColors: this._errorFormat === "pretty", logLevel: f2.log && lo(f2.log), logQueries: f2.log && !!(typeof f2.log == "string" ? f2.log === "query" : f2.log.find((R2) => typeof R2 == "string" ? R2 === "query" : R2.level === "query")), env: a2?.parsed ?? {}, flags: [], engineWasm: e2.engineWasm, clientVersion: e2.clientVersion, engineVersion: e2.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e2.activeProvider, inlineSchema: e2.inlineSchema, overrideDatasources: ki(f2, e2.datasourceNames), inlineDatasources: e2.inlineDatasources, inlineSchemaHash: e2.inlineSchemaHash, tracingHelper: this._tracingHelper, transactionOptions: { maxWait: f2.transactionOptions?.maxWait ?? 2e3, timeout: f2.transactionOptions?.timeout ?? 5e3, isolationLevel: f2.transactionOptions?.isolationLevel }, logEmitter: o2, isBundled: e2.isBundled, adapter: i2 }, this._accelerateEngineConfig = { ...this._engineConfig, accelerateUtils: { resolveDatasourceUrl: Gt, getBatchRequestPayload: _t, prismaGraphQLToJSError: qt, PrismaClientUnknownRequestError: J2, PrismaClientInitializationError: I2, PrismaClientKnownRequestError: Q2, debug: ee("prisma:client:accelerateEngine"), engineVersion: To.version, clientVersion: e2.clientVersion } }, ve("clientVersion", e2.clientVersion), this._engine = Di(e2, this._engineConfig), this._requestHandler = new or(this, o2), f2.log)
              for (let R2 of f2.log) {
                let L2 = typeof R2 == "string" ? R2 : R2.emit === "stdout" ? R2.level : null;
                L2 && this.$on(L2, (S2) => {
                  rt.log(`${rt.tags[L2] ?? ""}`, S2.message || S2.query);
                });
              }
            this._metrics = new Ue(this._engine);
          } catch (f2) {
            throw f2.clientVersion = this._clientVersion, f2;
          }
          return this._appliedParent = pt(this);
        }
        get [Symbol.toStringTag]() {
          return "PrismaClient";
        }
        $use(n2) {
          this._middlewares.use(n2);
        }
        $on(n2, i2) {
          n2 === "beforeExit" ? this._engine.onBeforeExit(i2) : n2 && this._engineConfig.logEmitter.on(n2, i2);
        }
        $connect() {
          try {
            return this._engine.start();
          } catch (n2) {
            throw n2.clientVersion = this._clientVersion, n2;
          }
        }
        async $disconnect() {
          try {
            await this._engine.stop();
          } catch (n2) {
            throw n2.clientVersion = this._clientVersion, n2;
          } finally {
            Sn();
          }
        }
        $executeRawInternal(n2, i2, o2, s2) {
          let a2 = this._activeProvider;
          return this._request({ action: "executeRaw", args: o2, transaction: n2, clientMethod: i2, argsMapper: jr({ clientMethod: i2, activeProvider: a2 }), callsite: xe(this._errorFormat), dataPath: [], middlewareArgsMapper: s2 });
        }
        $executeRaw(n2, ...i2) {
          return this._createPrismaPromise((o2) => {
            if (n2.raw !== void 0 || n2.sql !== void 0) {
              let [s2, a2] = Co(n2, i2);
              return qr(this._activeProvider, s2.text, s2.values, Array.isArray(n2) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o2, "$executeRaw", s2, a2);
            }
            throw new W2("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
          });
        }
        $executeRawUnsafe(n2, ...i2) {
          return this._createPrismaPromise((o2) => (qr(this._activeProvider, n2, i2, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o2, "$executeRawUnsafe", [n2, ...i2])));
        }
        $runCommandRaw(n2) {
          if (e2.activeProvider !== "mongodb")
            throw new W2(`The ${e2.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
          return this._createPrismaPromise((i2) => this._request({ args: n2, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: Hi, callsite: xe(this._errorFormat), transaction: i2 }));
        }
        async $queryRawInternal(n2, i2, o2, s2) {
          let a2 = this._activeProvider;
          return this._request({ action: "queryRaw", args: o2, transaction: n2, clientMethod: i2, argsMapper: jr({ clientMethod: i2, activeProvider: a2 }), callsite: xe(this._errorFormat), dataPath: [], middlewareArgsMapper: s2 }).then(ho);
        }
        $queryRaw(n2, ...i2) {
          return this._createPrismaPromise((o2) => {
            if (n2.raw !== void 0 || n2.sql !== void 0)
              return this.$queryRawInternal(o2, "$queryRaw", ...Co(n2, i2));
            throw new W2("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
          });
        }
        $queryRawUnsafe(n2, ...i2) {
          return this._createPrismaPromise((o2) => this.$queryRawInternal(o2, "$queryRawUnsafe", [n2, ...i2]));
        }
        _transactionWithArray({ promises: n2, options: i2 }) {
          let o2 = Ka.nextId(), s2 = so(n2.length), a2 = n2.map((f2, v2) => {
            if (f2?.[Symbol.toStringTag] !== "PrismaPromise")
              throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
            let C2 = i2?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel, T2 = { kind: "batch", id: o2, index: v2, isolationLevel: C2, lock: s2 };
            return f2.requestTransaction?.(T2) ?? f2;
          });
          return vo(a2);
        }
        async _transactionWithCallback({ callback: n2, options: i2 }) {
          let o2 = { traceparent: this._tracingHelper.getTraceParent() }, s2 = { maxWait: i2?.maxWait ?? this._engineConfig.transactionOptions.maxWait, timeout: i2?.timeout ?? this._engineConfig.transactionOptions.timeout, isolationLevel: i2?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel }, a2 = await this._engine.transaction("start", o2, s2), f2;
          try {
            let v2 = { kind: "itx", ...a2 };
            f2 = await n2(this._createItxClient(v2)), await this._engine.transaction("commit", o2, a2);
          } catch (v2) {
            throw await this._engine.transaction("rollback", o2, a2).catch(() => {
            }), v2;
          }
          return f2;
        }
        _createItxClient(n2) {
          return pt(me(mi(this), [H2("_appliedParent", () => this._appliedParent._createItxClient(n2)), H2("_createPrismaPromise", () => Qr(n2)), H2(Ga, () => n2.id), $e(ao2)]));
        }
        $transaction(n2, i2) {
          let o2;
          typeof n2 == "function" ? this._engineConfig.adapter?.adapterName === "@prisma/adapter-d1" ? o2 = () => {
            throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.");
          } : o2 = () => this._transactionWithCallback({ callback: n2, options: i2 }) : o2 = () => this._transactionWithArray({ promises: n2, options: i2 });
          let s2 = { name: "transaction", attributes: { method: "$transaction" } };
          return this._tracingHelper.runInChildSpan(s2, o2);
        }
        _request(n2) {
          n2.otelParentCtx = this._tracingHelper.getActiveContext();
          let i2 = n2.middlewareArgsMapper ?? Wa, o2 = { args: i2.requestArgsToMiddlewareArgs(n2.args), dataPath: n2.dataPath, runInTransaction: !!n2.transaction, action: n2.action, model: n2.model }, s2 = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: o2.action, model: o2.model, name: o2.model ? `${o2.model}.${o2.action}` : o2.action } } }, a2 = -1, f2 = async (v2) => {
            let C2 = this._middlewares.get(++a2);
            if (C2)
              return this._tracingHelper.runInChildSpan(s2.middleware, (M2) => C2(v2, (ne) => (M2?.end(), f2(ne))));
            let { runInTransaction: T2, args: O2, ...R2 } = v2, L2 = { ...n2, ...R2 };
            O2 && (L2.args = i2.middlewareArgsToRequestArgs(O2)), n2.transaction !== void 0 && T2 === false && delete L2.transaction;
            let S2 = await wi(this, L2);
            return L2.model ? gi({ result: S2, modelName: L2.model, args: L2.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel }) : S2;
          };
          return this._tracingHelper.runInChildSpan(s2.operation, () => f2(o2));
        }
        async _executeRequest({ args: n2, clientMethod: i2, dataPath: o2, callsite: s2, action: a2, model: f2, argsMapper: v2, transaction: C2, unpacker: T2, otelParentCtx: O2, customDataProxyFetch: R2 }) {
          try {
            n2 = v2 ? v2(n2) : n2;
            let L2 = { name: "serialize" }, S2 = this._tracingHelper.runInChildSpan(L2, () => Wi({ modelName: f2, runtimeDataModel: this._runtimeDataModel, action: a2, args: n2, clientMethod: i2, callsite: s2, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion, previewFeatures: this._previewFeatures }));
            return ee.enabled("prisma:client") && (ve("Prisma Client call:"), ve(`prisma.${i2}(${ei(n2)})`), ve("Generated request:"), ve(JSON.stringify(S2, null, 2) + `
`)), C2?.kind === "batch" && await C2.lock, this._requestHandler.request({ protocolQuery: S2, modelName: f2, action: a2, clientMethod: i2, dataPath: o2, callsite: s2, args: n2, extensions: this._extensions, transaction: C2, unpacker: T2, otelParentCtx: O2, otelChildCtx: this._tracingHelper.getActiveContext(), customDataProxyFetch: R2 });
          } catch (L2) {
            throw L2.clientVersion = this._clientVersion, L2;
          }
        }
        get $metrics() {
          if (!this._hasPreviewFlag("metrics"))
            throw new W2("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
          return this._metrics;
        }
        _hasPreviewFlag(n2) {
          return !!this._engineConfig.previewFeatures?.includes(n2);
        }
        $applyPendingMigrations() {
          return this._engine.applyPendingMigrations();
        }
      }
      return t2;
    }
    function Co(e2, t2) {
      return Ha(e2) ? [new X2(e2, t2), to] : [e2, ro];
    }
    function Ha(e2) {
      return Array.isArray(e2) && Array.isArray(e2.raw);
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    var za = /* @__PURE__ */ new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
    function Ro(e2) {
      return new Proxy(e2, { get(t2, r2) {
        if (r2 in t2)
          return t2[r2];
        if (!za.has(r2))
          throw new TypeError(`Invalid enum value: ${String(r2)}`);
      } });
    }
    u2();
    c2();
    m2();
    p2();
    d2();
    l2();
    l2();
  }
});

// ../../node_modules/.prisma/client/query_engine_bg.js
var require_query_engine_bg = __commonJS({
  "../../node_modules/.prisma/client/query_engine_bg.js"(exports, module) {
    "use strict";
    init_checked_fetch();
    init_modules_watch_stub();
    var v2 = Object.defineProperty;
    var R2 = Object.getOwnPropertyDescriptor;
    var B2 = Object.getOwnPropertyNames;
    var U2 = Object.prototype.hasOwnProperty;
    var D2 = (n2, t2) => {
      for (var e2 in t2)
        v2(n2, e2, { get: t2[e2], enumerable: true });
    };
    var N2 = (n2, t2, e2, o2) => {
      if (t2 && typeof t2 == "object" || typeof t2 == "function")
        for (let _ of B2(t2))
          !U2.call(n2, _) && _ !== e2 && v2(n2, _, { get: () => t2[_], enumerable: !(o2 = R2(t2, _)) || o2.enumerable });
      return n2;
    };
    var L2 = (n2) => N2(v2({}, "__esModule", { value: true }), n2);
    var kt = {};
    D2(kt, { QueryEngine: () => Z2, __wbg_String_88810dfeb4021902: () => Un, __wbg_buffer_344d9b41efe96da7: () => Nn, __wbg_call_53fc3abd42e24ec8: () => gt, __wbg_call_669127b9d730c650: () => Zn, __wbg_crypto_58f13aa23ffcb166: () => Jn, __wbg_done_bc26bf4ada718266: () => rt, __wbg_entries_6d727b73ee02b7ce: () => Tt, __wbg_getRandomValues_504510b5564925af: () => Pn, __wbg_getTime_ed6ee333b702f8fc: () => an2, __wbg_get_2aff440840bb6202: () => ct2, __wbg_get_4a9aa5157afeb382: () => nt, __wbg_get_94990005bd6ca07c: () => Bn, __wbg_getwithrefkey_5e6d9547403deab8: () => Mn, __wbg_globalThis_17eff828815f7d84: () => st, __wbg_global_46f939f6541643c5: () => ft, __wbg_has_cdf8b85f6e903c80: () => un, __wbg_instanceof_ArrayBuffer_c7cc317e5c29cc0d: () => ht, __wbg_instanceof_Promise_cfbcc42300367513: () => dn, __wbg_instanceof_Uint8Array_19e6f142a5e7e1e1: () => mt, __wbg_isArray_38525be7442aa21e: () => bt2, __wbg_isSafeInteger_c38b0a16d0c7cef7: () => lt, __wbg_iterator_7ee1a391d310f8e4: () => wn, __wbg_length_a5587d6cd79ab197: () => yt, __wbg_length_cace2e0b3ddc0502: () => pn, __wbg_msCrypto_abcb1295e768d1f2: () => Gn, __wbg_new0_ad75dd38f92424e2: () => fn, __wbg_new_08236689f0afb357: () => qn, __wbg_new_1b94180eeb48f2a2: () => vn, __wbg_new_c728d68b8b34487e: () => Fn, __wbg_new_d8a000788389a31e: () => $n, __wbg_new_feb65b865d980ae2: () => en, __wbg_newnoargs_ccdcae30fd002262: () => at2, __wbg_newwithbyteoffsetandlength_2dc04d99088b15e3: () => Ln, __wbg_newwithlength_13b5319ab422dcf6: () => Kn, __wbg_next_15da6a3df9290720: () => _t, __wbg_next_1989a20442400aaa: () => et, __wbg_node_523d7bd03ef69fba: () => Qn, __wbg_now_4579335d3581594c: () => gn, __wbg_now_8ed1a4454e40ecd1: () => bn2, __wbg_parse_3f0cb48976ca4123: () => sn, __wbg_process_5b786e71d465a513: () => Vn, __wbg_push_fd3233d09cf81821: () => Rn, __wbg_randomFillSync_a0d98aa11c81fe89: () => Cn, __wbg_require_2784e593a4674877: () => Hn, __wbg_resolve_a3252b2860f0a09e: () => Ft, __wbg_self_3fad056edded10bd: () => it, __wbg_setTimeout_631fe61f31fa2fad: () => rn, __wbg_set_0ac78a2bc07da03c: () => On, __wbg_set_3355b9f2d3092e3b: () => En, __wbg_set_40f7786a25a9cc7e: () => dt, __wbg_set_841ac57cff3d672b: () => kn, __wbg_set_dcfd613a3420f908: () => pt, __wbg_set_wasm: () => $2, __wbg_stringify_4039297315a25b00: () => wt, __wbg_subarray_6ca5cfa7fbb9abbe: () => zn, __wbg_then_1bbc9edafd859b06: () => vt, __wbg_then_89e1c559530b85cf: () => Ot, __wbg_valueOf_ff4b62641803432a: () => tt, __wbg_value_0570714ff7d75f35: () => ot, __wbg_versions_c2ab80650590b6a2: () => Wn, __wbg_window_a4f46c98a61d4089: () => ut, __wbindgen_bigint_from_i64: () => hn, __wbindgen_bigint_from_u64: () => Sn, __wbindgen_bigint_get_as_i64: () => St, __wbindgen_boolean_get: () => yn, __wbindgen_cb_drop: () => qt, __wbindgen_closure_wrapper6606: () => It, __wbindgen_debug_string: () => At, __wbindgen_error_new: () => tn, __wbindgen_in: () => Tn, __wbindgen_is_bigint: () => xn, __wbindgen_is_function: () => Xn, __wbindgen_is_object: () => ln, __wbindgen_is_string: () => In, __wbindgen_is_undefined: () => cn2, __wbindgen_jsval_eq: () => An, __wbindgen_jsval_loose_eq: () => xt, __wbindgen_memory: () => Dn, __wbindgen_number_get: () => mn, __wbindgen_number_new: () => jn, __wbindgen_object_clone_ref: () => _n, __wbindgen_object_drop_ref: () => Yn, __wbindgen_string_get: () => nn, __wbindgen_string_new: () => on, __wbindgen_throw: () => jt, debug_panic: () => K2, getBuildTimeInfo: () => G2 });
    module.exports = L2(kt);
    var h2 = () => {
    };
    h2.prototype = h2;
    var c2;
    function $2(n2) {
      c2 = n2;
    }
    var w2 = new Array(128).fill(void 0);
    w2.push(void 0, null, true, false);
    function r2(n2) {
      return w2[n2];
    }
    var a2 = 0;
    var T2 = null;
    function S2() {
      return (T2 === null || T2.byteLength === 0) && (T2 = new Uint8Array(c2.memory.buffer)), T2;
    }
    var C2 = typeof TextEncoder > "u" ? (0, module.require)("util").TextEncoder : TextEncoder;
    var A2 = new C2("utf-8");
    var z5 = typeof A2.encodeInto == "function" ? function(n2, t2) {
      return A2.encodeInto(n2, t2);
    } : function(n2, t2) {
      const e2 = A2.encode(n2);
      return t2.set(e2), { read: n2.length, written: e2.length };
    };
    function g2(n2, t2, e2) {
      if (e2 === void 0) {
        const s2 = A2.encode(n2), p2 = t2(s2.length, 1) >>> 0;
        return S2().subarray(p2, p2 + s2.length).set(s2), a2 = s2.length, p2;
      }
      let o2 = n2.length, _ = t2(o2, 1) >>> 0;
      const f2 = S2();
      let u2 = 0;
      for (; u2 < o2; u2++) {
        const s2 = n2.charCodeAt(u2);
        if (s2 > 127)
          break;
        f2[_ + u2] = s2;
      }
      if (u2 !== o2) {
        u2 !== 0 && (n2 = n2.slice(u2)), _ = e2(_, o2, o2 = u2 + n2.length * 3, 1) >>> 0;
        const s2 = S2().subarray(_ + u2, _ + o2), p2 = z5(n2, s2);
        u2 += p2.written, _ = e2(_, o2, u2, 1) >>> 0;
      }
      return a2 = u2, _;
    }
    function y2(n2) {
      return n2 == null;
    }
    var j2 = null;
    function d2() {
      return (j2 === null || j2.byteLength === 0) && (j2 = new Int32Array(c2.memory.buffer)), j2;
    }
    var P2 = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
    var I2 = new P2("utf-8", { ignoreBOM: true, fatal: true });
    I2.decode();
    function x2(n2, t2) {
      return n2 = n2 >>> 0, I2.decode(S2().subarray(n2, n2 + t2));
    }
    var m2 = w2.length;
    function i2(n2) {
      m2 === w2.length && w2.push(w2.length + 1);
      const t2 = m2;
      return m2 = w2[t2], w2[t2] = n2, t2;
    }
    var q2 = null;
    function J2() {
      return (q2 === null || q2.byteLength === 0) && (q2 = new Float64Array(c2.memory.buffer)), q2;
    }
    function V2(n2) {
      n2 < 132 || (w2[n2] = m2, m2 = n2);
    }
    function b2(n2) {
      const t2 = r2(n2);
      return V2(n2), t2;
    }
    var O2 = null;
    function W2() {
      return (O2 === null || O2.byteLength === 0) && (O2 = new BigInt64Array(c2.memory.buffer)), O2;
    }
    function F2(n2) {
      const t2 = typeof n2;
      if (t2 == "number" || t2 == "boolean" || n2 == null)
        return `${n2}`;
      if (t2 == "string")
        return `"${n2}"`;
      if (t2 == "symbol") {
        const _ = n2.description;
        return _ == null ? "Symbol" : `Symbol(${_})`;
      }
      if (t2 == "function") {
        const _ = n2.name;
        return typeof _ == "string" && _.length > 0 ? `Function(${_})` : "Function";
      }
      if (Array.isArray(n2)) {
        const _ = n2.length;
        let f2 = "[";
        _ > 0 && (f2 += F2(n2[0]));
        for (let u2 = 1; u2 < _; u2++)
          f2 += ", " + F2(n2[u2]);
        return f2 += "]", f2;
      }
      const e2 = /\[object ([^\]]+)\]/.exec(toString.call(n2));
      let o2;
      if (e2.length > 1)
        o2 = e2[1];
      else
        return toString.call(n2);
      if (o2 == "Object")
        try {
          return "Object(" + JSON.stringify(n2) + ")";
        } catch {
          return "Object";
        }
      return n2 instanceof Error ? `${n2.name}: ${n2.message}
${n2.stack}` : o2;
    }
    var k2 = typeof FinalizationRegistry > "u" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((n2) => {
      c2.__wbindgen_export_2.get(n2.dtor)(n2.a, n2.b);
    });
    function Q2(n2, t2, e2, o2) {
      const _ = { a: n2, b: t2, cnt: 1, dtor: e2 }, f2 = (...u2) => {
        _.cnt++;
        const s2 = _.a;
        _.a = 0;
        try {
          return o2(s2, _.b, ...u2);
        } finally {
          --_.cnt === 0 ? (c2.__wbindgen_export_2.get(_.dtor)(s2, _.b), k2.unregister(_)) : _.a = s2;
        }
      };
      return f2.original = _, k2.register(f2, _, _), f2;
    }
    function H2(n2, t2, e2) {
      c2.wasm_bindgen__convert__closures__invoke1_mut__h2ab813b52dfc3511(n2, t2, i2(e2));
    }
    function G2() {
      const n2 = c2.getBuildTimeInfo();
      return b2(n2);
    }
    function K2(n2) {
      try {
        const f2 = c2.__wbindgen_add_to_stack_pointer(-16);
        var t2 = y2(n2) ? 0 : g2(n2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), e2 = a2;
        c2.debug_panic(f2, t2, e2);
        var o2 = d2()[f2 / 4 + 0], _ = d2()[f2 / 4 + 1];
        if (_)
          throw b2(o2);
      } finally {
        c2.__wbindgen_add_to_stack_pointer(16);
      }
    }
    function l2(n2, t2) {
      try {
        return n2.apply(this, t2);
      } catch (e2) {
        c2.__wbindgen_exn_store(i2(e2));
      }
    }
    function X2(n2, t2, e2, o2) {
      c2.wasm_bindgen__convert__closures__invoke2_mut__h214de23b6bdb9b7b(n2, t2, i2(e2), i2(o2));
    }
    var Y2 = typeof FinalizationRegistry > "u" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((n2) => c2.__wbg_queryengine_free(n2 >>> 0));
    var Z2 = class {
      __destroy_into_raw() {
        const t2 = this.__wbg_ptr;
        return this.__wbg_ptr = 0, Y2.unregister(this), t2;
      }
      free() {
        const t2 = this.__destroy_into_raw();
        c2.__wbg_queryengine_free(t2);
      }
      constructor(t2, e2, o2) {
        try {
          const s2 = c2.__wbindgen_add_to_stack_pointer(-16);
          c2.queryengine_new(s2, i2(t2), i2(e2), i2(o2));
          var _ = d2()[s2 / 4 + 0], f2 = d2()[s2 / 4 + 1], u2 = d2()[s2 / 4 + 2];
          if (u2)
            throw b2(f2);
          return this.__wbg_ptr = _ >>> 0, this;
        } finally {
          c2.__wbindgen_add_to_stack_pointer(16);
        }
      }
      connect(t2) {
        const e2 = g2(t2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), o2 = a2, _ = c2.queryengine_connect(this.__wbg_ptr, e2, o2);
        return b2(_);
      }
      disconnect(t2) {
        const e2 = g2(t2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), o2 = a2, _ = c2.queryengine_disconnect(this.__wbg_ptr, e2, o2);
        return b2(_);
      }
      query(t2, e2, o2) {
        const _ = g2(t2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), f2 = a2, u2 = g2(e2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), s2 = a2;
        var p2 = y2(o2) ? 0 : g2(o2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), E2 = a2;
        const M2 = c2.queryengine_query(this.__wbg_ptr, _, f2, u2, s2, p2, E2);
        return b2(M2);
      }
      startTransaction(t2, e2) {
        const o2 = g2(t2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), _ = a2, f2 = g2(e2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), u2 = a2, s2 = c2.queryengine_startTransaction(this.__wbg_ptr, o2, _, f2, u2);
        return b2(s2);
      }
      commitTransaction(t2, e2) {
        const o2 = g2(t2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), _ = a2, f2 = g2(e2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), u2 = a2, s2 = c2.queryengine_commitTransaction(this.__wbg_ptr, o2, _, f2, u2);
        return b2(s2);
      }
      rollbackTransaction(t2, e2) {
        const o2 = g2(t2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), _ = a2, f2 = g2(e2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), u2 = a2, s2 = c2.queryengine_rollbackTransaction(this.__wbg_ptr, o2, _, f2, u2);
        return b2(s2);
      }
      metrics(t2) {
        const e2 = g2(t2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), o2 = a2, _ = c2.queryengine_metrics(this.__wbg_ptr, e2, o2);
        return b2(_);
      }
    };
    function nn(n2, t2) {
      const e2 = r2(t2), o2 = typeof e2 == "string" ? e2 : void 0;
      var _ = y2(o2) ? 0 : g2(o2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), f2 = a2;
      d2()[n2 / 4 + 1] = f2, d2()[n2 / 4 + 0] = _;
    }
    function tn(n2, t2) {
      const e2 = new Error(x2(n2, t2));
      return i2(e2);
    }
    function en(n2, t2) {
      try {
        var e2 = { a: n2, b: t2 }, o2 = (f2, u2) => {
          const s2 = e2.a;
          e2.a = 0;
          try {
            return X2(s2, e2.b, f2, u2);
          } finally {
            e2.a = s2;
          }
        };
        const _ = new Promise(o2);
        return i2(_);
      } finally {
        e2.a = e2.b = 0;
      }
    }
    function rn(n2, t2) {
      return setTimeout(r2(n2), t2 >>> 0);
    }
    function on(n2, t2) {
      const e2 = x2(n2, t2);
      return i2(e2);
    }
    function _n(n2) {
      const t2 = r2(n2);
      return i2(t2);
    }
    function cn2(n2) {
      return r2(n2) === void 0;
    }
    function un() {
      return l2(function(n2, t2) {
        return Reflect.has(r2(n2), r2(t2));
      }, arguments);
    }
    function sn() {
      return l2(function(n2, t2) {
        const e2 = JSON.parse(x2(n2, t2));
        return i2(e2);
      }, arguments);
    }
    function fn() {
      return i2(/* @__PURE__ */ new Date());
    }
    function an2(n2) {
      return r2(n2).getTime();
    }
    function bn2(n2) {
      return r2(n2).now();
    }
    function gn() {
      return Date.now();
    }
    function ln(n2) {
      const t2 = r2(n2);
      return typeof t2 == "object" && t2 !== null;
    }
    function dn(n2) {
      let t2;
      try {
        t2 = r2(n2) instanceof Promise;
      } catch {
        t2 = false;
      }
      return t2;
    }
    function wn() {
      return i2(Symbol.iterator);
    }
    function pn(n2) {
      return r2(n2).length;
    }
    function yn(n2) {
      const t2 = r2(n2);
      return typeof t2 == "boolean" ? t2 ? 1 : 0 : 2;
    }
    function xn(n2) {
      return typeof r2(n2) == "bigint";
    }
    function mn(n2, t2) {
      const e2 = r2(t2), o2 = typeof e2 == "number" ? e2 : void 0;
      J2()[n2 / 8 + 1] = y2(o2) ? 0 : o2, d2()[n2 / 4 + 0] = !y2(o2);
    }
    function hn(n2) {
      return i2(n2);
    }
    function Tn(n2, t2) {
      return r2(n2) in r2(t2);
    }
    function Sn(n2) {
      const t2 = BigInt.asUintN(64, n2);
      return i2(t2);
    }
    function An(n2, t2) {
      return r2(n2) === r2(t2);
    }
    function jn(n2) {
      return i2(n2);
    }
    function qn() {
      const n2 = new Array();
      return i2(n2);
    }
    function On(n2, t2, e2) {
      r2(n2)[t2 >>> 0] = b2(e2);
    }
    function vn() {
      return i2(/* @__PURE__ */ new Map());
    }
    function Fn() {
      const n2 = new Object();
      return i2(n2);
    }
    function In(n2) {
      return typeof r2(n2) == "string";
    }
    function kn(n2, t2, e2) {
      r2(n2)[b2(t2)] = b2(e2);
    }
    function En(n2, t2, e2) {
      const o2 = r2(n2).set(r2(t2), r2(e2));
      return i2(o2);
    }
    function Mn(n2, t2) {
      const e2 = r2(n2)[r2(t2)];
      return i2(e2);
    }
    function Rn(n2, t2) {
      return r2(n2).push(r2(t2));
    }
    function Bn() {
      return l2(function(n2, t2) {
        const e2 = r2(n2)[b2(t2)];
        return i2(e2);
      }, arguments);
    }
    function Un(n2, t2) {
      const e2 = String(r2(t2)), o2 = g2(e2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), _ = a2;
      d2()[n2 / 4 + 1] = _, d2()[n2 / 4 + 0] = o2;
    }
    function Dn() {
      const n2 = c2.memory;
      return i2(n2);
    }
    function Nn(n2) {
      const t2 = r2(n2).buffer;
      return i2(t2);
    }
    function Ln(n2, t2, e2) {
      const o2 = new Uint8Array(r2(n2), t2 >>> 0, e2 >>> 0);
      return i2(o2);
    }
    function $n(n2) {
      const t2 = new Uint8Array(r2(n2));
      return i2(t2);
    }
    function Cn() {
      return l2(function(n2, t2) {
        r2(n2).randomFillSync(b2(t2));
      }, arguments);
    }
    function zn(n2, t2, e2) {
      const o2 = r2(n2).subarray(t2 >>> 0, e2 >>> 0);
      return i2(o2);
    }
    function Pn() {
      return l2(function(n2, t2) {
        r2(n2).getRandomValues(r2(t2));
      }, arguments);
    }
    function Jn(n2) {
      const t2 = r2(n2).crypto;
      return i2(t2);
    }
    function Vn(n2) {
      const t2 = r2(n2).process;
      return i2(t2);
    }
    function Wn(n2) {
      const t2 = r2(n2).versions;
      return i2(t2);
    }
    function Qn(n2) {
      const t2 = r2(n2).node;
      return i2(t2);
    }
    function Hn() {
      return l2(function() {
        const n2 = module.require;
        return i2(n2);
      }, arguments);
    }
    function Gn(n2) {
      const t2 = r2(n2).msCrypto;
      return i2(t2);
    }
    function Kn(n2) {
      const t2 = new Uint8Array(n2 >>> 0);
      return i2(t2);
    }
    function Xn(n2) {
      return typeof r2(n2) == "function";
    }
    function Yn(n2) {
      b2(n2);
    }
    function Zn() {
      return l2(function(n2, t2) {
        const e2 = r2(n2).call(r2(t2));
        return i2(e2);
      }, arguments);
    }
    function nt(n2, t2) {
      const e2 = r2(n2)[t2 >>> 0];
      return i2(e2);
    }
    function tt(n2) {
      return r2(n2).valueOf();
    }
    function et() {
      return l2(function(n2) {
        const t2 = r2(n2).next();
        return i2(t2);
      }, arguments);
    }
    function rt(n2) {
      return r2(n2).done;
    }
    function ot(n2) {
      const t2 = r2(n2).value;
      return i2(t2);
    }
    function _t(n2) {
      const t2 = r2(n2).next;
      return i2(t2);
    }
    function ct2() {
      return l2(function(n2, t2) {
        const e2 = Reflect.get(r2(n2), r2(t2));
        return i2(e2);
      }, arguments);
    }
    function it() {
      return l2(function() {
        const n2 = self.self;
        return i2(n2);
      }, arguments);
    }
    function ut() {
      return l2(function() {
        const n2 = window.window;
        return i2(n2);
      }, arguments);
    }
    function st() {
      return l2(function() {
        const n2 = globalThis.globalThis;
        return i2(n2);
      }, arguments);
    }
    function ft() {
      return l2(function() {
        const n2 = global.global;
        return i2(n2);
      }, arguments);
    }
    function at2(n2, t2) {
      const e2 = new h2(x2(n2, t2));
      return i2(e2);
    }
    function bt2(n2) {
      return Array.isArray(r2(n2));
    }
    function gt() {
      return l2(function(n2, t2, e2) {
        const o2 = r2(n2).call(r2(t2), r2(e2));
        return i2(o2);
      }, arguments);
    }
    function lt(n2) {
      return Number.isSafeInteger(r2(n2));
    }
    function dt() {
      return l2(function(n2, t2, e2) {
        return Reflect.set(r2(n2), r2(t2), r2(e2));
      }, arguments);
    }
    function wt() {
      return l2(function(n2) {
        const t2 = JSON.stringify(r2(n2));
        return i2(t2);
      }, arguments);
    }
    function pt(n2, t2, e2) {
      r2(n2).set(r2(t2), e2 >>> 0);
    }
    function yt(n2) {
      return r2(n2).length;
    }
    function xt(n2, t2) {
      return r2(n2) == r2(t2);
    }
    function mt(n2) {
      let t2;
      try {
        t2 = r2(n2) instanceof Uint8Array;
      } catch {
        t2 = false;
      }
      return t2;
    }
    function ht(n2) {
      let t2;
      try {
        t2 = r2(n2) instanceof ArrayBuffer;
      } catch {
        t2 = false;
      }
      return t2;
    }
    function Tt(n2) {
      const t2 = Object.entries(r2(n2));
      return i2(t2);
    }
    function St(n2, t2) {
      const e2 = r2(t2), o2 = typeof e2 == "bigint" ? e2 : void 0;
      W2()[n2 / 8 + 1] = y2(o2) ? BigInt(0) : o2, d2()[n2 / 4 + 0] = !y2(o2);
    }
    function At(n2, t2) {
      const e2 = F2(r2(t2)), o2 = g2(e2, c2.__wbindgen_malloc, c2.__wbindgen_realloc), _ = a2;
      d2()[n2 / 4 + 1] = _, d2()[n2 / 4 + 0] = o2;
    }
    function jt(n2, t2) {
      throw new Error(x2(n2, t2));
    }
    function qt(n2) {
      const t2 = b2(n2).original;
      return t2.cnt-- == 1 ? (t2.a = 0, true) : false;
    }
    function Ot(n2, t2) {
      const e2 = r2(n2).then(r2(t2));
      return i2(e2);
    }
    function vt(n2, t2, e2) {
      const o2 = r2(n2).then(r2(t2), r2(e2));
      return i2(o2);
    }
    function Ft(n2) {
      const t2 = Promise.resolve(r2(n2));
      return i2(t2);
    }
    function It(n2, t2, e2) {
      const o2 = Q2(n2, t2, 273, H2);
      return i2(o2);
    }
  }
});

// ../../node_modules/.prisma/client/wasm-worker-loader.js
var wasm_worker_loader_exports = {};
__export(wasm_worker_loader_exports, {
  default: () => wasm_worker_loader_default
});
var wasm_worker_loader_default;
var init_wasm_worker_loader = __esm({
  async "../../node_modules/.prisma/client/wasm-worker-loader.js"() {
    init_checked_fetch();
    init_modules_watch_stub();
    wasm_worker_loader_default = (await import("./dd061a11ae2d74eea192c0e2386bba5b544a7ae8-query_engine_bg.wasm")).default;
  }
});

// ../../node_modules/.prisma/client/wasm.js
var require_wasm2 = __commonJS({
  "../../node_modules/.prisma/client/wasm.js"(exports) {
    init_checked_fetch();
    init_modules_watch_stub();
    Object.defineProperty(exports, "__esModule", { value: true });
    var {
      PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
      PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
      PrismaClientRustPanicError: PrismaClientRustPanicError2,
      PrismaClientInitializationError: PrismaClientInitializationError2,
      PrismaClientValidationError: PrismaClientValidationError2,
      NotFoundError: NotFoundError3,
      getPrismaClient: getPrismaClient2,
      sqltag: sqltag2,
      empty: empty2,
      join: join2,
      raw: raw3,
      Decimal: Decimal2,
      Debug: Debug3,
      objectEnumValues: objectEnumValues2,
      makeStrictEnum: makeStrictEnum2,
      Extensions: Extensions2,
      warnOnce: warnOnce2,
      defineDmmfProperty: defineDmmfProperty2,
      Public: Public2,
      getRuntime: getRuntime2
    } = require_wasm();
    var Prisma = {};
    exports.Prisma = Prisma;
    exports.$Enums = {};
    Prisma.prismaVersion = {
      client: "5.14.0",
      engine: "e9771e62de70f79a5e1c604a2d7c8e2a0a874b48"
    };
    Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
    Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
    Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
    Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
    Prisma.PrismaClientValidationError = PrismaClientValidationError2;
    Prisma.NotFoundError = NotFoundError3;
    Prisma.Decimal = Decimal2;
    Prisma.sql = sqltag2;
    Prisma.empty = empty2;
    Prisma.join = join2;
    Prisma.raw = raw3;
    Prisma.validator = Public2.validator;
    Prisma.getExtensionContext = Extensions2.getExtensionContext;
    Prisma.defineExtension = Extensions2.defineExtension;
    Prisma.DbNull = objectEnumValues2.instances.DbNull;
    Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
    Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
    Prisma.NullTypes = {
      DbNull: objectEnumValues2.classes.DbNull,
      JsonNull: objectEnumValues2.classes.JsonNull,
      AnyNull: objectEnumValues2.classes.AnyNull
    };
    exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
      Serializable: "Serializable"
    });
    exports.Prisma.UserRoleScalarFieldEnum = {
      id: "id"
    };
    exports.Prisma.UserScalarFieldEnum = {
      id: "id",
      username: "username",
      role: "role",
      enabled: "enabled",
      email: "email",
      password: "password",
      isDeleted: "isDeleted",
      lastLogin: "lastLogin",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.KeyTokenScalarFieldEnum = {
      id: "id",
      userId: "userId",
      publicKey: "publicKey",
      privateKey: "privateKey",
      refreshToken: "refreshToken",
      refreshTokensUsed: "refreshTokensUsed",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.AplicationMasterScalarFieldEnum = {
      id: "id",
      appName: "appName",
      packageName: "packageName",
      isDeleted: "isDeleted",
      termsOfUseId: "termsOfUseId",
      licenseId: "licenseId",
      assetBundleIOS: "assetBundleIOS",
      assetBundleAndroid: "assetBundleAndroid",
      encryptKey: "encryptKey",
      outlineUrl: "outlineUrl",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.AcstaManagementScalarFieldEnum = {
      id: "id",
      managementName: "managementName",
      acstaName: "acstaName",
      applicationId: "applicationId",
      isDeleted: "isDeleted",
      thumbnailUrl: "thumbnailUrl",
      scanImageUrl: "scanImageUrl",
      acstaBasicInfoId: "acstaBasicInfoId",
      scanOriginX: "scanOriginX",
      scanOriginY: "scanOriginY",
      scanWidth: "scanWidth",
      scanHeight: "scanHeight",
      scanColors: "scanColors",
      modeId: "modeId",
      dateStart: "dateStart",
      dateEnd: "dateEnd",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.PerformaceTypeMasterScalarFieldEnum = {
      id: "id",
      typeName: "typeName",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.PerformaceManagementScalarFieldEnum = {
      id: "id",
      name: "name",
      isDeleted: "isDeleted",
      performanceTypeMasterId: "performanceTypeMasterId",
      assetBundleIOS: "assetBundleIOS",
      acstaId: "acstaId",
      assetBundleAndroid: "assetBundleAndroid",
      encryptKey: "encryptKey",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.TermsOfUseScalarFieldEnum = {
      id: "id",
      memo: "memo",
      version: "version",
      content: "content",
      publishedDate: "publishedDate",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.LicenseScalarFieldEnum = {
      id: "id",
      memo: "memo",
      version: "version",
      content: "content",
      publishedDate: "publishedDate",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.IdLastestOfRecordScalarFieldEnum = {
      id: "id",
      name: "name",
      idLastest: "idLastest",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.ForcedUpdateManagementScalarFieldEnum = {
      id: "id",
      appMasterId: "appMasterId",
      managementName: "managementName",
      operateSystem: "operateSystem",
      version: "version",
      publishedDate: "publishedDate",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.BootUpdateScalarFieldEnum = {
      id: "id",
      tableName: "tableName",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.SortOrder = {
      asc: "asc",
      desc: "desc"
    };
    exports.Prisma.NullsOrder = {
      first: "first",
      last: "last"
    };
    exports.Prisma.ModelName = {
      UserRole: "UserRole",
      User: "User",
      KeyToken: "KeyToken",
      AplicationMaster: "AplicationMaster",
      AcstaManagement: "AcstaManagement",
      PerformaceTypeMaster: "PerformaceTypeMaster",
      PerformaceManagement: "PerformaceManagement",
      TermsOfUse: "TermsOfUse",
      License: "License",
      IdLastestOfRecord: "IdLastestOfRecord",
      ForcedUpdateManagement: "ForcedUpdateManagement",
      BootUpdate: "BootUpdate"
    };
    var config = {
      "generator": {
        "name": "client",
        "provider": {
          "fromEnvVar": null,
          "value": "prisma-client-js"
        },
        "output": {
          "value": "D:\\Code_Congty\\da-acstar-cms\\node_modules\\@prisma\\client",
          "fromEnvVar": null
        },
        "config": {
          "engineType": "library"
        },
        "binaryTargets": [
          {
            "fromEnvVar": null,
            "value": "windows",
            "native": true
          }
        ],
        "previewFeatures": [
          "driverAdapters"
        ]
      },
      "relativeEnvPaths": {
        "rootEnvPath": null,
        "schemaEnvPath": "../../../apps/cms/.env"
      },
      "relativePath": "../../../apps/cms/prisma",
      "clientVersion": "5.14.0",
      "engineVersion": "e9771e62de70f79a5e1c604a2d7c8e2a0a874b48",
      "datasourceNames": [
        "db"
      ],
      "activeProvider": "sqlite",
      "postinstall": false,
      "inlineDatasources": {
        "db": {
          "url": {
            "fromEnvVar": "DATABASE_URL",
            "value": null
          }
        }
      },
      "inlineSchema": `// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// stores allowed values for user roles
// enum : ['ADMIN', 'READ_ONLY', 'GENERAL']
model UserRole {
  id    String @id
  users User[]
}

model User {
  id        Int       @id @default(autoincrement())
  username  String
  role      String    @default("READ_ONLY")
  enabled   Boolean   @default(true)
  email     String
  password  String
  isDeleted Boolean   @default(false)
  lastLogin DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  userRole UserRole  @relation(fields: [role], references: [id])
  keyToken KeyToken?
}

model KeyToken {
  id                Int     @id @default(autoincrement())
  userId            Int     @unique
  publicKey         String? @unique
  privateKey        String? @unique
  refreshToken      String? @unique
  // JSON object
  // Currently, Prisma do not suport JSON type
  refreshTokensUsed String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AplicationMaster {
  id                 Int      @id @default(autoincrement())
  appName            String
  packageName        String
  isDeleted          Boolean  @default(false)
  termsOfUseId       Int
  licenseId          Int
  assetBundleIOS     String
  assetBundleAndroid String
  encryptKey         String
  outlineUrl         String
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  termOfUse TermsOfUse @relation(fields: [termsOfUseId], references: [id])
  license   License    @relation(fields: [licenseId], references: [id])

  acsta        AcstaManagement[]
  forcedUpdate ForcedUpdateManagement[]
}

model AcstaManagement {
  id               Int       @id @default(autoincrement())
  managementName   String
  acstaName        String
  applicationId    Int
  isDeleted        Boolean   @default(false)
  thumbnailUrl     String
  scanImageUrl     String
  acstaBasicInfoId Int?
  scanOriginX      Float?
  scanOriginY      Float?
  scanWidth        Float?
  scanHeight       Float?
  scanColors       String?
  modeId           Int?
  dateStart        DateTime
  dateEnd          DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  application AplicationMaster       @relation(fields: [applicationId], references: [id])
  performace  PerformaceManagement[]
}

model PerformaceTypeMaster {
  id        Int      @id @default(autoincrement())
  typeName  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  performances PerformaceManagement[]
}

model PerformaceManagement {
  id                      Int      @id @default(autoincrement())
  name                    String
  isDeleted               Boolean  @default(false)
  performanceTypeMasterId Int
  assetBundleIOS          String
  acstaId                 Int
  assetBundleAndroid      String
  encryptKey              String
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  performanceTypeMaster PerformaceTypeMaster @relation(fields: [performanceTypeMasterId], references: [id])
  acsta                 AcstaManagement      @relation(fields: [acstaId], references: [id])
}

model TermsOfUse {
  id            Int      @id @default(autoincrement())
  memo          String?
  version       String
  content       String
  publishedDate DateTime
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  applications AplicationMaster[]
}

model License {
  id            Int      @id @default(autoincrement())
  memo          String?
  version       String
  content       String
  publishedDate DateTime
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  applications AplicationMaster[]
}

model IdLastestOfRecord {
  id        Int      @id @default(autoincrement())
  name      String
  idLastest Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ForcedUpdateManagement {
  id             Int      @id @default(autoincrement())
  appMasterId    Int
  managementName String
  operateSystem  String
  version        String
  publishedDate  DateTime
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  aplicationMaster AplicationMaster @relation(fields: [appMasterId], references: [id])
}

model BootUpdate {
  id        Int      @id @default(autoincrement())
  tableName String   @unique /// table name
  createdAt DateTime @default(now()) /// Creation date and time
  updatedAt DateTime @updatedAt /// updated date and time
}
`,
      "inlineSchemaHash": "d07028ae740b04d36525992e2f3f7036388c48ec3c91a12d1a6dc1e0bc06397a",
      "copyEngine": true
    };
    config.dirname = "/";
    config.runtimeDataModel = JSON.parse('{"models":{"UserRole":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"users","kind":"object","type":"User","relationName":"UserToUserRole"}],"dbName":null},"User":{"fields":[{"name":"id","kind":"scalar","type":"Int"},{"name":"username","kind":"scalar","type":"String"},{"name":"role","kind":"scalar","type":"String"},{"name":"enabled","kind":"scalar","type":"Boolean"},{"name":"email","kind":"scalar","type":"String"},{"name":"password","kind":"scalar","type":"String"},{"name":"isDeleted","kind":"scalar","type":"Boolean"},{"name":"lastLogin","kind":"scalar","type":"DateTime"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"userRole","kind":"object","type":"UserRole","relationName":"UserToUserRole"},{"name":"keyToken","kind":"object","type":"KeyToken","relationName":"KeyTokenToUser"}],"dbName":null},"KeyToken":{"fields":[{"name":"id","kind":"scalar","type":"Int"},{"name":"userId","kind":"scalar","type":"Int"},{"name":"publicKey","kind":"scalar","type":"String"},{"name":"privateKey","kind":"scalar","type":"String"},{"name":"refreshToken","kind":"scalar","type":"String"},{"name":"refreshTokensUsed","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"user","kind":"object","type":"User","relationName":"KeyTokenToUser"}],"dbName":null},"AplicationMaster":{"fields":[{"name":"id","kind":"scalar","type":"Int"},{"name":"appName","kind":"scalar","type":"String"},{"name":"packageName","kind":"scalar","type":"String"},{"name":"isDeleted","kind":"scalar","type":"Boolean"},{"name":"termsOfUseId","kind":"scalar","type":"Int"},{"name":"licenseId","kind":"scalar","type":"Int"},{"name":"assetBundleIOS","kind":"scalar","type":"String"},{"name":"assetBundleAndroid","kind":"scalar","type":"String"},{"name":"encryptKey","kind":"scalar","type":"String"},{"name":"outlineUrl","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"termOfUse","kind":"object","type":"TermsOfUse","relationName":"AplicationMasterToTermsOfUse"},{"name":"license","kind":"object","type":"License","relationName":"AplicationMasterToLicense"},{"name":"acsta","kind":"object","type":"AcstaManagement","relationName":"AcstaManagementToAplicationMaster"},{"name":"forcedUpdate","kind":"object","type":"ForcedUpdateManagement","relationName":"AplicationMasterToForcedUpdateManagement"}],"dbName":null},"AcstaManagement":{"fields":[{"name":"id","kind":"scalar","type":"Int"},{"name":"managementName","kind":"scalar","type":"String"},{"name":"acstaName","kind":"scalar","type":"String"},{"name":"applicationId","kind":"scalar","type":"Int"},{"name":"isDeleted","kind":"scalar","type":"Boolean"},{"name":"thumbnailUrl","kind":"scalar","type":"String"},{"name":"scanImageUrl","kind":"scalar","type":"String"},{"name":"acstaBasicInfoId","kind":"scalar","type":"Int"},{"name":"scanOriginX","kind":"scalar","type":"Float"},{"name":"scanOriginY","kind":"scalar","type":"Float"},{"name":"scanWidth","kind":"scalar","type":"Float"},{"name":"scanHeight","kind":"scalar","type":"Float"},{"name":"scanColors","kind":"scalar","type":"String"},{"name":"modeId","kind":"scalar","type":"Int"},{"name":"dateStart","kind":"scalar","type":"DateTime"},{"name":"dateEnd","kind":"scalar","type":"DateTime"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"application","kind":"object","type":"AplicationMaster","relationName":"AcstaManagementToAplicationMaster"},{"name":"performace","kind":"object","type":"PerformaceManagement","relationName":"AcstaManagementToPerformaceManagement"}],"dbName":null},"PerformaceTypeMaster":{"fields":[{"name":"id","kind":"scalar","type":"Int"},{"name":"typeName","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"performances","kind":"object","type":"PerformaceManagement","relationName":"PerformaceManagementToPerformaceTypeMaster"}],"dbName":null},"PerformaceManagement":{"fields":[{"name":"id","kind":"scalar","type":"Int"},{"name":"name","kind":"scalar","type":"String"},{"name":"isDeleted","kind":"scalar","type":"Boolean"},{"name":"performanceTypeMasterId","kind":"scalar","type":"Int"},{"name":"assetBundleIOS","kind":"scalar","type":"String"},{"name":"acstaId","kind":"scalar","type":"Int"},{"name":"assetBundleAndroid","kind":"scalar","type":"String"},{"name":"encryptKey","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"performanceTypeMaster","kind":"object","type":"PerformaceTypeMaster","relationName":"PerformaceManagementToPerformaceTypeMaster"},{"name":"acsta","kind":"object","type":"AcstaManagement","relationName":"AcstaManagementToPerformaceManagement"}],"dbName":null},"TermsOfUse":{"fields":[{"name":"id","kind":"scalar","type":"Int"},{"name":"memo","kind":"scalar","type":"String"},{"name":"version","kind":"scalar","type":"String"},{"name":"content","kind":"scalar","type":"String"},{"name":"publishedDate","kind":"scalar","type":"DateTime"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"applications","kind":"object","type":"AplicationMaster","relationName":"AplicationMasterToTermsOfUse"}],"dbName":null},"License":{"fields":[{"name":"id","kind":"scalar","type":"Int"},{"name":"memo","kind":"scalar","type":"String"},{"name":"version","kind":"scalar","type":"String"},{"name":"content","kind":"scalar","type":"String"},{"name":"publishedDate","kind":"scalar","type":"DateTime"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"applications","kind":"object","type":"AplicationMaster","relationName":"AplicationMasterToLicense"}],"dbName":null},"IdLastestOfRecord":{"fields":[{"name":"id","kind":"scalar","type":"Int"},{"name":"name","kind":"scalar","type":"String"},{"name":"idLastest","kind":"scalar","type":"Int"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"}],"dbName":null},"ForcedUpdateManagement":{"fields":[{"name":"id","kind":"scalar","type":"Int"},{"name":"appMasterId","kind":"scalar","type":"Int"},{"name":"managementName","kind":"scalar","type":"String"},{"name":"operateSystem","kind":"scalar","type":"String"},{"name":"version","kind":"scalar","type":"String"},{"name":"publishedDate","kind":"scalar","type":"DateTime"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"aplicationMaster","kind":"object","type":"AplicationMaster","relationName":"AplicationMasterToForcedUpdateManagement"}],"dbName":null},"BootUpdate":{"fields":[{"name":"id","kind":"scalar","type":"Int"},{"name":"tableName","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"}],"dbName":null}},"enums":{},"types":{}}');
    defineDmmfProperty2(exports.Prisma, config.runtimeDataModel);
    config.engineWasm = {
      getRuntime: () => require_query_engine_bg(),
      getQueryEngineWasmModule: async () => {
        return (await init_wasm_worker_loader().then(() => wasm_worker_loader_exports)).default;
      }
    };
    config.injectableEdgeEnv = () => ({
      parsed: {
        DATABASE_URL: typeof globalThis !== "undefined" && globalThis["DATABASE_URL"] || typeof process !== "undefined" && process.env && process.env.DATABASE_URL || void 0
      }
    });
    if (typeof globalThis !== "undefined" && globalThis["DEBUG"] || typeof process !== "undefined" && process.env && process.env.DEBUG || void 0) {
      Debug3.enable(typeof globalThis !== "undefined" && globalThis["DEBUG"] || typeof process !== "undefined" && process.env && process.env.DEBUG || void 0);
    }
    var PrismaClient2 = getPrismaClient2(config);
    exports.PrismaClient = PrismaClient2;
    Object.assign(exports, Prisma);
  }
});

// ../../node_modules/.prisma/client/default.js
var require_default = __commonJS({
  "../../node_modules/.prisma/client/default.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = { ...require_wasm2() };
  }
});

// ../../node_modules/@prisma/client/default.js
var require_default2 = __commonJS({
  "../../node_modules/@prisma/client/default.js"(exports, module) {
    init_checked_fetch();
    init_modules_watch_stub();
    module.exports = {
      ...require_default()
    };
  }
});

// .wrangler/tmp/bundle-NyGiPh/middleware-loader.entry.ts
init_checked_fetch();
init_modules_watch_stub();

// .wrangler/tmp/bundle-NyGiPh/middleware-insertion-facade.js
init_checked_fetch();
init_modules_watch_stub();

// src/index.ts
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@hono/swagger-ui/dist/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/helper/html/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/utils/html.js
init_checked_fetch();
init_modules_watch_stub();
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw2 = (value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
};
var escapeRe = /[&<>'"]/;
var stringBufferToString = async (buffer) => {
  let str = "";
  const callbacks = [];
  for (let i2 = buffer.length - 1; ; i2--) {
    str += buffer[i2];
    i2--;
    if (i2 < 0) {
      break;
    }
    let r2 = await buffer[i2];
    if (typeof r2 === "object") {
      callbacks.push(...r2.callbacks || []);
    }
    const isEscaped = r2.isEscaped;
    r2 = await (typeof r2 === "object" ? r2.toString() : r2);
    if (typeof r2 === "object") {
      callbacks.push(...r2.callbacks || []);
    }
    if (r2.isEscaped ?? isEscaped) {
      str += r2;
    } else {
      const buf = [str];
      escapeToBuffer(r2, buf);
      str = buf[0];
    }
  }
  return raw2(str, callbacks);
};
var escapeToBuffer = (str, buffer) => {
  const match = str.search(escapeRe);
  if (match === -1) {
    buffer[0] += str;
    return;
  }
  let escape;
  let index;
  let lastIndex = 0;
  for (index = match; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escape = "&quot;";
        break;
      case 39:
        escape = "&#39;";
        break;
      case 38:
        escape = "&amp;";
        break;
      case 60:
        escape = "&lt;";
        break;
      case 62:
        escape = "&gt;";
        break;
      default:
        continue;
    }
    buffer[0] += str.substring(lastIndex, index) + escape;
    lastIndex = index + 1;
  }
  buffer[0] += str.substring(lastIndex, index);
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c2) => c2({ phase, buffer, context }))).then(
    (res) => Promise.all(
      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))
    ).then(() => buffer[0])
  );
  if (preserveCallbacks) {
    return raw2(await resStr, callbacks);
  } else {
    return resStr;
  }
};

// ../../node_modules/hono/dist/helper/html/index.js
var html = (strings, ...values) => {
  const buffer = [""];
  for (let i2 = 0, len = strings.length - 1; i2 < len; i2++) {
    buffer[0] += strings[i2];
    const children = values[i2] instanceof Array ? values[i2].flat(Infinity) : [values[i2]];
    for (let i22 = 0, len2 = children.length; i22 < len2; i22++) {
      const child2 = children[i22];
      if (typeof child2 === "string") {
        escapeToBuffer(child2, buffer);
      } else if (typeof child2 === "number") {
        ;
        buffer[0] += child2;
      } else if (typeof child2 === "boolean" || child2 === null || child2 === void 0) {
        continue;
      } else if (typeof child2 === "object" && child2.isEscaped) {
        if (child2.callbacks) {
          buffer.unshift("", child2);
        } else {
          const tmp = child2.toString();
          if (tmp instanceof Promise) {
            buffer.unshift("", tmp);
          } else {
            buffer[0] += tmp;
          }
        }
      } else if (child2 instanceof Promise) {
        buffer.unshift("", child2);
      } else {
        escapeToBuffer(child2.toString(), buffer);
      }
    }
  }
  buffer[0] += strings[strings.length - 1];
  return buffer.length === 1 ? raw2(buffer[0]) : stringBufferToString(buffer);
};

// ../../node_modules/@hono/swagger-ui/dist/index.js
var RENDER_TYPE = {
  STRING_ARRAY: "string_array",
  STRING: "string",
  JSON_STRING: "json_string",
  RAW: "raw"
};
var RENDER_TYPE_MAP = {
  configUrl: RENDER_TYPE.STRING,
  deepLinking: RENDER_TYPE.RAW,
  presets: RENDER_TYPE.STRING_ARRAY,
  plugins: RENDER_TYPE.STRING_ARRAY,
  spec: RENDER_TYPE.JSON_STRING,
  url: RENDER_TYPE.STRING,
  urls: RENDER_TYPE.JSON_STRING,
  layout: RENDER_TYPE.STRING,
  docExpansion: RENDER_TYPE.STRING,
  maxDisplayedTags: RENDER_TYPE.RAW,
  operationsSorter: RENDER_TYPE.RAW,
  requestInterceptor: RENDER_TYPE.RAW,
  responseInterceptor: RENDER_TYPE.RAW,
  persistAuthorization: RENDER_TYPE.RAW
};
var renderSwaggerUIOptions = (options) => {
  const optionsStrings = Object.entries(options).map(([k2, v2]) => {
    const key = k2;
    if (RENDER_TYPE_MAP[key] === RENDER_TYPE.STRING) {
      return `${key}: '${v2}'`;
    }
    if (RENDER_TYPE_MAP[key] === RENDER_TYPE.STRING_ARRAY) {
      if (!Array.isArray(v2)) {
        return "";
      }
      return `${key}: [${v2.map((ve) => `${ve}`).join(",")}]`;
    }
    if (RENDER_TYPE_MAP[key] === RENDER_TYPE.JSON_STRING) {
      return `${key}: ${JSON.stringify(v2)}`;
    }
    if (RENDER_TYPE_MAP[key] === RENDER_TYPE.RAW) {
      return `${key}: ${v2}`;
    }
    return "";
  }).join(",");
  return optionsStrings;
};
var remoteAssets = ({ version }) => {
  const url = `https://unpkg.com/swagger-ui-dist${version !== void 0 ? `@${version}` : ""}`;
  return {
    css: [`${url}/swagger-ui.css`],
    js: [`${url}/swagger-ui-bundle.js`]
  };
};
var _a;
var SwaggerUI = (options) => {
  const asset = remoteAssets({ version: options?.version });
  delete options.version;
  if (options.manuallySwaggerUIHtml) {
    return options.manuallySwaggerUIHtml(asset);
  }
  const optionsStrings = renderSwaggerUIOptions(options);
  return `
    <div>
      <div id="swagger-ui"></div>
      ${asset.css.map((url) => html`<link rel="stylesheet" href="${url}" />`)}
      ${asset.js.map((url) => html(_a || (_a = __template(['<script src="', '" crossorigin="anonymous"><\/script>'])), url))}
      <script>
        window.onload = () => {
          window.ui = SwaggerUIBundle({
            dom_id: '#swagger-ui',${optionsStrings},
          })
        }
      <\/script>
    </div>
  `;
};
var middleware = (options) => async (c2) => {
  return c2.html(
    /* html */
    `
      <html lang="en">
        <head>
          <meta charset="utf-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <meta name="description" content="SwaggerUI" />
          <title>SwaggerUI</title>
        </head>
        <body>
          ${SwaggerUI(options)}
        </body>
      </html>
    `
  );
};

// ../../node_modules/@hono/zod-openapi/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@asteasolutions/zod-to-openapi/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function isZodType(schema, typeName) {
  var _a2;
  return ((_a2 = schema === null || schema === void 0 ? void 0 : schema._def) === null || _a2 === void 0 ? void 0 : _a2.typeName) === typeName;
}
function isAnyZodType(schema) {
  return "_def" in schema;
}
function preserveMetadataFromModifier(zod, modifier) {
  const zodModifier = zod.ZodType.prototype[modifier];
  zod.ZodType.prototype[modifier] = function(...args) {
    const result = zodModifier.apply(this, args);
    result._def.openapi = this._def.openapi;
    return result;
  };
}
function extendZodWithOpenApi(zod) {
  if (typeof zod.ZodType.prototype.openapi !== "undefined") {
    return;
  }
  zod.ZodType.prototype.openapi = function(refOrOpenapi, metadata7) {
    var _a2, _b, _c, _d, _e, _f;
    const openapi = typeof refOrOpenapi === "string" ? metadata7 : refOrOpenapi;
    const _g = openapi !== null && openapi !== void 0 ? openapi : {}, { param } = _g, restOfOpenApi = __rest(_g, ["param"]);
    const _internal = Object.assign(Object.assign({}, (_a2 = this._def.openapi) === null || _a2 === void 0 ? void 0 : _a2._internal), typeof refOrOpenapi === "string" ? { refId: refOrOpenapi } : void 0);
    const resultMetadata = Object.assign(Object.assign(Object.assign({}, (_b = this._def.openapi) === null || _b === void 0 ? void 0 : _b.metadata), restOfOpenApi), ((_d = (_c = this._def.openapi) === null || _c === void 0 ? void 0 : _c.metadata) === null || _d === void 0 ? void 0 : _d.param) || param ? {
      param: Object.assign(Object.assign({}, (_f = (_e = this._def.openapi) === null || _e === void 0 ? void 0 : _e.metadata) === null || _f === void 0 ? void 0 : _f.param), param)
    } : void 0);
    const result = new this.constructor(Object.assign(Object.assign({}, this._def), { openapi: Object.assign(Object.assign({}, Object.keys(_internal).length > 0 ? { _internal } : void 0), Object.keys(resultMetadata).length > 0 ? { metadata: resultMetadata } : void 0) }));
    if (isZodType(this, "ZodObject")) {
      const originalExtend = this.extend;
      result.extend = function(...args) {
        var _a3, _b2, _c2, _d2, _e2, _f2;
        const extendedResult = originalExtend.apply(this, args);
        extendedResult._def.openapi = {
          _internal: {
            extendedFrom: ((_b2 = (_a3 = this._def.openapi) === null || _a3 === void 0 ? void 0 : _a3._internal) === null || _b2 === void 0 ? void 0 : _b2.refId) ? { refId: (_d2 = (_c2 = this._def.openapi) === null || _c2 === void 0 ? void 0 : _c2._internal) === null || _d2 === void 0 ? void 0 : _d2.refId, schema: this } : (_e2 = this._def.openapi) === null || _e2 === void 0 ? void 0 : _e2._internal.extendedFrom
          },
          metadata: (_f2 = extendedResult._def.openapi) === null || _f2 === void 0 ? void 0 : _f2.metadata
        };
        return extendedResult;
      };
    }
    return result;
  };
  preserveMetadataFromModifier(zod, "optional");
  preserveMetadataFromModifier(zod, "nullable");
  preserveMetadataFromModifier(zod, "default");
  preserveMetadataFromModifier(zod, "transform");
  preserveMetadataFromModifier(zod, "refine");
  const zodDeepPartial = zod.ZodObject.prototype.deepPartial;
  zod.ZodObject.prototype.deepPartial = function() {
    const initialShape = this._def.shape();
    const result = zodDeepPartial.apply(this);
    const resultShape = result._def.shape();
    Object.entries(resultShape).forEach(([key, value]) => {
      var _a2, _b;
      value._def.openapi = (_b = (_a2 = initialShape[key]) === null || _a2 === void 0 ? void 0 : _a2._def) === null || _b === void 0 ? void 0 : _b.openapi;
    });
    result._def.openapi = void 0;
    return result;
  };
  const zodPick = zod.ZodObject.prototype.pick;
  zod.ZodObject.prototype.pick = function(...args) {
    const result = zodPick.apply(this, args);
    result._def.openapi = void 0;
    return result;
  };
  const zodOmit = zod.ZodObject.prototype.omit;
  zod.ZodObject.prototype.omit = function(...args) {
    const result = zodOmit.apply(this, args);
    result._def.openapi = void 0;
    return result;
  };
}
function isEqual(x2, y2) {
  if (x2 === null || x2 === void 0 || y2 === null || y2 === void 0) {
    return x2 === y2;
  }
  if (x2 === y2 || x2.valueOf() === y2.valueOf()) {
    return true;
  }
  if (Array.isArray(x2)) {
    if (!Array.isArray(y2)) {
      return false;
    }
    if (x2.length !== y2.length) {
      return false;
    }
  }
  if (!(x2 instanceof Object) || !(y2 instanceof Object)) {
    return false;
  }
  const keysX = Object.keys(x2);
  return Object.keys(y2).every((keyY) => keysX.indexOf(keyY) !== -1) && keysX.every((key) => isEqual(x2[key], y2[key]));
}
var ObjectSet = class {
  constructor() {
    this.buckets = /* @__PURE__ */ new Map();
  }
  put(value) {
    const hashCode = this.hashCodeOf(value);
    const itemsByCode = this.buckets.get(hashCode);
    if (!itemsByCode) {
      this.buckets.set(hashCode, [value]);
      return;
    }
    const alreadyHasItem = itemsByCode.some((_) => isEqual(_, value));
    if (!alreadyHasItem) {
      itemsByCode.push(value);
    }
  }
  contains(value) {
    const hashCode = this.hashCodeOf(value);
    const itemsByCode = this.buckets.get(hashCode);
    if (!itemsByCode) {
      return false;
    }
    return itemsByCode.some((_) => isEqual(_, value));
  }
  values() {
    return [...this.buckets.values()].flat();
  }
  stats() {
    let totalBuckets = 0;
    let totalValues = 0;
    let collisions = 0;
    for (const bucket of this.buckets.values()) {
      totalBuckets += 1;
      totalValues += bucket.length;
      if (bucket.length > 1) {
        collisions += 1;
      }
    }
    const hashEffectiveness = totalBuckets / totalValues;
    return { totalBuckets, collisions, totalValues, hashEffectiveness };
  }
  hashCodeOf(object) {
    let hashCode = 0;
    if (Array.isArray(object)) {
      for (let i2 = 0; i2 < object.length; i2++) {
        hashCode ^= this.hashCodeOf(object[i2]) * i2;
      }
      return hashCode;
    }
    if (typeof object === "string") {
      for (let i2 = 0; i2 < object.length; i2++) {
        hashCode ^= object.charCodeAt(i2) * i2;
      }
      return hashCode;
    }
    if (typeof object === "number") {
      return object;
    }
    if (typeof object === "object") {
      for (const [key, value] of Object.entries(object)) {
        hashCode ^= this.hashCodeOf(key) + this.hashCodeOf(value !== null && value !== void 0 ? value : "");
      }
    }
    return hashCode;
  }
};
function isNil(value) {
  return value === null || value === void 0;
}
function mapValues(object, mapper) {
  const result = {};
  Object.entries(object).forEach(([key, value]) => {
    result[key] = mapper(value);
  });
  return result;
}
function omit(object, keys) {
  const result = {};
  Object.entries(object).forEach(([key, value]) => {
    if (!keys.some((keyToOmit) => keyToOmit === key)) {
      result[key] = value;
    }
  });
  return result;
}
function omitBy(object, predicate) {
  const result = {};
  Object.entries(object).forEach(([key, value]) => {
    if (!predicate(value, key)) {
      result[key] = value;
    }
  });
  return result;
}
function compact(arr) {
  return arr.filter((elem) => !isNil(elem));
}
var objectEquals = isEqual;
function uniq(values) {
  const set = new ObjectSet();
  values.forEach((value) => set.put(value));
  return [...set.values()];
}
function isString(val2) {
  return typeof val2 === "string";
}
var OpenAPIRegistry = class {
  constructor(parents) {
    this.parents = parents;
    this._definitions = [];
  }
  get definitions() {
    var _a2, _b;
    const parentDefinitions = (_b = (_a2 = this.parents) === null || _a2 === void 0 ? void 0 : _a2.flatMap((par) => par.definitions)) !== null && _b !== void 0 ? _b : [];
    return [...parentDefinitions, ...this._definitions];
  }
  /**
   * Registers a new component schema under /components/schemas/${name}
   */
  register(refId, zodSchema) {
    const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
    this._definitions.push({ type: "schema", schema: schemaWithRefId });
    return schemaWithRefId;
  }
  /**
   * Registers a new parameter schema under /components/parameters/${name}
   */
  registerParameter(refId, zodSchema) {
    var _a2, _b, _c;
    const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
    const currentMetadata = (_a2 = schemaWithRefId._def.openapi) === null || _a2 === void 0 ? void 0 : _a2.metadata;
    const schemaWithMetadata = schemaWithRefId.openapi(Object.assign(Object.assign({}, currentMetadata), { param: Object.assign(Object.assign({}, currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param), { name: (_c = (_b = currentMetadata === null || currentMetadata === void 0 ? void 0 : currentMetadata.param) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : refId }) }));
    this._definitions.push({
      type: "parameter",
      schema: schemaWithMetadata
    });
    return schemaWithMetadata;
  }
  /**
   * Registers a new path that would be generated under paths:
   */
  registerPath(route) {
    this._definitions.push({
      type: "route",
      route
    });
  }
  /**
   * Registers a new webhook that would be generated under webhooks:
   */
  registerWebhook(webhook) {
    this._definitions.push({
      type: "webhook",
      webhook
    });
  }
  /**
   * Registers a raw OpenAPI component. Use this if you have a simple object instead of a Zod schema.
   *
   * @param type The component type, e.g. `schemas`, `responses`, `securitySchemes`, etc.
   * @param name The name of the object, it is the key under the component
   *             type in the resulting OpenAPI document
   * @param component The actual object to put there
   */
  registerComponent(type, name2, component) {
    this._definitions.push({
      type: "component",
      componentType: type,
      name: name2,
      component
    });
    return {
      name: name2,
      ref: { $ref: `#/components/${type}/${name2}` }
    };
  }
  schemaWithRefId(refId, zodSchema) {
    return zodSchema.openapi(refId);
  }
};
var ZodToOpenAPIError = class {
  constructor(message) {
    this.message = message;
  }
};
var ConflictError = class extends ZodToOpenAPIError {
  constructor(message, data) {
    super(message);
    this.data = data;
  }
};
var MissingParameterDataError = class extends ZodToOpenAPIError {
  constructor(data) {
    super(`Missing parameter data, please specify \`${data.missingField}\` and other OpenAPI parameter props using the \`param\` field of \`ZodSchema.openapi\``);
    this.data = data;
  }
};
function enhanceMissingParametersError(action, paramsToAdd) {
  try {
    return action();
  } catch (error) {
    if (error instanceof MissingParameterDataError) {
      throw new MissingParameterDataError(Object.assign(Object.assign({}, error.data), paramsToAdd));
    }
    throw error;
  }
}
var UnknownZodTypeError = class extends ZodToOpenAPIError {
  constructor(data) {
    super(`Unknown zod object type, please specify \`type\` and other OpenAPI props using \`ZodSchema.openapi\`.`);
    this.data = data;
  }
};
var Metadata = class {
  static getMetadata(zodSchema) {
    var _a2;
    const innerSchema = this.unwrapChained(zodSchema);
    const metadata7 = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
    const zodDescription = (_a2 = zodSchema.description) !== null && _a2 !== void 0 ? _a2 : innerSchema.description;
    return {
      _internal: metadata7 === null || metadata7 === void 0 ? void 0 : metadata7._internal,
      metadata: Object.assign({ description: zodDescription }, metadata7 === null || metadata7 === void 0 ? void 0 : metadata7.metadata)
    };
  }
  static getInternalMetadata(zodSchema) {
    const innerSchema = this.unwrapChained(zodSchema);
    const openapi = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
    return openapi === null || openapi === void 0 ? void 0 : openapi._internal;
  }
  static getParamMetadata(zodSchema) {
    var _a2, _b;
    const innerSchema = this.unwrapChained(zodSchema);
    const metadata7 = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
    const zodDescription = (_a2 = zodSchema.description) !== null && _a2 !== void 0 ? _a2 : innerSchema.description;
    return {
      _internal: metadata7 === null || metadata7 === void 0 ? void 0 : metadata7._internal,
      metadata: Object.assign(Object.assign({}, metadata7 === null || metadata7 === void 0 ? void 0 : metadata7.metadata), {
        // A description provided from .openapi() should be taken with higher precedence
        param: Object.assign({ description: zodDescription }, (_b = metadata7 === null || metadata7 === void 0 ? void 0 : metadata7.metadata) === null || _b === void 0 ? void 0 : _b.param)
      })
    };
  }
  /**
   * A method that omits all custom keys added to the regular OpenAPI
   * metadata properties
   */
  static buildSchemaMetadata(metadata7) {
    return omitBy(omit(metadata7, ["param"]), isNil);
  }
  static buildParameterMetadata(metadata7) {
    return omitBy(metadata7, isNil);
  }
  static applySchemaMetadata(initialData, metadata7) {
    return omitBy(Object.assign(Object.assign({}, initialData), this.buildSchemaMetadata(metadata7)), isNil);
  }
  static getRefId(zodSchema) {
    var _a2;
    return (_a2 = this.getInternalMetadata(zodSchema)) === null || _a2 === void 0 ? void 0 : _a2.refId;
  }
  static unwrapChained(schema) {
    return this.unwrapUntil(schema);
  }
  static getDefaultValue(zodSchema) {
    const unwrapped = this.unwrapUntil(zodSchema, "ZodDefault");
    return unwrapped === null || unwrapped === void 0 ? void 0 : unwrapped._def.defaultValue();
  }
  static unwrapUntil(schema, typeName) {
    if (typeName && isZodType(schema, typeName)) {
      return schema;
    }
    if (isZodType(schema, "ZodOptional") || isZodType(schema, "ZodNullable") || isZodType(schema, "ZodBranded")) {
      return this.unwrapUntil(schema.unwrap(), typeName);
    }
    if (isZodType(schema, "ZodDefault") || isZodType(schema, "ZodReadonly")) {
      return this.unwrapUntil(schema._def.innerType, typeName);
    }
    if (isZodType(schema, "ZodEffects")) {
      return this.unwrapUntil(schema._def.schema, typeName);
    }
    if (isZodType(schema, "ZodPipeline")) {
      return this.unwrapUntil(schema._def.in, typeName);
    }
    return typeName ? void 0 : schema;
  }
  static isOptionalSchema(zodSchema) {
    if (isZodType(zodSchema, "ZodEffects")) {
      return this.isOptionalSchema(zodSchema._def.schema);
    }
    return zodSchema.isOptional();
  }
};
var ArrayTransformer = class {
  transform(zodSchema, mapNullableType, mapItems) {
    var _a2, _b;
    const itemType = zodSchema._def.type;
    return Object.assign(Object.assign({}, mapNullableType("array")), { items: mapItems(itemType), minItems: (_a2 = zodSchema._def.minLength) === null || _a2 === void 0 ? void 0 : _a2.value, maxItems: (_b = zodSchema._def.maxLength) === null || _b === void 0 ? void 0 : _b.value });
  }
};
var BigIntTransformer = class {
  transform(mapNullableType) {
    return Object.assign(Object.assign({}, mapNullableType("string")), { pattern: `^d+$` });
  }
};
var DiscriminatedUnionTransformer = class {
  transform(zodSchema, isNullable, mapNullableOfArray, mapItem, generateSchemaRef) {
    const options = [...zodSchema.options.values()];
    const optionSchema = options.map(mapItem);
    if (isNullable) {
      return {
        oneOf: mapNullableOfArray(optionSchema, isNullable)
      };
    }
    return {
      oneOf: optionSchema,
      discriminator: this.mapDiscriminator(options, zodSchema.discriminator, generateSchemaRef)
    };
  }
  mapDiscriminator(zodObjects, discriminator, generateSchemaRef) {
    if (zodObjects.some((obj) => Metadata.getRefId(obj) === void 0)) {
      return void 0;
    }
    const mapping = {};
    zodObjects.forEach((obj) => {
      var _a2;
      const refId = Metadata.getRefId(obj);
      const value = (_a2 = obj.shape) === null || _a2 === void 0 ? void 0 : _a2[discriminator];
      if (isZodType(value, "ZodEnum") || isZodType(value, "ZodNativeEnum")) {
        const keys = Object.values(value.enum).filter(isString);
        keys.forEach((enumValue) => {
          mapping[enumValue] = generateSchemaRef(refId);
        });
        return;
      }
      const literalValue = value === null || value === void 0 ? void 0 : value._def.value;
      if (typeof literalValue !== "string") {
        throw new Error(`Discriminator ${discriminator} could not be found in one of the values of a discriminated union`);
      }
      mapping[literalValue] = generateSchemaRef(refId);
    });
    return {
      propertyName: discriminator,
      mapping
    };
  }
};
var EnumTransformer = class {
  transform(zodSchema, mapNullableType) {
    return Object.assign(Object.assign({}, mapNullableType("string")), { enum: zodSchema._def.values });
  }
};
var IntersectionTransformer = class {
  transform(zodSchema, isNullable, mapNullableOfArray, mapItem) {
    const subtypes = this.flattenIntersectionTypes(zodSchema);
    const allOfSchema = {
      allOf: subtypes.map(mapItem)
    };
    if (isNullable) {
      return {
        anyOf: mapNullableOfArray([allOfSchema], isNullable)
      };
    }
    return allOfSchema;
  }
  flattenIntersectionTypes(schema) {
    if (!isZodType(schema, "ZodIntersection")) {
      return [schema];
    }
    const leftSubTypes = this.flattenIntersectionTypes(schema._def.left);
    const rightSubTypes = this.flattenIntersectionTypes(schema._def.right);
    return [...leftSubTypes, ...rightSubTypes];
  }
};
var LiteralTransformer = class {
  transform(zodSchema, mapNullableType) {
    return Object.assign(Object.assign({}, mapNullableType(typeof zodSchema._def.value)), { enum: [zodSchema._def.value] });
  }
};
function enumInfo(enumObject) {
  const keysExceptReverseMappings = Object.keys(enumObject).filter((key) => typeof enumObject[enumObject[key]] !== "number");
  const values = keysExceptReverseMappings.map((key) => enumObject[key]);
  const numericCount = values.filter((_) => typeof _ === "number").length;
  const type = numericCount === 0 ? "string" : numericCount === values.length ? "numeric" : "mixed";
  return { values, type };
}
var NativeEnumTransformer = class {
  transform(zodSchema, mapNullableType) {
    const { type, values } = enumInfo(zodSchema._def.values);
    if (type === "mixed") {
      throw new ZodToOpenAPIError("Enum has mixed string and number values, please specify the OpenAPI type manually");
    }
    return Object.assign(Object.assign({}, mapNullableType(type === "numeric" ? "integer" : "string")), { enum: values });
  }
};
var NumberTransformer = class {
  transform(zodSchema, mapNullableType, getNumberChecks) {
    return Object.assign(Object.assign({}, mapNullableType(zodSchema.isInt ? "integer" : "number")), getNumberChecks(zodSchema._def.checks));
  }
};
var ObjectTransformer = class {
  transform(zodSchema, defaultValue, mapNullableType, mapItem) {
    var _a2;
    const extendedFrom = (_a2 = Metadata.getInternalMetadata(zodSchema)) === null || _a2 === void 0 ? void 0 : _a2.extendedFrom;
    const required = this.requiredKeysOf(zodSchema);
    const properties = mapValues(zodSchema._def.shape(), mapItem);
    if (!extendedFrom) {
      return Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType("object")), { properties, default: defaultValue }), required.length > 0 ? { required } : {}), this.generateAdditionalProperties(zodSchema, mapItem));
    }
    const parent = extendedFrom.schema;
    mapItem(parent);
    const keysRequiredByParent = this.requiredKeysOf(parent);
    const propsOfParent = mapValues(parent === null || parent === void 0 ? void 0 : parent._def.shape(), mapItem);
    const propertiesToAdd = Object.fromEntries(Object.entries(properties).filter(([key, type]) => {
      return !objectEquals(propsOfParent[key], type);
    }));
    const additionallyRequired = required.filter((prop) => !keysRequiredByParent.includes(prop));
    const objectData = Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType("object")), { default: defaultValue, properties: propertiesToAdd }), additionallyRequired.length > 0 ? { required: additionallyRequired } : {}), this.generateAdditionalProperties(zodSchema, mapItem));
    return {
      allOf: [
        { $ref: `#/components/schemas/${extendedFrom.refId}` },
        objectData
      ]
    };
  }
  generateAdditionalProperties(zodSchema, mapItem) {
    const unknownKeysOption = zodSchema._def.unknownKeys;
    const catchallSchema = zodSchema._def.catchall;
    if (isZodType(catchallSchema, "ZodNever")) {
      if (unknownKeysOption === "strict") {
        return { additionalProperties: false };
      }
      return {};
    }
    return { additionalProperties: mapItem(catchallSchema) };
  }
  requiredKeysOf(objectSchema) {
    return Object.entries(objectSchema._def.shape()).filter(([_key, type]) => !Metadata.isOptionalSchema(type)).map(([key, _type]) => key);
  }
};
var RecordTransformer = class {
  transform(zodSchema, mapNullableType, mapItem) {
    const propertiesType = zodSchema._def.valueType;
    const keyType = zodSchema._def.keyType;
    const propertiesSchema = mapItem(propertiesType);
    if (isZodType(keyType, "ZodEnum") || isZodType(keyType, "ZodNativeEnum")) {
      const keys = Object.values(keyType.enum).filter(isString);
      const properties = keys.reduce((acc, curr) => Object.assign(Object.assign({}, acc), { [curr]: propertiesSchema }), {});
      return Object.assign(Object.assign({}, mapNullableType("object")), { properties });
    }
    return Object.assign(Object.assign({}, mapNullableType("object")), { additionalProperties: propertiesSchema });
  }
};
var StringTransformer = class {
  transform(zodSchema, mapNullableType) {
    var _a2, _b, _c;
    const regexCheck = this.getZodStringCheck(zodSchema, "regex");
    const length = (_a2 = this.getZodStringCheck(zodSchema, "length")) === null || _a2 === void 0 ? void 0 : _a2.value;
    const maxLength = Number.isFinite(zodSchema.minLength) ? (_b = zodSchema.minLength) !== null && _b !== void 0 ? _b : void 0 : void 0;
    const minLength = Number.isFinite(zodSchema.maxLength) ? (_c = zodSchema.maxLength) !== null && _c !== void 0 ? _c : void 0 : void 0;
    return Object.assign(Object.assign({}, mapNullableType("string")), {
      // FIXME: https://github.com/colinhacks/zod/commit/d78047e9f44596a96d637abb0ce209cd2732d88c
      minLength: length !== null && length !== void 0 ? length : maxLength,
      maxLength: length !== null && length !== void 0 ? length : minLength,
      format: this.mapStringFormat(zodSchema),
      pattern: regexCheck === null || regexCheck === void 0 ? void 0 : regexCheck.regex.source
    });
  }
  /**
   * Attempts to map Zod strings to known formats
   * https://json-schema.org/understanding-json-schema/reference/string.html#built-in-formats
   */
  mapStringFormat(zodString) {
    if (zodString.isUUID) {
      return "uuid";
    }
    if (zodString.isEmail) {
      return "email";
    }
    if (zodString.isURL) {
      return "uri";
    }
    if (zodString.isDatetime) {
      return "date-time";
    }
    return void 0;
  }
  getZodStringCheck(zodString, kind) {
    return zodString._def.checks.find((check) => {
      return check.kind === kind;
    });
  }
};
var TupleTransformer = class {
  constructor(versionSpecifics) {
    this.versionSpecifics = versionSpecifics;
  }
  transform(zodSchema, mapNullableType, mapItem) {
    const { items } = zodSchema._def;
    const schemas = items.map(mapItem);
    return Object.assign(Object.assign({}, mapNullableType("array")), this.versionSpecifics.mapTupleItems(schemas));
  }
};
var UnionTransformer = class {
  transform(zodSchema, mapNullableOfArray, mapItem) {
    const options = this.flattenUnionTypes(zodSchema);
    const schemas = options.map((schema) => {
      const optionToGenerate = this.unwrapNullable(schema);
      return mapItem(optionToGenerate);
    });
    return {
      anyOf: mapNullableOfArray(schemas)
    };
  }
  flattenUnionTypes(schema) {
    if (!isZodType(schema, "ZodUnion")) {
      return [schema];
    }
    const options = schema._def.options;
    return options.flatMap((option) => this.flattenUnionTypes(option));
  }
  unwrapNullable(schema) {
    if (isZodType(schema, "ZodNullable")) {
      return this.unwrapNullable(schema.unwrap());
    }
    return schema;
  }
};
var OpenApiTransformer = class {
  constructor(versionSpecifics) {
    this.versionSpecifics = versionSpecifics;
    this.objectTransformer = new ObjectTransformer();
    this.stringTransformer = new StringTransformer();
    this.numberTransformer = new NumberTransformer();
    this.bigIntTransformer = new BigIntTransformer();
    this.literalTransformer = new LiteralTransformer();
    this.enumTransformer = new EnumTransformer();
    this.nativeEnumTransformer = new NativeEnumTransformer();
    this.arrayTransformer = new ArrayTransformer();
    this.unionTransformer = new UnionTransformer();
    this.discriminatedUnionTransformer = new DiscriminatedUnionTransformer();
    this.intersectionTransformer = new IntersectionTransformer();
    this.recordTransformer = new RecordTransformer();
    this.tupleTransformer = new TupleTransformer(versionSpecifics);
  }
  transform(zodSchema, isNullable, mapItem, generateSchemaRef, defaultValue) {
    if (isZodType(zodSchema, "ZodNull")) {
      return this.versionSpecifics.nullType;
    }
    if (isZodType(zodSchema, "ZodUnknown") || isZodType(zodSchema, "ZodAny")) {
      return this.versionSpecifics.mapNullableType(void 0, isNullable);
    }
    if (isZodType(zodSchema, "ZodObject")) {
      return this.objectTransformer.transform(
        zodSchema,
        defaultValue,
        // verified on TS level from input
        // verified on TS level from input
        (_) => this.versionSpecifics.mapNullableType(_, isNullable),
        mapItem
      );
    }
    const schema = this.transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef);
    return Object.assign(Object.assign({}, schema), { default: defaultValue });
  }
  transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef) {
    if (isZodType(zodSchema, "ZodUnknown") || isZodType(zodSchema, "ZodAny")) {
      return this.versionSpecifics.mapNullableType(void 0, isNullable);
    }
    if (isZodType(zodSchema, "ZodString")) {
      return this.stringTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodNumber")) {
      return this.numberTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable), (_) => this.versionSpecifics.getNumberChecks(_));
    }
    if (isZodType(zodSchema, "ZodBigInt")) {
      return this.bigIntTransformer.transform((schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodBoolean")) {
      return this.versionSpecifics.mapNullableType("boolean", isNullable);
    }
    if (isZodType(zodSchema, "ZodLiteral")) {
      return this.literalTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodEnum")) {
      return this.enumTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodNativeEnum")) {
      return this.nativeEnumTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodArray")) {
      return this.arrayTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodTuple")) {
      return this.tupleTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodUnion")) {
      return this.unionTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodDiscriminatedUnion")) {
      return this.discriminatedUnionTransformer.transform(zodSchema, isNullable, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem, generateSchemaRef);
    }
    if (isZodType(zodSchema, "ZodIntersection")) {
      return this.intersectionTransformer.transform(zodSchema, isNullable, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodRecord")) {
      return this.recordTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodDate")) {
      return this.versionSpecifics.mapNullableType("string", isNullable);
    }
    const refId = Metadata.getRefId(zodSchema);
    throw new UnknownZodTypeError({
      currentSchema: zodSchema._def,
      schemaName: refId
    });
  }
};
var OpenAPIGenerator = class {
  constructor(definitions, versionSpecifics) {
    this.definitions = definitions;
    this.versionSpecifics = versionSpecifics;
    this.schemaRefs = {};
    this.paramRefs = {};
    this.pathRefs = {};
    this.rawComponents = [];
    this.openApiTransformer = new OpenApiTransformer(versionSpecifics);
    this.sortDefinitions();
  }
  generateDocumentData() {
    this.definitions.forEach((definition) => this.generateSingle(definition));
    return {
      components: this.buildComponents(),
      paths: this.pathRefs
    };
  }
  generateComponents() {
    this.definitions.forEach((definition) => this.generateSingle(definition));
    return {
      components: this.buildComponents()
    };
  }
  buildComponents() {
    var _a2, _b;
    const rawComponents = {};
    this.rawComponents.forEach(({ componentType, name: name2, component }) => {
      var _a3;
      (_a3 = rawComponents[componentType]) !== null && _a3 !== void 0 ? _a3 : rawComponents[componentType] = {};
      rawComponents[componentType][name2] = component;
    });
    return Object.assign(Object.assign({}, rawComponents), { schemas: Object.assign(Object.assign({}, (_a2 = rawComponents.schemas) !== null && _a2 !== void 0 ? _a2 : {}), this.schemaRefs), parameters: Object.assign(Object.assign({}, (_b = rawComponents.parameters) !== null && _b !== void 0 ? _b : {}), this.paramRefs) });
  }
  sortDefinitions() {
    const generationOrder = [
      "schema",
      "parameter",
      "component",
      "route"
    ];
    this.definitions.sort((left, right) => {
      if (!("type" in left)) {
        if (!("type" in right)) {
          return 0;
        }
        return -1;
      }
      if (!("type" in right)) {
        return 1;
      }
      const leftIndex = generationOrder.findIndex((type) => type === left.type);
      const rightIndex = generationOrder.findIndex((type) => type === right.type);
      return leftIndex - rightIndex;
    });
  }
  generateSingle(definition) {
    if (!("type" in definition)) {
      this.generateSchemaWithRef(definition);
      return;
    }
    switch (definition.type) {
      case "parameter":
        this.generateParameterDefinition(definition.schema);
        return;
      case "schema":
        this.generateSchemaWithRef(definition.schema);
        return;
      case "route":
        this.generateSingleRoute(definition.route);
        return;
      case "component":
        this.rawComponents.push(definition);
        return;
    }
  }
  generateParameterDefinition(zodSchema) {
    const refId = Metadata.getRefId(zodSchema);
    const result = this.generateParameter(zodSchema);
    if (refId) {
      this.paramRefs[refId] = result;
    }
    return result;
  }
  getParameterRef(schemaMetadata, external) {
    var _a2, _b, _c, _d, _e;
    const parameterMetadata = (_a2 = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata.metadata) === null || _a2 === void 0 ? void 0 : _a2.param;
    const existingRef = ((_b = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _b === void 0 ? void 0 : _b.refId) ? this.paramRefs[(_c = schemaMetadata._internal) === null || _c === void 0 ? void 0 : _c.refId] : void 0;
    if (!((_d = schemaMetadata === null || schemaMetadata === void 0 ? void 0 : schemaMetadata._internal) === null || _d === void 0 ? void 0 : _d.refId) || !existingRef) {
      return void 0;
    }
    if (parameterMetadata && existingRef.in !== parameterMetadata.in || (external === null || external === void 0 ? void 0 : external.in) && existingRef.in !== external.in) {
      throw new ConflictError(`Conflicting location for parameter ${existingRef.name}`, {
        key: "in",
        values: compact([
          existingRef.in,
          external === null || external === void 0 ? void 0 : external.in,
          parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in
        ])
      });
    }
    if (parameterMetadata && existingRef.name !== parameterMetadata.name || (external === null || external === void 0 ? void 0 : external.name) && existingRef.name !== (external === null || external === void 0 ? void 0 : external.name)) {
      throw new ConflictError(`Conflicting names for parameter`, {
        key: "name",
        values: compact([
          existingRef.name,
          external === null || external === void 0 ? void 0 : external.name,
          parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.name
        ])
      });
    }
    return {
      $ref: `#/components/parameters/${(_e = schemaMetadata._internal) === null || _e === void 0 ? void 0 : _e.refId}`
    };
  }
  generateInlineParameters(zodSchema, location) {
    var _a2;
    const metadata7 = Metadata.getMetadata(zodSchema);
    const parameterMetadata = (_a2 = metadata7 === null || metadata7 === void 0 ? void 0 : metadata7.metadata) === null || _a2 === void 0 ? void 0 : _a2.param;
    const referencedSchema = this.getParameterRef(metadata7, { in: location });
    if (referencedSchema) {
      return [referencedSchema];
    }
    if (isZodType(zodSchema, "ZodObject")) {
      const propTypes = zodSchema._def.shape();
      const parameters = Object.entries(propTypes).map(([key, schema]) => {
        var _a3, _b;
        const innerMetadata = Metadata.getMetadata(schema);
        const referencedSchema2 = this.getParameterRef(innerMetadata, {
          in: location,
          name: key
        });
        if (referencedSchema2) {
          return referencedSchema2;
        }
        const innerParameterMetadata = (_a3 = innerMetadata === null || innerMetadata === void 0 ? void 0 : innerMetadata.metadata) === null || _a3 === void 0 ? void 0 : _a3.param;
        if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.name) && innerParameterMetadata.name !== key) {
          throw new ConflictError(`Conflicting names for parameter`, {
            key: "name",
            values: [key, innerParameterMetadata.name]
          });
        }
        if ((innerParameterMetadata === null || innerParameterMetadata === void 0 ? void 0 : innerParameterMetadata.in) && innerParameterMetadata.in !== location) {
          throw new ConflictError(`Conflicting location for parameter ${(_b = innerParameterMetadata.name) !== null && _b !== void 0 ? _b : key}`, {
            key: "in",
            values: [location, innerParameterMetadata.in]
          });
        }
        return this.generateParameter(schema.openapi({ param: { name: key, in: location } }));
      });
      return parameters;
    }
    if ((parameterMetadata === null || parameterMetadata === void 0 ? void 0 : parameterMetadata.in) && parameterMetadata.in !== location) {
      throw new ConflictError(`Conflicting location for parameter ${parameterMetadata.name}`, {
        key: "in",
        values: [location, parameterMetadata.in]
      });
    }
    return [
      this.generateParameter(zodSchema.openapi({ param: { in: location } }))
    ];
  }
  generateSimpleParameter(zodSchema) {
    var _a2;
    const metadata7 = Metadata.getParamMetadata(zodSchema);
    const paramMetadata = (_a2 = metadata7 === null || metadata7 === void 0 ? void 0 : metadata7.metadata) === null || _a2 === void 0 ? void 0 : _a2.param;
    const required = !Metadata.isOptionalSchema(zodSchema) && !zodSchema.isNullable();
    const schema = this.generateSchemaWithRef(zodSchema);
    return Object.assign({
      schema,
      required
    }, paramMetadata ? Metadata.buildParameterMetadata(paramMetadata) : {});
  }
  generateParameter(zodSchema) {
    var _a2;
    const metadata7 = Metadata.getMetadata(zodSchema);
    const paramMetadata = (_a2 = metadata7 === null || metadata7 === void 0 ? void 0 : metadata7.metadata) === null || _a2 === void 0 ? void 0 : _a2.param;
    const paramName = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.name;
    const paramLocation = paramMetadata === null || paramMetadata === void 0 ? void 0 : paramMetadata.in;
    if (!paramName) {
      throw new MissingParameterDataError({ missingField: "name" });
    }
    if (!paramLocation) {
      throw new MissingParameterDataError({
        missingField: "in",
        paramName
      });
    }
    const baseParameter = this.generateSimpleParameter(zodSchema);
    return Object.assign(Object.assign({}, baseParameter), { in: paramLocation, name: paramName });
  }
  generateSchemaWithMetadata(zodSchema) {
    var _a2;
    const innerSchema = Metadata.unwrapChained(zodSchema);
    const metadata7 = Metadata.getMetadata(zodSchema);
    const defaultValue = Metadata.getDefaultValue(zodSchema);
    const result = ((_a2 = metadata7 === null || metadata7 === void 0 ? void 0 : metadata7.metadata) === null || _a2 === void 0 ? void 0 : _a2.type) ? { type: metadata7 === null || metadata7 === void 0 ? void 0 : metadata7.metadata.type } : this.toOpenAPISchema(innerSchema, zodSchema.isNullable(), defaultValue);
    return (metadata7 === null || metadata7 === void 0 ? void 0 : metadata7.metadata) ? Metadata.applySchemaMetadata(result, metadata7.metadata) : omitBy(result, isNil);
  }
  /**
   * Same as above but applies nullable
   */
  constructReferencedOpenAPISchema(zodSchema) {
    var _a2;
    const metadata7 = Metadata.getMetadata(zodSchema);
    const innerSchema = Metadata.unwrapChained(zodSchema);
    const defaultValue = Metadata.getDefaultValue(zodSchema);
    const isNullableSchema = zodSchema.isNullable();
    if ((_a2 = metadata7 === null || metadata7 === void 0 ? void 0 : metadata7.metadata) === null || _a2 === void 0 ? void 0 : _a2.type) {
      return this.versionSpecifics.mapNullableType(metadata7.metadata.type, isNullableSchema);
    }
    return this.toOpenAPISchema(innerSchema, isNullableSchema, defaultValue);
  }
  /**
   * Generates an OpenAPI SchemaObject or a ReferenceObject with all the provided metadata applied
   */
  generateSimpleSchema(zodSchema) {
    var _a2;
    const metadata7 = Metadata.getMetadata(zodSchema);
    const refId = Metadata.getRefId(zodSchema);
    if (!refId || !this.schemaRefs[refId]) {
      return this.generateSchemaWithMetadata(zodSchema);
    }
    const schemaRef = this.schemaRefs[refId];
    const referenceObject = {
      $ref: this.generateSchemaRef(refId)
    };
    const newMetadata = omitBy(Metadata.buildSchemaMetadata((_a2 = metadata7 === null || metadata7 === void 0 ? void 0 : metadata7.metadata) !== null && _a2 !== void 0 ? _a2 : {}), (value, key) => value === void 0 || objectEquals(value, schemaRef[key]));
    if (newMetadata.type) {
      return {
        allOf: [referenceObject, newMetadata]
      };
    }
    const newSchemaMetadata = omitBy(this.constructReferencedOpenAPISchema(zodSchema), (value, key) => value === void 0 || objectEquals(value, schemaRef[key]));
    const appliedMetadata = Metadata.applySchemaMetadata(newSchemaMetadata, newMetadata);
    if (Object.keys(appliedMetadata).length > 0) {
      return {
        allOf: [referenceObject, appliedMetadata]
      };
    }
    return referenceObject;
  }
  /**
   * Same as `generateSchema` but if the new schema is added into the
   * referenced schemas, it would return a ReferenceObject and not the
   * whole result.
   *
   * Should be used for nested objects, arrays, etc.
   */
  generateSchemaWithRef(zodSchema) {
    const refId = Metadata.getRefId(zodSchema);
    const result = this.generateSimpleSchema(zodSchema);
    if (refId && this.schemaRefs[refId] === void 0) {
      this.schemaRefs[refId] = result;
      return { $ref: this.generateSchemaRef(refId) };
    }
    return result;
  }
  generateSchemaRef(refId) {
    return `#/components/schemas/${refId}`;
  }
  getRequestBody(requestBody) {
    if (!requestBody) {
      return;
    }
    const { content } = requestBody, rest = __rest(requestBody, ["content"]);
    const requestBodyContent = this.getBodyContent(content);
    return Object.assign(Object.assign({}, rest), { content: requestBodyContent });
  }
  getParameters(request) {
    if (!request) {
      return [];
    }
    const { headers } = request;
    const query = this.cleanParameter(request.query);
    const params = this.cleanParameter(request.params);
    const cookies = this.cleanParameter(request.cookies);
    const queryParameters = enhanceMissingParametersError(() => query ? this.generateInlineParameters(query, "query") : [], { location: "query" });
    const pathParameters = enhanceMissingParametersError(() => params ? this.generateInlineParameters(params, "path") : [], { location: "path" });
    const cookieParameters = enhanceMissingParametersError(() => cookies ? this.generateInlineParameters(cookies, "cookie") : [], { location: "cookie" });
    const headerParameters = enhanceMissingParametersError(() => {
      if (Array.isArray(headers)) {
        return headers.flatMap((header) => this.generateInlineParameters(header, "header"));
      }
      const cleanHeaders = this.cleanParameter(headers);
      return cleanHeaders ? this.generateInlineParameters(cleanHeaders, "header") : [];
    }, { location: "header" });
    return [
      ...pathParameters,
      ...queryParameters,
      ...headerParameters,
      ...cookieParameters
    ];
  }
  cleanParameter(schema) {
    if (!schema) {
      return void 0;
    }
    return isZodType(schema, "ZodEffects") ? schema._def.schema : schema;
  }
  generatePath(route) {
    const { method, path, request, responses } = route, pathItemConfig = __rest(route, ["method", "path", "request", "responses"]);
    const generatedResponses = mapValues(responses, (response) => {
      return this.getResponse(response);
    });
    const parameters = enhanceMissingParametersError(() => this.getParameters(request), { route: `${method} ${path}` });
    const requestBody = this.getRequestBody(request === null || request === void 0 ? void 0 : request.body);
    const routeDoc = {
      [method]: Object.assign(Object.assign(Object.assign(Object.assign({}, pathItemConfig), parameters.length > 0 ? {
        parameters: [...pathItemConfig.parameters || [], ...parameters]
      } : {}), requestBody ? { requestBody } : {}), { responses: generatedResponses })
    };
    return routeDoc;
  }
  generateSingleRoute(route) {
    const routeDoc = this.generatePath(route);
    this.pathRefs[route.path] = Object.assign(Object.assign({}, this.pathRefs[route.path]), routeDoc);
    return routeDoc;
  }
  getResponse(_a2) {
    var { content, headers } = _a2, rest = __rest(_a2, ["content", "headers"]);
    const responseContent = content ? { content: this.getBodyContent(content) } : {};
    if (!headers) {
      return Object.assign(Object.assign({}, rest), responseContent);
    }
    const responseHeaders = isZodType(headers, "ZodObject") ? this.getResponseHeaders(headers) : (
      // This is input data so it is okay to cast in the common generator
      // since this is the user's responsibility to keep it correct
      headers
    );
    return Object.assign(Object.assign(Object.assign({}, rest), { headers: responseHeaders }), responseContent);
  }
  getResponseHeaders(headers) {
    const schemaShape = headers._def.shape();
    const responseHeaders = mapValues(schemaShape, (_) => this.generateSimpleParameter(_));
    return responseHeaders;
  }
  getBodyContent(content) {
    return mapValues(content, (config) => {
      if (!config || !isAnyZodType(config.schema)) {
        return config;
      }
      const { schema: configSchema } = config, rest = __rest(config, ["schema"]);
      const schema = this.generateSchemaWithRef(configSchema);
      return Object.assign({ schema }, rest);
    });
  }
  toOpenAPISchema(zodSchema, isNullable, defaultValue) {
    return this.openApiTransformer.transform(zodSchema, isNullable, (_) => this.generateSchemaWithRef(_), (_) => this.generateSchemaRef(_), defaultValue);
  }
};
var OpenApiGeneratorV30Specifics = class {
  get nullType() {
    return { nullable: true };
  }
  mapNullableOfArray(objects, isNullable) {
    if (isNullable) {
      return [...objects, this.nullType];
    }
    return objects;
  }
  mapNullableType(type, isNullable) {
    return Object.assign(Object.assign({}, type ? { type } : void 0), isNullable ? this.nullType : void 0);
  }
  mapTupleItems(schemas) {
    const uniqueSchemas = uniq(schemas);
    return {
      items: uniqueSchemas.length === 1 ? uniqueSchemas[0] : { anyOf: uniqueSchemas },
      minItems: schemas.length,
      maxItems: schemas.length
    };
  }
  getNumberChecks(checks) {
    return Object.assign({}, ...checks.map((check) => {
      switch (check.kind) {
        case "min":
          return check.inclusive ? { minimum: Number(check.value) } : { minimum: Number(check.value), exclusiveMinimum: true };
        case "max":
          return check.inclusive ? { maximum: Number(check.value) } : { maximum: Number(check.value), exclusiveMaximum: true };
        default:
          return {};
      }
    }));
  }
};
var OpenApiGeneratorV3 = class {
  constructor(definitions) {
    const specifics = new OpenApiGeneratorV30Specifics();
    this.generator = new OpenAPIGenerator(definitions, specifics);
  }
  generateDocument(config) {
    const baseData = this.generator.generateDocumentData();
    return Object.assign(Object.assign({}, config), baseData);
  }
  generateComponents() {
    return this.generator.generateComponents();
  }
};
var OpenApiGeneratorV31Specifics = class {
  get nullType() {
    return { type: "null" };
  }
  mapNullableOfArray(objects, isNullable) {
    if (isNullable) {
      return [...objects, this.nullType];
    }
    return objects;
  }
  mapNullableType(type, isNullable) {
    if (!type) {
      return {};
    }
    if (isNullable) {
      return {
        type: Array.isArray(type) ? [...type, "null"] : [type, "null"]
      };
    }
    return {
      type
    };
  }
  mapTupleItems(schemas) {
    return {
      prefixItems: schemas
    };
  }
  getNumberChecks(checks) {
    return Object.assign({}, ...checks.map((check) => {
      switch (check.kind) {
        case "min":
          return check.inclusive ? { minimum: Number(check.value) } : { exclusiveMinimum: Number(check.value) };
        case "max":
          return check.inclusive ? { maximum: Number(check.value) } : { exclusiveMaximum: Number(check.value) };
        default:
          return {};
      }
    }));
  }
};
function isWebhookDefinition(definition) {
  return "type" in definition && definition.type === "webhook";
}
var OpenApiGeneratorV31 = class {
  constructor(definitions) {
    this.definitions = definitions;
    this.webhookRefs = {};
    const specifics = new OpenApiGeneratorV31Specifics();
    this.generator = new OpenAPIGenerator(this.definitions, specifics);
  }
  generateDocument(config) {
    const baseDocument = this.generator.generateDocumentData();
    this.definitions.filter(isWebhookDefinition).forEach((definition) => this.generateSingleWebhook(definition.webhook));
    return Object.assign(Object.assign(Object.assign({}, config), baseDocument), { webhooks: this.webhookRefs });
  }
  generateComponents() {
    return this.generator.generateComponents();
  }
  generateSingleWebhook(route) {
    const routeDoc = this.generator.generatePath(route);
    this.webhookRefs[route.path] = Object.assign(Object.assign({}, this.webhookRefs[route.path]), routeDoc);
    return routeDoc;
  }
};

// ../../node_modules/@hono/zod-validator/dist/esm/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/validator/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/validator/validator.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/helper/cookie/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/utils/cookie.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/utils/url.js
init_checked_fetch();
init_modules_watch_stub();
var splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
};
var extractGroupsFromPath = (path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
};
var replaceGroupMarks = (paths, groups) => {
  for (let i2 = groups.length - 1; i2 >= 0; i2--) {
    const [mark] = groups[i2];
    for (let j2 = paths.length - 1; j2 >= 0; j2--) {
      if (paths[j2].includes(mark)) {
        paths[j2] = paths[j2].replace(mark, groups[i2][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    if (!patternCache[label]) {
      if (match[2]) {
        patternCache[label] = [label, match[1], new RegExp("^" + match[2] + "$")];
      } else {
        patternCache[label] = [label, match[1], true];
      }
    }
    return patternCache[label];
  }
  return null;
};
var getPath = (request) => {
  const url = request.url;
  const queryIndex = url.indexOf("?", 8);
  return url.slice(url.indexOf("/", 8), queryIndex === -1 ? void 0 : queryIndex);
};
var getQueryStrings = (url) => {
  const queryIndex = url.indexOf("?", 8);
  return queryIndex === -1 ? "" : "?" + url.slice(queryIndex + 1);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result[result.length - 1] === "/" ? result.slice(0, -1) : result;
};
var mergePath = (...paths) => {
  let p2 = "";
  let endsWithSlash = false;
  for (let path of paths) {
    if (p2[p2.length - 1] === "/") {
      p2 = p2.slice(0, -1);
      endsWithSlash = true;
    }
    if (path[0] !== "/") {
      path = `/${path}`;
    }
    if (path === "/" && endsWithSlash) {
      p2 = `${p2}/`;
    } else if (path !== "/") {
      p2 = `${p2}${path}`;
    }
    if (path === "/" && p2 === "") {
      p2 = "/";
    }
  }
  return p2;
};
var checkOptionalParameter = (path) => {
  if (!path.match(/\:.+\?$/)) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v2, i2, a2) => a2.indexOf(v2) === i2);
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return /%/.test(value) ? decodeURIComponent_(value) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return void 0;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name2 = url.slice(
      keyIndex + 1,
      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex
    );
    if (encoded) {
      name2 = _decodeURI(name2);
    }
    keyIndex = nextKeyIndex;
    if (name2 === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name2] && Array.isArray(results[name2]))) {
        results[name2] = [];
      }
      ;
      results[name2].push(value);
    } else {
      results[name2] ??= value;
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// ../../node_modules/hono/dist/utils/cookie.js
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse = (cookie, name2) => {
  const pairs = cookie.trim().split(";");
  return pairs.reduce((parsedCookie, pairStr) => {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1) {
      return parsedCookie;
    }
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name2 && name2 !== cookieName || !validCookieNameRegEx.test(cookieName)) {
      return parsedCookie;
    }
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
      cookieValue = cookieValue.slice(1, -1);
    }
    if (validCookieValueRegEx.test(cookieValue)) {
      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);
    }
    return parsedCookie;
  }, {});
};

// ../../node_modules/hono/dist/helper/cookie/index.js
var getCookie = (c2, key, prefix) => {
  const cookie = c2.req.raw.headers.get("Cookie");
  if (typeof key === "string") {
    if (!cookie) {
      return void 0;
    }
    let finalKey = key;
    if (prefix === "secure") {
      finalKey = "__Secure-" + key;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key;
    }
    const obj2 = parse(cookie, finalKey);
    return obj2[finalKey];
  }
  if (!cookie) {
    return {};
  }
  const obj = parse(cookie);
  return obj;
};

// ../../node_modules/hono/dist/http-exception.js
init_checked_fetch();
init_modules_watch_stub();
var HTTPException = class extends Error {
  res;
  status;
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      return this.res;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// ../../node_modules/hono/dist/utils/buffer.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/utils/crypto.js
init_checked_fetch();
init_modules_watch_stub();
var sha256 = async (data) => {
  const algorithm = { name: "SHA-256", alias: "sha256" };
  const hash = await createHash(data, algorithm);
  return hash;
};
var createHash = async (data, algorithm) => {
  let sourceBuffer;
  if (data instanceof ReadableStream) {
    let body = "";
    const reader = data.getReader();
    await reader?.read().then(async (chuck) => {
      const value = await createHash(chuck.value || "", algorithm);
      body += value;
    });
    return body;
  }
  if (ArrayBuffer.isView(data) || data instanceof ArrayBuffer) {
    sourceBuffer = data;
  } else {
    if (typeof data === "object") {
      data = JSON.stringify(data);
    }
    sourceBuffer = new TextEncoder().encode(String(data));
  }
  if (crypto && crypto.subtle) {
    const buffer = await crypto.subtle.digest(
      {
        name: algorithm.name
      },
      sourceBuffer
    );
    const hash = Array.prototype.map.call(new Uint8Array(buffer), (x2) => ("00" + x2.toString(16)).slice(-2)).join("");
    return hash;
  }
  return null;
};

// ../../node_modules/hono/dist/utils/buffer.js
var timingSafeEqual = async (a2, b2, hashFunction) => {
  if (!hashFunction) {
    hashFunction = sha256;
  }
  const sa = await hashFunction(a2);
  const sb = await hashFunction(b2);
  if (!sa || !sb) {
    return false;
  }
  return sa === sb && a2 === b2;
};
var bufferToFormData = (arrayBuffer, contentType) => {
  const response = new Response(arrayBuffer, {
    headers: {
      "Content-Type": contentType
    }
  });
  return response.formData();
};

// ../../node_modules/hono/dist/validator/validator.js
var validator = (target, validationFunc) => {
  return async (c2, next) => {
    let value = {};
    const contentType = c2.req.header("Content-Type");
    switch (target) {
      case "json":
        if (!contentType || !/^application\/([a-z-]+\+)?json/.test(contentType)) {
          const message = `Invalid HTTP header: Content-Type=${contentType}`;
          throw new HTTPException(400, { message });
        }
        try {
          value = await c2.req.json();
        } catch {
          const message = "Malformed JSON in request body";
          throw new HTTPException(400, { message });
        }
        break;
      case "form": {
        if (!contentType) {
          break;
        }
        if (c2.req.bodyCache.formData) {
          value = await c2.req.bodyCache.formData;
          break;
        }
        try {
          const arrayBuffer = await c2.req.arrayBuffer();
          const formData = await bufferToFormData(arrayBuffer, contentType);
          const form = {};
          formData.forEach((value2, key) => {
            if (key.endsWith("[]")) {
              if (form[key] === void 0) {
                form[key] = [value2];
              } else if (Array.isArray(form[key])) {
                ;
                form[key].push(value2);
              }
            } else {
              form[key] = value2;
            }
          });
          value = form;
          c2.req.bodyCache.formData = formData;
        } catch (e2) {
          let message = "Malformed FormData request.";
          message += e2 instanceof Error ? ` ${e2.message}` : ` ${String(e2)}`;
          throw new HTTPException(400, { message });
        }
        break;
      }
      case "query":
        value = Object.fromEntries(
          Object.entries(c2.req.queries()).map(([k2, v2]) => {
            return v2.length === 1 ? [k2, v2[0]] : [k2, v2];
          })
        );
        break;
      case "param":
        value = c2.req.param();
        break;
      case "header":
        value = c2.req.header();
        break;
      case "cookie":
        value = getCookie(c2);
        break;
    }
    const res = await validationFunc(value, c2);
    if (res instanceof Response) {
      return res;
    }
    c2.req.addValidatedData(target, res);
    await next();
  };
};

// ../../node_modules/@hono/zod-validator/dist/esm/index.js
var zValidator = (target, schema, hook) => (
  // @ts-expect-error not typed well
  validator(target, async (value, c2) => {
    const result = await schema.safeParseAsync(value);
    if (hook) {
      const hookResult = hook({ data: value, ...result }, c2);
      if (hookResult) {
        if (hookResult instanceof Response || hookResult instanceof Promise) {
          return hookResult;
        }
        if ("response" in hookResult) {
          return hookResult.response;
        }
      }
    }
    if (!result.success) {
      return c2.json(result, 400);
    }
    const data = result.data;
    return data;
  })
);

// ../../node_modules/hono/dist/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/hono.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/hono-base.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/compose.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/context.js
init_checked_fetch();
init_modules_watch_stub();
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setHeaders = (headers, map2 = {}) => {
  Object.entries(map2).forEach(([key, value]) => headers.set(key, value));
  return headers;
};
var Context = class {
  req;
  env = {};
  _var = {};
  finalized = false;
  error = void 0;
  #status = 200;
  #executionCtx;
  #headers = void 0;
  #preparedHeaders = void 0;
  #res;
  #isFresh = true;
  layout = void 0;
  renderer = (content) => this.html(content);
  notFoundHandler = () => new Response();
  constructor(req, options) {
    this.req = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      if (options.notFoundHandler) {
        this.notFoundHandler = options.notFoundHandler;
      }
    }
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    this.#isFresh = false;
    return this.#res ||= new Response("404 Not Found", { status: 404 });
  }
  set res(_res) {
    this.#isFresh = false;
    if (this.#res && _res) {
      this.#res.headers.delete("content-type");
      for (const [k2, v2] of this.#res.headers.entries()) {
        if (k2 === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k2, v2);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = (...args) => this.renderer(...args);
  setLayout = (layout) => this.layout = layout;
  getLayout = () => this.layout;
  setRenderer = (renderer) => {
    this.renderer = renderer;
  };
  header = (name2, value, options) => {
    if (value === void 0) {
      if (this.#headers) {
        this.#headers.delete(name2);
      } else if (this.#preparedHeaders) {
        delete this.#preparedHeaders[name2.toLocaleLowerCase()];
      }
      if (this.finalized) {
        this.res.headers.delete(name2);
      }
      return;
    }
    if (options?.append) {
      if (!this.#headers) {
        this.#isFresh = false;
        this.#headers = new Headers(this.#preparedHeaders);
        this.#preparedHeaders = {};
      }
      this.#headers.append(name2, value);
    } else {
      if (this.#headers) {
        this.#headers.set(name2, value);
      } else {
        this.#preparedHeaders ??= {};
        this.#preparedHeaders[name2.toLowerCase()] = value;
      }
    }
    if (this.finalized) {
      if (options?.append) {
        this.res.headers.append(name2, value);
      } else {
        this.res.headers.set(name2, value);
      }
    }
  };
  status = (status) => {
    this.#isFresh = false;
    this.#status = status;
  };
  set = (key, value) => {
    this._var ??= {};
    this._var[key] = value;
  };
  get = (key) => {
    return this._var ? this._var[key] : void 0;
  };
  get var() {
    return { ...this._var };
  }
  newResponse = (data, arg, headers) => {
    if (this.#isFresh && !headers && !arg && this.#status === 200) {
      return new Response(data, {
        headers: this.#preparedHeaders
      });
    }
    if (arg && typeof arg !== "number") {
      const header = new Headers(arg.headers);
      if (this.#headers) {
        this.#headers.forEach((v2, k2) => {
          header.set(k2, v2);
        });
      }
      const headers2 = setHeaders(header, this.#preparedHeaders);
      return new Response(data, {
        headers: headers2,
        status: arg.status ?? this.#status
      });
    }
    const status = typeof arg === "number" ? arg : this.#status;
    this.#preparedHeaders ??= {};
    this.#headers ??= new Headers();
    setHeaders(this.#headers, this.#preparedHeaders);
    if (this.#res) {
      this.#res.headers.forEach((v2, k2) => {
        if (k2 === "set-cookie") {
          this.#headers?.append(k2, v2);
        } else {
          this.#headers?.set(k2, v2);
        }
      });
      setHeaders(this.#headers, this.#preparedHeaders);
    }
    headers ??= {};
    for (const [k2, v2] of Object.entries(headers)) {
      if (typeof v2 === "string") {
        this.#headers.set(k2, v2);
      } else {
        this.#headers.delete(k2);
        for (const v22 of v2) {
          this.#headers.append(k2, v22);
        }
      }
    }
    return new Response(data, {
      status,
      headers: this.#headers
    });
  };
  body = (data, arg, headers) => {
    return typeof arg === "number" ? this.newResponse(data, arg, headers) : this.newResponse(data, arg);
  };
  text = (text, arg, headers) => {
    if (!this.#preparedHeaders) {
      if (this.#isFresh && !headers && !arg) {
        return new Response(text);
      }
      this.#preparedHeaders = {};
    }
    this.#preparedHeaders["content-type"] = TEXT_PLAIN;
    return typeof arg === "number" ? this.newResponse(text, arg, headers) : this.newResponse(text, arg);
  };
  json = (object, arg, headers) => {
    const body = JSON.stringify(object);
    this.#preparedHeaders ??= {};
    this.#preparedHeaders["content-type"] = "application/json; charset=UTF-8";
    return typeof arg === "number" ? this.newResponse(body, arg, headers) : this.newResponse(body, arg);
  };
  html = (html2, arg, headers) => {
    this.#preparedHeaders ??= {};
    this.#preparedHeaders["content-type"] = "text/html; charset=UTF-8";
    if (typeof html2 === "object") {
      if (!(html2 instanceof Promise)) {
        html2 = html2.toString();
      }
      if (html2 instanceof Promise) {
        return html2.then((html22) => resolveCallback(html22, HtmlEscapedCallbackPhase.Stringify, false, {})).then((html22) => {
          return typeof arg === "number" ? this.newResponse(html22, arg, headers) : this.newResponse(html22, arg);
        });
      }
    }
    return typeof arg === "number" ? this.newResponse(html2, arg, headers) : this.newResponse(html2, arg);
  };
  redirect = (location, status = 302) => {
    this.#headers ??= new Headers();
    this.#headers.set("Location", location);
    return this.newResponse(null, status);
  };
  notFound = () => {
    return this.notFoundHandler(this);
  };
};

// ../../node_modules/hono/dist/compose.js
var compose = (middleware2, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i2) {
      if (i2 <= index) {
        throw new Error("next() called multiple times");
      }
      index = i2;
      let res;
      let isError = false;
      let handler;
      if (middleware2[i2]) {
        handler = middleware2[i2][0][0];
        if (context instanceof Context) {
          context.req.routeIndex = i2;
        }
      } else {
        handler = i2 === middleware2.length && next || void 0;
      }
      if (!handler) {
        if (context instanceof Context && context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      } else {
        try {
          res = await handler(context, () => {
            return dispatch(i2 + 1);
          });
        } catch (err2) {
          if (err2 instanceof Error && context instanceof Context && onError) {
            context.error = err2;
            res = await onError(err2, context);
            isError = true;
          } else {
            throw err2;
          }
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
  };
};

// ../../node_modules/hono/dist/request.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/utils/body.js
init_checked_fetch();
init_modules_watch_stub();
var parseBody = async (request, options = { all: false }) => {
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType !== null && contentType.startsWith("multipart/form-data") || contentType !== null && contentType.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, options);
  }
  return {};
};
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = {};
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  return form;
}
var handleParsingAllValues = (form, key, value) => {
  const formKey = form[key];
  if (formKey && Array.isArray(formKey)) {
    ;
    form[key].push(value);
  } else if (formKey) {
    form[key] = [formKey, value];
  } else {
    form[key] = value;
  }
};

// ../../node_modules/hono/dist/request.js
var HonoRequest = class {
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.getDecodedParam(key) : this.getAllDecodedParams();
  }
  getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.getParamValue(paramKey);
    return param ? /\%/.test(param) ? decodeURIComponent_(param) : param : void 0;
  }
  getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value && typeof value === "string") {
        decoded[key] = /\%/.test(value) ? decodeURIComponent_(value) : value;
      }
    }
    return decoded;
  }
  getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name2) {
    if (name2) {
      return this.raw.headers.get(name2.toLowerCase()) ?? void 0;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    if (this.bodyCache.parsedBody) {
      return this.bodyCache.parsedBody;
    }
    const parsedBody = await parseBody(this, options);
    this.bodyCache.parsedBody = parsedBody;
    return parsedBody;
  }
  cachedBody = (key) => {
    const { bodyCache, raw: raw3 } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    if (!bodyCache[key]) {
      for (const keyOfBodyCache of Object.keys(bodyCache)) {
        if (keyOfBodyCache === "parsedBody") {
          continue;
        }
        return (async () => {
          let body = await bodyCache[keyOfBodyCache];
          if (keyOfBodyCache === "json") {
            body = JSON.stringify(body);
          }
          return await new Response(body)[key]();
        })();
      }
    }
    return bodyCache[key] = raw3[key]();
  };
  json() {
    return this.cachedBody("json");
  }
  text() {
    return this.cachedBody("text");
  }
  arrayBuffer() {
    return this.cachedBody("arrayBuffer");
  }
  blob() {
    return this.cachedBody("blob");
  }
  formData() {
    return this.cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// ../../node_modules/hono/dist/router.js
init_checked_fetch();
init_modules_watch_stub();
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};

// ../../node_modules/hono/dist/hono-base.js
var COMPOSED_HANDLER = Symbol("composedHandler");
function defineDynamicClass() {
  return class {
  };
}
var notFoundHandler = (c2) => {
  return c2.text("404 Not Found", 404);
};
var errorHandler = (err2, c2) => {
  if (err2 instanceof HTTPException) {
    return err2.getResponse();
  }
  console.error(err2);
  return c2.text("Internal Server Error", 500);
};
var Hono = class extends defineDynamicClass() {
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    super();
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          if (typeof handler !== "string") {
            this.addRoute(method, this.#path, handler);
          }
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      if (!method) {
        return this;
      }
      for (const p2 of [path].flat()) {
        this.#path = p2;
        for (const m2 of [method].flat()) {
          handlers.map((handler) => {
            this.addRoute(m2.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const strict = options.strict ?? true;
    delete options.strict;
    Object.assign(this, options);
    this.getPath = strict ? options.getPath ?? getPath : getPathNoStrict;
  }
  clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.routes = this.routes;
    return clone;
  }
  notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app10) {
    const subApp = this.basePath(path);
    if (!app10) {
      return subApp;
    }
    app10.routes.map((r2) => {
      let handler;
      if (app10.errorHandler === errorHandler) {
        handler = r2.handler;
      } else {
        handler = async (c2, next) => (await compose([], app10.errorHandler)(c2, () => r2.handler(c2, next))).res;
        handler[COMPOSED_HANDLER] = r2.handler;
      }
      subApp.addRoute(r2.method, r2.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = (handler) => {
    this.errorHandler = handler;
    return this;
  };
  notFound = (handler) => {
    this.notFoundHandler = handler;
    return this;
  };
  mount(path, applicationHandler, optionHandler) {
    const mergedPath = mergePath(this._basePath, path);
    const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
    const handler = async (c2, next) => {
      let executionContext = void 0;
      try {
        executionContext = c2.executionCtx;
      } catch {
      }
      const options = optionHandler ? optionHandler(c2) : [c2.env, executionContext];
      const optionsArray = Array.isArray(options) ? options : [options];
      const queryStrings = getQueryStrings(c2.req.url);
      const res = await applicationHandler(
        new Request(
          new URL((c2.req.path.slice(pathPrefixLength) || "/") + queryStrings, c2.req.url),
          c2.req.raw
        ),
        ...optionsArray
      );
      if (res) {
        return res;
      }
      await next();
    };
    this.addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r2 = { path, method, handler };
    this.router.add(method, path, [handler, r2]);
    this.routes.push(r2);
  }
  matchRoute(method, path) {
    return this.router.match(method, path);
  }
  handleError(err2, c2) {
    if (err2 instanceof Error) {
      return this.errorHandler(err2, c2);
    }
    throw err2;
  }
  dispatch(request, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.dispatch(request, executionCtx, env, "GET")))();
    }
    const path = this.getPath(request, { env });
    const matchResult = this.matchRoute(method, path);
    const c2 = new Context(new HonoRequest(request, path, matchResult), {
      env,
      executionCtx,
      notFoundHandler: this.notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c2, async () => {
          c2.res = await this.notFoundHandler(c2);
        });
      } catch (err2) {
        return this.handleError(err2, c2);
      }
      return res instanceof Promise ? res.then(
        (resolved) => resolved || (c2.finalized ? c2.res : this.notFoundHandler(c2))
      ).catch((err2) => this.handleError(err2, c2)) : res;
    }
    const composed = compose(matchResult[0], this.errorHandler, this.notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c2);
        if (!context.finalized) {
          throw new Error(
            "Context is not finalized. You may forget returning Response object or `await next()`"
          );
        }
        return context.res;
      } catch (err2) {
        return this.handleError(err2, c2);
      }
    })();
  }
  fetch = (request, ...rest) => {
    return this.dispatch(request, rest[1], rest[0], request.method);
  };
  request = (input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      if (requestInit !== void 0) {
        input = new Request(input, requestInit);
      }
      return this.fetch(input, Env, executionCtx);
    }
    input = input.toString();
    const path = /^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`;
    const req = new Request(path, requestInit);
    return this.fetch(req, Env, executionCtx);
  };
  fire = () => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.dispatch(event.request, event, void 0, event.request.method));
    });
  };
};

// ../../node_modules/hono/dist/router/reg-exp-router/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/router/reg-exp-router/router.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/router/reg-exp-router/node.js
init_checked_fetch();
init_modules_watch_stub();
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a2, b2) {
  if (a2.length === 1) {
    return b2.length === 1 ? a2 < b2 ? -1 : 1 : -1;
  }
  if (b2.length === 1) {
    return 1;
  }
  if (a2 === ONLY_WILDCARD_REG_EXP_STR || a2 === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b2 === ONLY_WILDCARD_REG_EXP_STR || b2 === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a2 === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b2 === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a2.length === b2.length ? a2 < b2 ? -1 : 1 : b2.length - a2.length;
}
var Node = class {
  index;
  varIndex;
  children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.index !== void 0) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name2 = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name2 && pattern[2]) {
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.children[regexpStr];
      if (!node) {
        if (Object.keys(this.children).some(
          (k2) => k2 !== ONLY_WILDCARD_REG_EXP_STR && k2 !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.children[regexpStr] = new Node();
        if (name2 !== "") {
          node.varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name2 !== "") {
        paramMap.push([name2, node.varIndex]);
      }
    } else {
      node = this.children[token];
      if (!node) {
        if (Object.keys(this.children).some(
          (k2) => k2.length > 1 && k2 !== ONLY_WILDCARD_REG_EXP_STR && k2 !== TAIL_WILDCARD_REG_EXP_STR
        )) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.children[token] = new Node();
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.children).sort(compareKey);
    const strList = childKeys.map((k2) => {
      const c2 = this.children[k2];
      return (typeof c2.varIndex === "number" ? `(${k2})@${c2.varIndex}` : regExpMetaChars.has(k2) ? `\\${k2}` : k2) + c2.buildRegExpStr();
    });
    if (typeof this.index === "number") {
      strList.unshift(`#${this.index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// ../../node_modules/hono/dist/router/reg-exp-router/trie.js
init_checked_fetch();
init_modules_watch_stub();
var Trie = class {
  context = { varIndex: 0 };
  root = new Node();
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i2 = 0; ; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m2) => {
        const mark = `@\\${i2}`;
        groups[i2] = [mark, m2];
        i2++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i2 = groups.length - 1; i2 >= 0; i2--) {
      const [mark] = groups[i2];
      for (let j2 = tokens.length - 1; j2 >= 0; j2--) {
        if (tokens[j2].indexOf(mark) !== -1) {
          tokens[j2] = tokens[j2].replace(mark, groups[i2][1]);
          break;
        }
      }
    }
    this.root.insert(tokens, index, paramAssoc, this.context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (typeof handlerIndex !== "undefined") {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (typeof paramIndex !== "undefined") {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// ../../node_modules/hono/dist/router/reg-exp-router/router.js
var emptyParam = [];
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(
    path === "*" ? "" : `^${path.replace(
      /\/\*$|([.\\+*[^\]$()])/g,
      (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)"
    )}$`
  );
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie();
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map(
    (route) => [!/\*|\/:/.test(route[0]), ...route]
  ).sort(
    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length
  );
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i2 = 0, j2 = -1, len = routesWithStaticPathFlag.length; i2 < len; i2++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i2];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h2]) => [h2, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j2++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j2, pathErrorCheckOnly);
    } catch (e2) {
      throw e2 === PATH_ERROR ? new UnsupportedPathError(path) : e2;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j2] = handlers.map(([h2, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (; paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h2, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i2 = 0, len = handlerData.length; i2 < len; i2++) {
    for (let j2 = 0, len2 = handlerData[i2].length; j2 < len2; j2++) {
      const map2 = handlerData[i2][j2]?.[1];
      if (!map2) {
        continue;
      }
      const keys = Object.keys(map2);
      for (let k2 = 0, len3 = keys.length; k2 < len3; k2++) {
        map2[keys[k2]] = paramReplacementMap[map2[keys[k2]]];
      }
    }
  }
  const handlerMap = [];
  for (const i2 in indexReplacementMap) {
    handlerMap[i2] = handlerData[indexReplacementMap[i2]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware2, path) {
  if (!middleware2) {
    return void 0;
  }
  for (const k2 of Object.keys(middleware2).sort((a2, b2) => b2.length - a2.length)) {
    if (buildWildcardRegExp(k2).test(path)) {
      return [...middleware2[k2]];
    }
  }
  return void 0;
}
var RegExpRouter = class {
  name = "RegExpRouter";
  middleware;
  routes;
  constructor() {
    this.middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const { middleware: middleware2, routes } = this;
    if (!middleware2 || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware2[method]) {
      ;
      [middleware2, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p2) => {
          handlerMap[method][p2] = [...handlerMap[METHOD_NAME_ALL][p2]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware2).forEach((m2) => {
          middleware2[m2][path] ||= findMiddleware(middleware2[m2], path) || findMiddleware(middleware2[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware2[method][path] ||= findMiddleware(middleware2[method], path) || findMiddleware(middleware2[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware2).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          Object.keys(middleware2[m2]).forEach((p2) => {
            re.test(p2) && middleware2[m2][p2].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          Object.keys(routes[m2]).forEach(
            (p2) => re.test(p2) && routes[m2][p2].push([handler, paramCount])
          );
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i2 = 0, len = paths.length; i2 < len; i2++) {
      const path2 = paths[i2];
      Object.keys(routes).forEach((m2) => {
        if (method === METHOD_NAME_ALL || method === m2) {
          routes[m2][path2] ||= [
            ...findMiddleware(middleware2[m2], path2) || findMiddleware(middleware2[METHOD_NAME_ALL], path2) || []
          ];
          routes[m2][path2].push([handler, paramCount - len + i2 + 1]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    [...Object.keys(this.routes), ...Object.keys(this.middleware)].forEach((method) => {
      matchers[method] ||= this.buildMatcher(method);
    });
    this.middleware = this.routes = void 0;
    return matchers;
  }
  buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.middleware, this.routes].forEach((r2) => {
      const ownRoute = r2[method] ? Object.keys(r2[method]).map((path) => [path, r2[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(
          ...Object.keys(r2[METHOD_NAME_ALL]).map((path) => [path, r2[METHOD_NAME_ALL][path]])
        );
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// ../../node_modules/hono/dist/router/smart-router/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/router/smart-router/router.js
init_checked_fetch();
init_modules_watch_stub();
var SmartRouter = class {
  name = "SmartRouter";
  routers = [];
  routes = [];
  constructor(init2) {
    Object.assign(this, init2);
  }
  add(method, path, handler) {
    if (!this.routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.routes) {
      throw new Error("Fatal error");
    }
    const { routers, routes } = this;
    const len = routers.length;
    let i2 = 0;
    let res;
    for (; i2 < len; i2++) {
      const router = routers[i2];
      try {
        routes.forEach((args) => {
          router.add(...args);
        });
        res = router.match(method, path);
      } catch (e2) {
        if (e2 instanceof UnsupportedPathError) {
          continue;
        }
        throw e2;
      }
      this.match = router.match.bind(router);
      this.routers = [router];
      this.routes = void 0;
      break;
    }
    if (i2 === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.routes || this.routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.routers[0];
  }
};

// ../../node_modules/hono/dist/router/trie-router/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/router/trie-router/router.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/hono/dist/router/trie-router/node.js
init_checked_fetch();
init_modules_watch_stub();
var Node2 = class {
  methods;
  children;
  patterns;
  order = 0;
  name;
  params = /* @__PURE__ */ Object.create(null);
  constructor(method, handler, children) {
    this.children = children || /* @__PURE__ */ Object.create(null);
    this.methods = [];
    this.name = "";
    if (method && handler) {
      const m2 = /* @__PURE__ */ Object.create(null);
      m2[method] = { handler, possibleKeys: [], score: 0, name: this.name };
      this.methods = [m2];
    }
    this.patterns = [];
  }
  insert(method, path, handler) {
    this.name = `${method} ${path}`;
    this.order = ++this.order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i2 = 0, len = parts.length; i2 < len; i2++) {
      const p2 = parts[i2];
      if (Object.keys(curNode.children).includes(p2)) {
        curNode = curNode.children[p2];
        const pattern2 = getPattern(p2);
        if (pattern2) {
          possibleKeys.push(pattern2[1]);
        }
        continue;
      }
      curNode.children[p2] = new Node2();
      const pattern = getPattern(p2);
      if (pattern) {
        curNode.patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.children[p2];
    }
    if (!curNode.methods.length) {
      curNode.methods = [];
    }
    const m2 = /* @__PURE__ */ Object.create(null);
    const handlerSet = {
      handler,
      possibleKeys: possibleKeys.filter((v2, i2, a2) => a2.indexOf(v2) === i2),
      name: this.name,
      score: this.order
    };
    m2[method] = handlerSet;
    curNode.methods.push(m2);
    return curNode;
  }
  gHSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i2 = 0, len = node.methods.length; i2 < len; i2++) {
      const m2 = node.methods[i2];
      const handlerSet = m2[method] || m2[METHOD_NAME_ALL];
      const processedSet = /* @__PURE__ */ Object.create(null);
      if (handlerSet !== void 0) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSet.possibleKeys.forEach((key) => {
          const processed = processedSet[handlerSet.name];
          handlerSet.params[key] = params[key] && !processed ? params[key] : nodeParams[key] ?? params[key];
          processedSet[handlerSet.name] = true;
        });
        handlerSets.push(handlerSet);
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.params = /* @__PURE__ */ Object.create(null);
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    for (let i2 = 0, len = parts.length; i2 < len; i2++) {
      const part = parts[i2];
      const isLast = i2 === len - 1;
      const tempNodes = [];
      for (let j2 = 0, len2 = curNodes.length; j2 < len2; j2++) {
        const node = curNodes[j2];
        const nextNode = node.children[part];
        if (nextNode) {
          nextNode.params = node.params;
          if (isLast === true) {
            if (nextNode.children["*"]) {
              handlerSets.push(
                ...this.gHSets(nextNode.children["*"], method, node.params, /* @__PURE__ */ Object.create(null))
              );
            }
            handlerSets.push(...this.gHSets(nextNode, method, node.params, /* @__PURE__ */ Object.create(null)));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k2 = 0, len3 = node.patterns.length; k2 < len3; k2++) {
          const pattern = node.patterns[k2];
          const params = { ...node.params };
          if (pattern === "*") {
            const astNode = node.children["*"];
            if (astNode) {
              handlerSets.push(...this.gHSets(astNode, method, node.params, /* @__PURE__ */ Object.create(null)));
              tempNodes.push(astNode);
            }
            continue;
          }
          if (part === "") {
            continue;
          }
          const [key, name2, matcher] = pattern;
          const child2 = node.children[key];
          const restPathString = parts.slice(i2).join("/");
          if (matcher instanceof RegExp && matcher.test(restPathString)) {
            params[name2] = restPathString;
            handlerSets.push(...this.gHSets(child2, method, node.params, params));
            continue;
          }
          if (matcher === true || matcher instanceof RegExp && matcher.test(part)) {
            if (typeof key === "string") {
              params[name2] = part;
              if (isLast === true) {
                handlerSets.push(...this.gHSets(child2, method, params, node.params));
                if (child2.children["*"]) {
                  handlerSets.push(...this.gHSets(child2.children["*"], method, params, node.params));
                }
              } else {
                child2.params = params;
                tempNodes.push(child2);
              }
            }
          }
        }
      }
      curNodes = tempNodes;
    }
    const results = handlerSets.sort((a2, b2) => {
      return a2.score - b2.score;
    });
    return [results.map(({ handler, params }) => [handler, params])];
  }
};

// ../../node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  name = "TrieRouter";
  node;
  constructor() {
    this.node = new Node2();
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (const p2 of results) {
        this.node.insert(method, p2, handler);
      }
      return;
    }
    this.node.insert(method, path, handler);
  }
  match(method, path) {
    return this.node.search(method, path);
  }
};

// ../../node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter(), new TrieRouter()]
    });
  }
};

// ../../node_modules/zod/lib/index.mjs
init_checked_fetch();
init_modules_watch_stub();
var util;
(function(util2) {
  util2.assertEqual = (val2) => val2;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val2) => Number.isInteger(val2) : (val2) => typeof val2 === "number" && isFinite(val2) && Math.floor(val2) === val2;
  function joinValues(array, separator = " | ") {
    return array.map((val2) => typeof val2 === "string" ? `'${val2}'` : val2).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x2) => x2.status === "aborted";
var isDirty = (x2) => x2.status === "dirty";
var isValid = (x2) => x2.status === "valid";
var isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a2, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a2 = message !== null && message !== void 0 ? message : required_error) !== null && _a2 !== void 0 ? _a2 : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val2) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val2);
      } else {
        return message;
      }
    };
    return this._refinement((val2, ctx) => {
      const result = check(val2);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val2)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val2, ctx) => {
      if (!check(val2)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val2, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a2, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch2) => ch2.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch2) => ch2.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch2) => ch2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch2) => ch2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch2) => ch2.kind === "base64");
  }
  get minLength() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a2;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val2, step) {
  const valDecCount = (val2.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val2.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
        return true;
      } else if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      } else if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a2;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max === null || ch2.value < max)
          max = ch2.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a2, _b, _c, _d;
          const defaultError = (_c = (_b = (_a2 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a2, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val2 of this._def.values) {
      enumValues[val2] = val2;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val2 of this._def.values) {
      enumValues[val2] = val2;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val2 of this._def.values) {
      enumValues[val2] = val2;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a2, _b;
      if (!check(data)) {
        const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a2 = p2.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// ../../node_modules/@hono/zod-openapi/dist/index.mjs
var OpenAPIHono = class _OpenAPIHono extends Hono2 {
  openAPIRegistry;
  defaultHook;
  constructor(init2) {
    super(init2);
    this.openAPIRegistry = new OpenAPIRegistry();
    this.defaultHook = init2?.defaultHook;
  }
  /**
   *
   * @param {RouteConfig} route - The route definition which you create with `createRoute()`.
   * @param {Handler} handler - The handler. If you want to return a JSON object, you should specify the status code with `c.json()`.
   * @param {Hook} hook - Optional. The hook method defines what it should do after validation.
   * @example
   * app.openapi(
   *   route,
   *   (c) => {
   *     // ...
   *     return c.json(
   *       {
   *         age: 20,
   *         name: 'Young man',
   *       },
   *       200 // You should specify the status code even if it's 200.
   *     )
   *   },
   *  (result, c) => {
   *    if (!result.success) {
   *      return c.json(
   *        {
   *          code: 400,
   *          message: 'Custom Message',
   *        },
   *        400
   *      )
   *    }
   *  }
   *)
   */
  openapi = (route, handler, hook = this.defaultHook) => {
    this.openAPIRegistry.registerPath(route);
    const validators = [];
    if (route.request?.query) {
      const validator2 = zValidator("query", route.request.query, hook);
      validators.push(validator2);
    }
    if (route.request?.params) {
      const validator2 = zValidator("param", route.request.params, hook);
      validators.push(validator2);
    }
    if (route.request?.headers) {
      const validator2 = zValidator("header", route.request.headers, hook);
      validators.push(validator2);
    }
    if (route.request?.cookies) {
      const validator2 = zValidator("cookie", route.request.cookies, hook);
      validators.push(validator2);
    }
    const bodyContent = route.request?.body?.content;
    if (bodyContent) {
      for (const mediaType of Object.keys(bodyContent)) {
        if (!bodyContent[mediaType]) {
          continue;
        }
        const schema = bodyContent[mediaType]["schema"];
        if (!(schema instanceof ZodType)) {
          continue;
        }
        if (mediaType.startsWith("application/json")) {
          const validator2 = zValidator("json", schema, hook);
          validators.push(validator2);
        }
        if (mediaType.startsWith("multipart/form-data") || mediaType.startsWith("application/x-www-form-urlencoded")) {
          const validator2 = zValidator("form", schema, hook);
          validators.push(validator2);
        }
      }
    }
    const middleware2 = route.middleware ? Array.isArray(route.middleware) ? route.middleware : [route.middleware] : [];
    this.on(
      [route.method],
      route.path.replaceAll(/\/{(.+?)}/g, "/:$1"),
      ...middleware2,
      ...validators,
      handler
    );
    return this;
  };
  getOpenAPIDocument = (config) => {
    const generator = new OpenApiGeneratorV3(this.openAPIRegistry.definitions);
    const document = generator.generateDocument(config);
    return document;
  };
  getOpenAPI31Document = (config) => {
    const generator = new OpenApiGeneratorV31(this.openAPIRegistry.definitions);
    const document = generator.generateDocument(config);
    return document;
  };
  doc = (path, configure) => {
    return this.get(path, (c2) => {
      const config = typeof configure === "function" ? configure(c2) : configure;
      try {
        const document = this.getOpenAPIDocument(config);
        return c2.json(document);
      } catch (e2) {
        return c2.json(e2, 500);
      }
    });
  };
  doc31 = (path, configure) => {
    return this.get(path, (c2) => {
      const config = typeof configure === "function" ? configure(c2) : configure;
      try {
        const document = this.getOpenAPI31Document(config);
        return c2.json(document);
      } catch (e2) {
        return c2.json(e2, 500);
      }
    });
  };
  route(path, app10) {
    const pathForOpenAPI = path.replaceAll(/:([^\/]+)/g, "{$1}");
    super.route(path, app10);
    if (!(app10 instanceof _OpenAPIHono)) {
      return this;
    }
    app10.openAPIRegistry.definitions.forEach((def) => {
      switch (def.type) {
        case "component":
          return this.openAPIRegistry.registerComponent(def.componentType, def.name, def.component);
        case "route":
          return this.openAPIRegistry.registerPath({
            ...def.route,
            path: mergePath(pathForOpenAPI, def.route.path)
          });
        case "webhook":
          return this.openAPIRegistry.registerWebhook({
            ...def.webhook,
            path: mergePath(pathForOpenAPI, def.webhook.path)
          });
        case "schema":
          return this.openAPIRegistry.register(def.schema._def.openapi._internal.refId, def.schema);
        case "parameter":
          return this.openAPIRegistry.registerParameter(
            def.schema._def.openapi._internal.refId,
            def.schema
          );
        default: {
          const errorIfNotExhaustive = def;
          throw new Error(`Unknown registry type: ${errorIfNotExhaustive}`);
        }
      }
    });
    return this;
  }
  basePath(path) {
    return new _OpenAPIHono({ ...super.basePath(path), defaultHook: this.defaultHook });
  }
};
var createRoute = (routeConfig) => {
  const route = {
    ...routeConfig,
    getRoutingPath() {
      return routeConfig.path.replaceAll(/\/{(.+?)}/g, "/:$1");
    }
  };
  return Object.defineProperty(route, "getRoutingPath", { enumerable: false });
};
extendZodWithOpenApi(z);

// ../../node_modules/hono/dist/middleware/bearer-auth/index.js
init_checked_fetch();
init_modules_watch_stub();
var TOKEN_STRINGS = "[A-Za-z0-9._~+/-]+=*";
var PREFIX = "Bearer";
var HEADER = "Authorization";
var bearerAuth = (options) => {
  if (!("token" in options || "verifyToken" in options)) {
    throw new Error('bearer auth middleware requires options for "token"');
  }
  if (!options.realm) {
    options.realm = "";
  }
  if (!options.prefix) {
    options.prefix = PREFIX;
  }
  const realm = options.realm?.replace(/"/g, '\\"');
  return async function bearerAuth2(c2, next) {
    const headerToken = c2.req.header(options.headerName || HEADER);
    if (!headerToken) {
      const res = new Response("Unauthorized", {
        status: 401,
        headers: {
          "WWW-Authenticate": `${options.prefix} realm="` + realm + '"'
        }
      });
      throw new HTTPException(401, { res });
    } else {
      const regexp = new RegExp("^" + options.prefix + " +(" + TOKEN_STRINGS + ") *$");
      const match = regexp.exec(headerToken);
      if (!match) {
        const res = new Response("Bad Request", {
          status: 400,
          headers: {
            "WWW-Authenticate": `${options.prefix} error="invalid_request"`
          }
        });
        throw new HTTPException(400, { res });
      } else {
        let equal = false;
        if ("verifyToken" in options) {
          equal = await options.verifyToken(match[1], c2);
        } else if (typeof options.token === "string") {
          equal = await timingSafeEqual(options.token, match[1], options.hashFunction);
        } else if (Array.isArray(options.token) && options.token.length > 0) {
          for (const token of options.token) {
            if (await timingSafeEqual(token, match[1], options.hashFunction)) {
              equal = true;
              break;
            }
          }
        }
        if (!equal) {
          const res = new Response("Unauthorized", {
            status: 401,
            headers: {
              "WWW-Authenticate": `${options.prefix} error="invalid_token"`
            }
          });
          throw new HTTPException(401, { res });
        }
      }
    }
    await next();
  };
};

// ../../node_modules/hono/dist/helper/factory/index.js
init_checked_fetch();
init_modules_watch_stub();
var Factory = class {
  initApp;
  constructor(init2) {
    this.initApp = init2?.initApp;
  }
  createApp = () => {
    const app10 = new Hono2();
    if (this.initApp) {
      this.initApp(app10);
    }
    return app10;
  };
  createMiddleware = (middleware2) => middleware2;
  createHandlers = (...handlers) => {
    return handlers.filter((handler) => handler !== void 0);
  };
};
var createFactory = (init2) => new Factory(init2);
var createMiddleware = (middleware2) => createFactory().createMiddleware(middleware2);

// src/auth/index.ts
init_checked_fetch();
init_modules_watch_stub();

// src/core/error.response.ts
init_checked_fetch();
init_modules_watch_stub();
var { StatusCodes, ReasonPhrases } = (init_httpStatusCode(), __toCommonJS(httpStatusCode_exports));
var ErrorResponse = class extends Error {
  status;
  constructor(message, status) {
    super(message);
    this.status = status;
  }
};
var BadRequestError = class extends ErrorResponse {
  constructor(message = ReasonPhrases.BAD_REQUEST, status = StatusCodes.BAD_REQUEST) {
    super(message, status);
  }
};
var AuthFailureError = class extends ErrorResponse {
  constructor(message = ReasonPhrases.UNAUTHORIZED, status = StatusCodes.UNAUTHORIZED) {
    super(message, status);
  }
};
var NotFoundError2 = class extends ErrorResponse {
  constructor(message = ReasonPhrases.NOT_FOUND, status = StatusCodes.NOT_FOUND) {
    super(message, status);
  }
};
var InternalServerError = class extends ErrorResponse {
  constructor(message = ReasonPhrases.INTERNAL_SERVER_ERROR, status = StatusCodes.INTERNAL_SERVER_ERROR) {
    super(message, status);
  }
};

// src/lib/globalObject.ts
init_checked_fetch();
init_modules_watch_stub();

// src/lib/asyncLocalStorage.ts
init_checked_fetch();
init_modules_watch_stub();
import { AsyncLocalStorage } from "node:async_hooks";
var localStorage = new AsyncLocalStorage();
var asyncLocalStorage = () => ({
  store: (callback) => createMiddleware(async (c2, next) => {
    const obj = callback(c2);
    return localStorage.run(obj, next);
  }),
  get: (key) => {
    const store = localStorage.getStore();
    return store[key];
  }
});

// src/lib/globalObject.ts
var globalObject = asyncLocalStorage();
var getBundleId = () => globalObject.get("bundleId");
var getDb = () => globalObject.get("db");
var getBucketName = () => globalObject.get("bucketName");
var getUSERNAME = () => globalObject.get("USERNAME");
var getPASSWORD = () => globalObject.get("PASSWORD");

// src/auth/index.ts
var basicAuthMiddware = createMiddleware(async (c2, next) => {
  const Authorization2 = c2.req.header("Authorization");
  if (!Authorization2) {
    throw new BadRequestError("Authorization header is missing.");
  }
  const { user, pass: pass2 } = basicAuthentication(Authorization2);
  verifyCredentials(user, pass2);
  await next();
});
var verifyCredentials = (user, pass2) => {
  const USERNAME = getUSERNAME();
  if (!USERNAME) {
    throw new InternalServerError(
      "Not found USERNAME in environment variables."
    );
  }
  if (USERNAME !== user) {
    throw new AuthFailureError("Invalid credentials.");
  }
  const PASSWORD = getPASSWORD();
  if (!PASSWORD) {
    throw new InternalServerError(
      "Not found PASSWORD in environment variables."
    );
  }
  if (PASSWORD !== pass2) {
    throw new AuthFailureError("Invalid credentials.");
  }
};
var basicAuthentication = (Authorization2) => {
  const [scheme, encoded] = Authorization2.split(" ");
  if (!encoded || scheme !== "Basic") {
    throw new BadRequestError("Malformed authorization header.");
  }
  const buffer = Uint8Array.from(
    atob(encoded),
    (character) => character.charCodeAt(0)
  );
  const decoded = new TextDecoder().decode(buffer).normalize();
  const index = decoded.indexOf(":");
  if (index === -1 || /[\0-\x1F\x7F]/.test(decoded)) {
    throw new BadRequestError("Invalid authorization value.");
  }
  return {
    user: decoded.substring(0, index),
    pass: decoded.substring(index + 1)
  };
};

// src/auth/swaggerAuth.ts
init_checked_fetch();
init_modules_watch_stub();
var swaggerBasicAuth = createMiddleware(async (c2, next) => {
  const authHeader = c2.req.header("Authorization");
  if (!authHeader) {
    return c2.text("Unauthorized", 401, {
      "WWW-Authenticate": 'Basic realm="Restricted Area"'
    });
  }
  if (!authHeader?.startsWith("Basic ")) {
    return c2.text("Unauthorized", 401, {
      "WWW-Authenticate": 'Basic realm="Restricted Area"'
    });
  }
  const { user, pass: pass2 } = basicAuthentication(authHeader);
  verifyCredentials(user, pass2);
  await next();
});

// src/lib/cloudflare-r2.ts
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/middleware-expect-continue/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/protocol-http/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/protocol-http/dist-es/extensions/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/protocol-http/dist-es/extensions/httpExtensionConfiguration.js
init_checked_fetch();
init_modules_watch_stub();
var getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
  let httpHandler = runtimeConfig.httpHandler;
  return {
    setHttpHandler(handler) {
      httpHandler = handler;
    },
    httpHandler() {
      return httpHandler;
    },
    updateHttpClientConfig(key, value) {
      httpHandler.updateHttpClientConfig(key, value);
    },
    httpHandlerConfigs() {
      return httpHandler.httpHandlerConfigs();
    }
  };
};
var resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
  return {
    httpHandler: httpHandlerExtensionConfiguration.httpHandler()
  };
};

// ../../node_modules/@smithy/protocol-http/dist-es/Field.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/abort.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/auth/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/auth/auth.js
init_checked_fetch();
init_modules_watch_stub();
var HttpAuthLocation;
(function(HttpAuthLocation2) {
  HttpAuthLocation2["HEADER"] = "header";
  HttpAuthLocation2["QUERY"] = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));

// ../../node_modules/@smithy/types/dist-es/auth/HttpApiKeyAuth.js
init_checked_fetch();
init_modules_watch_stub();
var HttpApiKeyAuthLocation;
(function(HttpApiKeyAuthLocation2) {
  HttpApiKeyAuthLocation2["HEADER"] = "header";
  HttpApiKeyAuthLocation2["QUERY"] = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));

// ../../node_modules/@smithy/types/dist-es/auth/HttpAuthScheme.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/auth/HttpAuthSchemeProvider.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/auth/HttpSigner.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/auth/IdentityProviderConfig.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/blob/blob-payload-input-types.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/checksum.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/client.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/command.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/connection/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/connection/config.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/connection/manager.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/connection/pool.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/crypto.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/encode.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/endpoint.js
init_checked_fetch();
init_modules_watch_stub();
var EndpointURLScheme;
(function(EndpointURLScheme2) {
  EndpointURLScheme2["HTTP"] = "http";
  EndpointURLScheme2["HTTPS"] = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));

// ../../node_modules/@smithy/types/dist-es/endpoints/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/endpoints/EndpointRuleObject.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/endpoints/ErrorRuleObject.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/endpoints/RuleSetObject.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/endpoints/shared.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/endpoints/TreeRuleObject.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/eventStream.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/extensions/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/extensions/defaultClientConfiguration.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/extensions/checksum.js
init_checked_fetch();
init_modules_watch_stub();
var AlgorithmId;
(function(AlgorithmId2) {
  AlgorithmId2["MD5"] = "md5";
  AlgorithmId2["CRC32"] = "crc32";
  AlgorithmId2["CRC32C"] = "crc32c";
  AlgorithmId2["SHA1"] = "sha1";
  AlgorithmId2["SHA256"] = "sha256";
})(AlgorithmId || (AlgorithmId = {}));

// ../../node_modules/@smithy/types/dist-es/extensions/defaultExtensionConfiguration.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/http.js
init_checked_fetch();
init_modules_watch_stub();
var FieldPosition;
(function(FieldPosition2) {
  FieldPosition2[FieldPosition2["HEADER"] = 0] = "HEADER";
  FieldPosition2[FieldPosition2["TRAILER"] = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));

// ../../node_modules/@smithy/types/dist-es/http/httpHandlerInitialization.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/identity/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/identity/apiKeyIdentity.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/identity/awsCredentialIdentity.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/identity/identity.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/identity/tokenIdentity.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/logger.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/middleware.js
init_checked_fetch();
init_modules_watch_stub();
var SMITHY_CONTEXT_KEY = "__smithy_context";

// ../../node_modules/@smithy/types/dist-es/pagination.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/profile.js
init_checked_fetch();
init_modules_watch_stub();
var IniSectionType;
(function(IniSectionType2) {
  IniSectionType2["PROFILE"] = "profile";
  IniSectionType2["SSO_SESSION"] = "sso-session";
  IniSectionType2["SERVICES"] = "services";
})(IniSectionType || (IniSectionType = {}));

// ../../node_modules/@smithy/types/dist-es/response.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/retry.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/serde.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/shapes.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/signature.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/stream.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-common-types.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-input-types.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/streaming-payload/streaming-blob-payload-output-types.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/transfer.js
init_checked_fetch();
init_modules_watch_stub();
var RequestHandlerProtocol;
(function(RequestHandlerProtocol2) {
  RequestHandlerProtocol2["HTTP_0_9"] = "http/0.9";
  RequestHandlerProtocol2["HTTP_1_0"] = "http/1.0";
  RequestHandlerProtocol2["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));

// ../../node_modules/@smithy/types/dist-es/transform/client-payload-blob-type-narrow.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/transform/no-undefined.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/transform/type-transform.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/uri.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/util.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/types/dist-es/waiter.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/protocol-http/dist-es/Fields.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/protocol-http/dist-es/httpHandler.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/protocol-http/dist-es/httpRequest.js
init_checked_fetch();
init_modules_watch_stub();
var HttpRequest = class {
  constructor(options) {
    this.method = options.method || "GET";
    this.hostname = options.hostname || "localhost";
    this.port = options.port;
    this.query = options.query || {};
    this.headers = options.headers || {};
    this.body = options.body;
    this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
    this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
    this.username = options.username;
    this.password = options.password;
    this.fragment = options.fragment;
  }
  static isInstance(request) {
    if (!request)
      return false;
    const req = request;
    return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
  }
  clone() {
    const cloned = new HttpRequest({
      ...this,
      headers: { ...this.headers }
    });
    if (cloned.query)
      cloned.query = cloneQuery(cloned.query);
    return cloned;
  }
};
function cloneQuery(query) {
  return Object.keys(query).reduce((carry, paramName) => {
    const param = query[paramName];
    return {
      ...carry,
      [paramName]: Array.isArray(param) ? [...param] : param
    };
  }, {});
}

// ../../node_modules/@smithy/protocol-http/dist-es/httpResponse.js
init_checked_fetch();
init_modules_watch_stub();
var HttpResponse = class {
  constructor(options) {
    this.statusCode = options.statusCode;
    this.reason = options.reason;
    this.headers = options.headers || {};
    this.body = options.body;
  }
  static isInstance(response) {
    if (!response)
      return false;
    const resp = response;
    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
  }
};

// ../../node_modules/@smithy/protocol-http/dist-es/isValidHostname.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/protocol-http/dist-es/types.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/middleware-expect-continue/dist-es/index.js
function addExpectContinueMiddleware(options) {
  return (next) => async (args) => {
    const { request } = args;
    if (HttpRequest.isInstance(request) && request.body && options.runtime === "node") {
      if (options.requestHandler?.constructor?.name !== "FetchHttpHandler") {
        request.headers = {
          ...request.headers,
          Expect: "100-continue"
        };
      }
    }
    return next({
      ...args,
      request
    });
  };
}
var addExpectContinueMiddlewareOptions = {
  step: "build",
  tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
  name: "addExpectContinueMiddleware",
  override: true
};
var getAddExpectContinuePlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(addExpectContinueMiddleware(options), addExpectContinueMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();
function resolveHostHeaderConfig(input) {
  return input;
}
var hostHeaderMiddleware = (options) => (next) => async (args) => {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  const { request } = args;
  const { handlerProtocol = "" } = options.requestHandler.metadata || {};
  if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
    delete request.headers["host"];
    request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
  } else if (!request.headers["host"]) {
    let host = request.hostname;
    if (request.port != null)
      host += `:${request.port}`;
    request.headers["host"] = host;
  }
  return next(args);
};
var hostHeaderMiddlewareOptions = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: true
};
var getHostHeaderPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-logger/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/middleware-logger/dist-es/loggerMiddleware.js
init_checked_fetch();
init_modules_watch_stub();
var loggerMiddleware = () => (next, context) => async (args) => {
  try {
    const response = await next(args);
    const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context;
    const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
    const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
    const { $metadata, ...outputWithoutMetadata } = response.output;
    logger2?.info?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      output: outputFilterSensitiveLog(outputWithoutMetadata),
      metadata: $metadata
    });
    return response;
  } catch (error) {
    const { clientName, commandName, logger: logger2, dynamoDbDocumentClientOptions = {} } = context;
    const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
    const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
    logger2?.error?.({
      clientName,
      commandName,
      input: inputFilterSensitiveLog(args.input),
      error,
      metadata: error.$metadata
    });
    throw error;
  }
};
var loggerMiddlewareOptions = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: true
};
var getLoggerPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();
var TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
var recursionDetectionMiddleware = (options) => (next) => async (args) => {
  const { request } = args;
  if (!HttpRequest.isInstance(request) || options.runtime !== "node" || request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
    return next(args);
  }
  const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
  const traceId = process.env[ENV_TRACE_ID];
  const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
  if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
    request.headers[TRACE_ID_HEADER_NAME] = traceId;
  }
  return next({
    ...args,
    request
  });
};
var addRecursionDetectionMiddlewareOptions = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: true,
  priority: "low"
};
var getRecursionDetectionPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(recursionDetectionMiddleware(options), addRecursionDetectionMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/smithy-client/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/smithy-client/dist-es/NoOpLogger.js
init_checked_fetch();
init_modules_watch_stub();
var NoOpLogger = class {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
};

// ../../node_modules/@smithy/smithy-client/dist-es/client.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-stack/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-stack/dist-es/MiddlewareStack.js
init_checked_fetch();
init_modules_watch_stub();
var getAllAliases = (name2, aliases) => {
  const _aliases = [];
  if (name2) {
    _aliases.push(name2);
  }
  if (aliases) {
    for (const alias of aliases) {
      _aliases.push(alias);
    }
  }
  return _aliases;
};
var getMiddlewareNameWithAliases = (name2, aliases) => {
  return `${name2 || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
var constructStack = () => {
  let absoluteEntries = [];
  let relativeEntries = [];
  let identifyOnResolve = false;
  const entriesNameSet = /* @__PURE__ */ new Set();
  const sort = (entries) => entries.sort((a2, b2) => stepWeights[b2.step] - stepWeights[a2.step] || priorityWeights[b2.priority || "normal"] - priorityWeights[a2.priority || "normal"]);
  const removeByName = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      const aliases = getAllAliases(entry.name, entry.aliases);
      if (aliases.includes(toRemove)) {
        isRemoved = true;
        for (const alias of aliases) {
          entriesNameSet.delete(alias);
        }
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const removeByReference = (toRemove) => {
    let isRemoved = false;
    const filterCb = (entry) => {
      if (entry.middleware === toRemove) {
        isRemoved = true;
        for (const alias of getAllAliases(entry.name, entry.aliases)) {
          entriesNameSet.delete(alias);
        }
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  const cloneTo = (toStack) => {
    absoluteEntries.forEach((entry) => {
      toStack.add(entry.middleware, { ...entry });
    });
    relativeEntries.forEach((entry) => {
      toStack.addRelativeTo(entry.middleware, { ...entry });
    });
    toStack.identifyOnResolve?.(stack.identifyOnResolve());
    return toStack;
  };
  const expandRelativeMiddlewareList = (from) => {
    const expandedMiddlewareList = [];
    from.before.forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    expandedMiddlewareList.push(from);
    from.after.reverse().forEach((entry) => {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
      }
    });
    return expandedMiddlewareList;
  };
  const getMiddlewareList = (debug2 = false) => {
    const normalizedAbsoluteEntries = [];
    const normalizedRelativeEntries = [];
    const normalizedEntriesNameMap = {};
    absoluteEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
        normalizedEntriesNameMap[alias] = normalizedEntry;
      }
      normalizedAbsoluteEntries.push(normalizedEntry);
    });
    relativeEntries.forEach((entry) => {
      const normalizedEntry = {
        ...entry,
        before: [],
        after: []
      };
      for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
        normalizedEntriesNameMap[alias] = normalizedEntry;
      }
      normalizedRelativeEntries.push(normalizedEntry);
    });
    normalizedRelativeEntries.forEach((entry) => {
      if (entry.toMiddleware) {
        const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
        if (toMiddleware === void 0) {
          if (debug2) {
            return;
          }
          throw new Error(`${entry.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(entry.name, entry.aliases)} middleware ${entry.relation} ${entry.toMiddleware}`);
        }
        if (entry.relation === "after") {
          toMiddleware.after.push(entry);
        }
        if (entry.relation === "before") {
          toMiddleware.before.push(entry);
        }
      }
    });
    const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
      wholeList.push(...expandedMiddlewareList);
      return wholeList;
    }, []);
    return mainChain;
  };
  const stack = {
    add: (middleware2, options = {}) => {
      const { name: name2, override, aliases: _aliases } = options;
      const entry = {
        step: "initialize",
        priority: "normal",
        middleware: middleware2,
        ...options
      };
      const aliases = getAllAliases(name2, _aliases);
      if (aliases.length > 0) {
        if (aliases.some((alias) => entriesNameSet.has(alias))) {
          if (!override)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name2, _aliases)}'`);
          for (const alias of aliases) {
            const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a2) => a2 === alias));
            if (toOverrideIndex === -1) {
              continue;
            }
            const toOverride = absoluteEntries[toOverrideIndex];
            if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
              throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by "${getMiddlewareNameWithAliases(name2, _aliases)}" middleware with ${entry.priority} priority in ${entry.step} step.`);
            }
            absoluteEntries.splice(toOverrideIndex, 1);
          }
        }
        for (const alias of aliases) {
          entriesNameSet.add(alias);
        }
      }
      absoluteEntries.push(entry);
    },
    addRelativeTo: (middleware2, options) => {
      const { name: name2, override, aliases: _aliases } = options;
      const entry = {
        middleware: middleware2,
        ...options
      };
      const aliases = getAllAliases(name2, _aliases);
      if (aliases.length > 0) {
        if (aliases.some((alias) => entriesNameSet.has(alias))) {
          if (!override)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name2, _aliases)}'`);
          for (const alias of aliases) {
            const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a2) => a2 === alias));
            if (toOverrideIndex === -1) {
              continue;
            }
            const toOverride = relativeEntries[toOverrideIndex];
            if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
              throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(name2, _aliases)}" middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
            }
            relativeEntries.splice(toOverrideIndex, 1);
          }
        }
        for (const alias of aliases) {
          entriesNameSet.add(alias);
        }
      }
      relativeEntries.push(entry);
    },
    clone: () => cloneTo(constructStack()),
    use: (plugin) => {
      plugin.applyToStack(stack);
    },
    remove: (toRemove) => {
      if (typeof toRemove === "string")
        return removeByName(toRemove);
      else
        return removeByReference(toRemove);
    },
    removeByTag: (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        const { tags, name: name2, aliases: _aliases } = entry;
        if (tags && tags.includes(toRemove)) {
          const aliases = getAllAliases(name2, _aliases);
          for (const alias of aliases) {
            entriesNameSet.delete(alias);
          }
          isRemoved = true;
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    },
    concat: (from) => {
      const cloned = cloneTo(constructStack());
      cloned.use(from);
      cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
      return cloned;
    },
    applyToStack: cloneTo,
    identify: () => {
      return getMiddlewareList(true).map((mw) => {
        const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
        return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
      });
    },
    identifyOnResolve(toggle) {
      if (typeof toggle === "boolean")
        identifyOnResolve = toggle;
      return identifyOnResolve;
    },
    resolve: (handler, context) => {
      for (const middleware2 of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
        handler = middleware2(handler, context);
      }
      if (identifyOnResolve) {
        console.log(stack.identify());
      }
      return handler;
    }
  };
  return stack;
};
var stepWeights = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
};
var priorityWeights = {
  high: 3,
  normal: 2,
  low: 1
};

// ../../node_modules/@smithy/smithy-client/dist-es/client.js
var Client = class {
  constructor(config) {
    this.middlewareStack = constructStack();
    this.config = config;
  }
  send(command, optionsOrCb, cb2) {
    const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
    const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb2;
    const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
    if (callback) {
      handler(command).then((result) => callback(null, result.output), (err2) => callback(err2)).catch(() => {
      });
    } else {
      return handler(command).then((result) => result.output);
    }
  }
  destroy() {
    if (this.config.requestHandler.destroy)
      this.config.requestHandler.destroy();
  }
};

// ../../node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-stream/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-stream/dist-es/blob/transforms.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-base64/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-base64/dist-es/constants.browser.js
init_checked_fetch();
init_modules_watch_stub();
var alphabetByEncoding = {};
var alphabetByValue = new Array(64);
for (let i2 = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i2 + start <= limit; i2++) {
  const char = String.fromCharCode(i2 + start);
  alphabetByEncoding[char] = i2;
  alphabetByValue[i2] = char;
}
for (let i2 = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i2 + start <= limit; i2++) {
  const char = String.fromCharCode(i2 + start);
  const index = i2 + 26;
  alphabetByEncoding[char] = index;
  alphabetByValue[index] = char;
}
for (let i2 = 0; i2 < 10; i2++) {
  alphabetByEncoding[i2.toString(10)] = i2 + 52;
  const char = i2.toString(10);
  const index = i2 + 52;
  alphabetByEncoding[char] = index;
  alphabetByValue[index] = char;
}
alphabetByEncoding["+"] = 62;
alphabetByValue[62] = "+";
alphabetByEncoding["/"] = 63;
alphabetByValue[63] = "/";
var bitsPerLetter = 6;
var bitsPerByte = 8;
var maxLetterValue = 63;

// ../../node_modules/@smithy/util-base64/dist-es/fromBase64.browser.js
var fromBase64 = (input) => {
  let totalByteLength = input.length / 4 * 3;
  if (input.slice(-2) === "==") {
    totalByteLength -= 2;
  } else if (input.slice(-1) === "=") {
    totalByteLength--;
  }
  const out = new ArrayBuffer(totalByteLength);
  const dataView = new DataView(out);
  for (let i2 = 0; i2 < input.length; i2 += 4) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i2, limit = i2 + 3; j2 <= limit; j2++) {
      if (input[j2] !== "=") {
        if (!(input[j2] in alphabetByEncoding)) {
          throw new TypeError(`Invalid character ${input[j2]} in base64 string.`);
        }
        bits |= alphabetByEncoding[input[j2]] << (limit - j2) * bitsPerLetter;
        bitLength += bitsPerLetter;
      } else {
        bits >>= bitsPerLetter;
      }
    }
    const chunkOffset = i2 / 4 * 3;
    bits >>= bitLength % bitsPerByte;
    const byteLength = Math.floor(bitLength / bitsPerByte);
    for (let k2 = 0; k2 < byteLength; k2++) {
      const offset = (byteLength - k2 - 1) * bitsPerByte;
      dataView.setUint8(chunkOffset + k2, (bits & 255 << offset) >> offset);
    }
  }
  return new Uint8Array(out);
};

// ../../node_modules/@smithy/util-base64/dist-es/toBase64.browser.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-utf8/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
init_checked_fetch();
init_modules_watch_stub();
var fromUtf8 = (input) => new TextEncoder().encode(input);

// ../../node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
init_checked_fetch();
init_modules_watch_stub();
var toUint8Array = (data) => {
  if (typeof data === "string") {
    return fromUtf8(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
};

// ../../node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js
init_checked_fetch();
init_modules_watch_stub();
var toUtf8 = (input) => {
  if (typeof input === "string") {
    return input;
  }
  if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
    throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
  }
  return new TextDecoder("utf-8").decode(input);
};

// ../../node_modules/@smithy/util-base64/dist-es/toBase64.browser.js
function toBase64(_input) {
  let input;
  if (typeof _input === "string") {
    input = fromUtf8(_input);
  } else {
    input = _input;
  }
  const isArrayLike = typeof input === "object" && typeof input.length === "number";
  const isUint8Array = typeof input === "object" && typeof input.byteOffset === "number" && typeof input.byteLength === "number";
  if (!isArrayLike && !isUint8Array) {
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  }
  let str = "";
  for (let i2 = 0; i2 < input.length; i2 += 3) {
    let bits = 0;
    let bitLength = 0;
    for (let j2 = i2, limit = Math.min(i2 + 3, input.length); j2 < limit; j2++) {
      bits |= input[j2] << (limit - j2 - 1) * bitsPerByte;
      bitLength += bitsPerByte;
    }
    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
    bits <<= bitClusterCount * bitsPerLetter - bitLength;
    for (let k2 = 1; k2 <= bitClusterCount; k2++) {
      const offset = (bitClusterCount - k2) * bitsPerLetter;
      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];
    }
    str += "==".slice(0, 4 - bitClusterCount);
  }
  return str;
}

// ../../node_modules/@smithy/util-stream/dist-es/blob/transforms.js
function transformToString(payload, encoding = "utf-8") {
  if (encoding === "base64") {
    return toBase64(payload);
  }
  return toUtf8(payload);
}
function transformFromString(str, encoding) {
  if (encoding === "base64") {
    return Uint8ArrayBlobAdapter.mutate(fromBase64(str));
  }
  return Uint8ArrayBlobAdapter.mutate(fromUtf8(str));
}

// ../../node_modules/@smithy/util-stream/dist-es/blob/Uint8ArrayBlobAdapter.js
var Uint8ArrayBlobAdapter = class extends Uint8Array {
  static fromString(source, encoding = "utf-8") {
    switch (typeof source) {
      case "string":
        return transformFromString(source, encoding);
      default:
        throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
    }
  }
  static mutate(source) {
    Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
    return source;
  }
  transformToString(encoding = "utf-8") {
    return transformToString(this, encoding);
  }
};

// ../../node_modules/@smithy/util-stream/dist-es/getAwsChunkedEncodingStream.browser.js
init_checked_fetch();
init_modules_watch_stub();
var getAwsChunkedEncodingStream = (readableStream, options) => {
  const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
  const checksumRequired = base64Encoder !== void 0 && bodyLengthChecker !== void 0 && checksumAlgorithmFn !== void 0 && checksumLocationName !== void 0 && streamHasher !== void 0;
  const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : void 0;
  const reader = readableStream.getReader();
  return new ReadableStream({
    async pull(controller) {
      const { value, done } = await reader.read();
      if (done) {
        controller.enqueue(`0\r
`);
        if (checksumRequired) {
          const checksum = base64Encoder(await digest);
          controller.enqueue(`${checksumLocationName}:${checksum}\r
`);
          controller.enqueue(`\r
`);
        }
        controller.close();
      } else {
        controller.enqueue(`${(bodyLengthChecker(value) || 0).toString(16)}\r
${value}\r
`);
      }
    }
  });
};

// ../../node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/fetch-http-handler/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/querystring-builder/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-uri-escape/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-uri-escape/dist-es/escape-uri.js
init_checked_fetch();
init_modules_watch_stub();
var escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
var hexEncode = (c2) => `%${c2.charCodeAt(0).toString(16).toUpperCase()}`;

// ../../node_modules/@smithy/util-uri-escape/dist-es/escape-uri-path.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/querystring-builder/dist-es/index.js
function buildQueryString(query) {
  const parts = [];
  for (let key of Object.keys(query).sort()) {
    const value = query[key];
    key = escapeUri(key);
    if (Array.isArray(value)) {
      for (let i2 = 0, iLen = value.length; i2 < iLen; i2++) {
        parts.push(`${key}=${escapeUri(value[i2])}`);
      }
    } else {
      let qsEntry = key;
      if (value || typeof value === "string") {
        qsEntry += `=${escapeUri(value)}`;
      }
      parts.push(qsEntry);
    }
  }
  return parts.join("&");
}

// ../../node_modules/@smithy/fetch-http-handler/dist-es/request-timeout.js
init_checked_fetch();
init_modules_watch_stub();
function requestTimeout(timeoutInMs = 0) {
  return new Promise((resolve, reject) => {
    if (timeoutInMs) {
      setTimeout(() => {
        const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
        timeoutError.name = "TimeoutError";
        reject(timeoutError);
      }, timeoutInMs);
    }
  });
}

// ../../node_modules/@smithy/fetch-http-handler/dist-es/fetch-http-handler.js
var keepAliveSupport = {
  supported: Boolean(typeof Request !== "undefined" && "keepalive" in new Request("https://[::1]"))
};
var FetchHttpHandler = class {
  static create(instanceOrOptions) {
    if (typeof instanceOrOptions?.handle === "function") {
      return instanceOrOptions;
    }
    return new FetchHttpHandler(instanceOrOptions);
  }
  constructor(options) {
    if (typeof options === "function") {
      this.configProvider = options().then((opts) => opts || {});
    } else {
      this.config = options ?? {};
      this.configProvider = Promise.resolve(this.config);
    }
  }
  destroy() {
  }
  async handle(request, { abortSignal } = {}) {
    if (!this.config) {
      this.config = await this.configProvider;
    }
    const requestTimeoutInMs = this.config.requestTimeout;
    const keepAlive = this.config.keepAlive === true;
    if (abortSignal?.aborted) {
      const abortError = new Error("Request aborted");
      abortError.name = "AbortError";
      return Promise.reject(abortError);
    }
    let path = request.path;
    const queryString = buildQueryString(request.query || {});
    if (queryString) {
      path += `?${queryString}`;
    }
    if (request.fragment) {
      path += `#${request.fragment}`;
    }
    let auth = "";
    if (request.username != null || request.password != null) {
      const username = request.username ?? "";
      const password = request.password ?? "";
      auth = `${username}:${password}@`;
    }
    const { port, method } = request;
    const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
    const body = method === "GET" || method === "HEAD" ? void 0 : request.body;
    const requestOptions = {
      body,
      headers: new Headers(request.headers),
      method
    };
    if (body) {
      requestOptions.duplex = "half";
    }
    if (typeof AbortController !== "undefined") {
      requestOptions.signal = abortSignal;
    }
    if (keepAliveSupport.supported) {
      requestOptions.keepalive = keepAlive;
    }
    const fetchRequest = new Request(url, requestOptions);
    const raceOfPromises = [
      fetch(fetchRequest).then((response) => {
        const fetchHeaders = response.headers;
        const transformedHeaders = {};
        for (const pair of fetchHeaders.entries()) {
          transformedHeaders[pair[0]] = pair[1];
        }
        const hasReadableStream = response.body != void 0;
        if (!hasReadableStream) {
          return response.blob().then((body2) => ({
            response: new HttpResponse({
              headers: transformedHeaders,
              reason: response.statusText,
              statusCode: response.status,
              body: body2
            })
          }));
        }
        return {
          response: new HttpResponse({
            headers: transformedHeaders,
            reason: response.statusText,
            statusCode: response.status,
            body: response.body
          })
        };
      }),
      requestTimeout(requestTimeoutInMs)
    ];
    if (abortSignal) {
      raceOfPromises.push(new Promise((resolve, reject) => {
        abortSignal.onabort = () => {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
        };
      }));
    }
    return Promise.race(raceOfPromises);
  }
  updateHttpClientConfig(key, value) {
    this.config = void 0;
    this.configProvider = this.configProvider.then((config) => {
      config[key] = value;
      return config;
    });
  }
  httpHandlerConfigs() {
    return this.config ?? {};
  }
};

// ../../node_modules/@smithy/fetch-http-handler/dist-es/stream-collector.js
init_checked_fetch();
init_modules_watch_stub();
var streamCollector = (stream) => {
  if (typeof Blob === "function" && stream instanceof Blob) {
    return collectBlob(stream);
  }
  return collectStream(stream);
};
async function collectBlob(blob) {
  const base64 = await readToBase64(blob);
  const arrayBuffer = fromBase64(base64);
  return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
  const chunks = [];
  const reader = stream.getReader();
  let isDone = false;
  let length = 0;
  while (!isDone) {
    const { done, value } = await reader.read();
    if (value) {
      chunks.push(value);
      length += value.length;
    }
    isDone = done;
  }
  const collected = new Uint8Array(length);
  let offset = 0;
  for (const chunk of chunks) {
    collected.set(chunk, offset);
    offset += chunk.length;
  }
  return collected;
}
function readToBase64(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      if (reader.readyState !== 2) {
        return reject(new Error("Reader aborted too early"));
      }
      const result = reader.result ?? "";
      const commaIndex = result.indexOf(",");
      const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
      resolve(result.substring(dataOffset));
    };
    reader.onabort = () => reject(new Error("Read aborted"));
    reader.onerror = () => reject(reader.error);
    reader.readAsDataURL(blob);
  });
}

// ../../node_modules/@smithy/util-hex-encoding/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();
var SHORT_TO_HEX = {};
var HEX_TO_SHORT = {};
for (let i2 = 0; i2 < 256; i2++) {
  let encodedByte = i2.toString(16).toLowerCase();
  if (encodedByte.length === 1) {
    encodedByte = `0${encodedByte}`;
  }
  SHORT_TO_HEX[i2] = encodedByte;
  HEX_TO_SHORT[encodedByte] = i2;
}
function fromHex(encoded) {
  if (encoded.length % 2 !== 0) {
    throw new Error("Hex encoded strings must have an even number length");
  }
  const out = new Uint8Array(encoded.length / 2);
  for (let i2 = 0; i2 < encoded.length; i2 += 2) {
    const encodedByte = encoded.slice(i2, i2 + 2).toLowerCase();
    if (encodedByte in HEX_TO_SHORT) {
      out[i2 / 2] = HEX_TO_SHORT[encodedByte];
    } else {
      throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
    }
  }
  return out;
}
function toHex(bytes) {
  let out = "";
  for (let i2 = 0; i2 < bytes.byteLength; i2++) {
    out += SHORT_TO_HEX[bytes[i2]];
  }
  return out;
}

// ../../node_modules/@smithy/util-stream/dist-es/sdk-stream-mixin.browser.js
var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
var sdkStreamMixin = (stream) => {
  if (!isBlobInstance(stream) && !isReadableStreamInstance(stream)) {
    const name2 = stream?.__proto__?.constructor?.name || stream;
    throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name2}`);
  }
  let transformed = false;
  const transformToByteArray = async () => {
    if (transformed) {
      throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
    }
    transformed = true;
    return await streamCollector(stream);
  };
  const blobToWebStream = (blob) => {
    if (typeof blob.stream !== "function") {
      throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
    }
    return blob.stream();
  };
  return Object.assign(stream, {
    transformToByteArray,
    transformToString: async (encoding) => {
      const buf = await transformToByteArray();
      if (encoding === "base64") {
        return toBase64(buf);
      } else if (encoding === "hex") {
        return toHex(buf);
      } else if (encoding === void 0 || encoding === "utf8" || encoding === "utf-8") {
        return toUtf8(buf);
      } else if (typeof TextDecoder === "function") {
        return new TextDecoder(encoding).decode(buf);
      } else {
        throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
      }
    },
    transformToWebStream: () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      if (isBlobInstance(stream)) {
        return blobToWebStream(stream);
      } else if (isReadableStreamInstance(stream)) {
        return stream;
      } else {
        throw new Error(`Cannot transform payload to web stream, got ${stream}`);
      }
    }
  });
};
var isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
var isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;

// ../../node_modules/@smithy/smithy-client/dist-es/collect-stream-body.js
var collectBody = async (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Uint8ArrayBlobAdapter.mutate(streamBody);
  }
  if (!streamBody) {
    return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
  }
  const fromContext = context.streamCollector(streamBody);
  return Uint8ArrayBlobAdapter.mutate(await fromContext);
};

// ../../node_modules/@smithy/smithy-client/dist-es/command.js
init_checked_fetch();
init_modules_watch_stub();
var Command = class {
  constructor() {
    this.middlewareStack = constructStack();
  }
  static classBuilder() {
    return new ClassBuilder();
  }
  resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
    for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
      this.middlewareStack.use(mw);
    }
    const stack = clientStack.concat(this.middlewareStack);
    const { logger: logger2 } = configuration;
    const handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog,
      outputFilterSensitiveLog,
      [SMITHY_CONTEXT_KEY]: {
        ...smithyContext
      },
      ...additionalContext
    };
    const { requestHandler } = configuration;
    return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
  }
};
var ClassBuilder = class {
  constructor() {
    this._init = () => {
    };
    this._ep = {};
    this._middlewareFn = () => [];
    this._commandName = "";
    this._clientName = "";
    this._additionalContext = {};
    this._smithyContext = {};
    this._inputFilterSensitiveLog = (_) => _;
    this._outputFilterSensitiveLog = (_) => _;
    this._serializer = null;
    this._deserializer = null;
  }
  init(cb2) {
    this._init = cb2;
  }
  ep(endpointParameterInstructions) {
    this._ep = endpointParameterInstructions;
    return this;
  }
  m(middlewareSupplier) {
    this._middlewareFn = middlewareSupplier;
    return this;
  }
  s(service, operation, smithyContext = {}) {
    this._smithyContext = {
      service,
      operation,
      ...smithyContext
    };
    return this;
  }
  c(additionalContext = {}) {
    this._additionalContext = additionalContext;
    return this;
  }
  n(clientName, commandName) {
    this._clientName = clientName;
    this._commandName = commandName;
    return this;
  }
  f(inputFilter = (_) => _, outputFilter = (_) => _) {
    this._inputFilterSensitiveLog = inputFilter;
    this._outputFilterSensitiveLog = outputFilter;
    return this;
  }
  ser(serializer) {
    this._serializer = serializer;
    return this;
  }
  de(deserializer) {
    this._deserializer = deserializer;
    return this;
  }
  build() {
    const closure = this;
    let CommandRef;
    return CommandRef = class extends Command {
      static getEndpointParameterInstructions() {
        return closure._ep;
      }
      constructor(...[input]) {
        super();
        this.serialize = closure._serializer;
        this.deserialize = closure._deserializer;
        this.input = input ?? {};
        closure._init(this);
      }
      resolveMiddleware(stack, configuration, options) {
        return this.resolveMiddlewareWithContext(stack, configuration, options, {
          CommandCtor: CommandRef,
          middlewareFn: closure._middlewareFn,
          clientName: closure._clientName,
          commandName: closure._commandName,
          inputFilterSensitiveLog: closure._inputFilterSensitiveLog,
          outputFilterSensitiveLog: closure._outputFilterSensitiveLog,
          smithyContext: closure._smithyContext,
          additionalContext: closure._additionalContext
        });
      }
    };
  }
};

// ../../node_modules/@smithy/smithy-client/dist-es/constants.js
init_checked_fetch();
init_modules_watch_stub();
var SENSITIVE_STRING = "***SensitiveInformation***";

// ../../node_modules/@smithy/smithy-client/dist-es/create-aggregated-client.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/smithy-client/dist-es/date-utils.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/smithy-client/dist-es/parse-utils.js
init_checked_fetch();
init_modules_watch_stub();
var expectNumber = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    const parsed = parseFloat(value);
    if (!Number.isNaN(parsed)) {
      if (String(parsed) !== String(value)) {
        logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
      }
      return parsed;
    }
  }
  if (typeof value === "number") {
    return value;
  }
  throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
var expectFloat32 = (value) => {
  const expected = expectNumber(value);
  if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
    if (Math.abs(expected) > MAX_FLOAT) {
      throw new TypeError(`Expected 32-bit float, got ${value}`);
    }
  }
  return expected;
};
var expectLong = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (Number.isInteger(value) && !Number.isNaN(value)) {
    return value;
  }
  throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
var expectShort = (value) => expectSizedInt(value, 16);
var expectByte = (value) => expectSizedInt(value, 8);
var expectSizedInt = (value, size) => {
  const expected = expectLong(value);
  if (expected !== void 0 && castInt(expected, size) !== expected) {
    throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
  }
  return expected;
};
var castInt = (value, size) => {
  switch (size) {
    case 32:
      return Int32Array.of(value)[0];
    case 16:
      return Int16Array.of(value)[0];
    case 8:
      return Int8Array.of(value)[0];
  }
};
var expectNonNull = (value, location) => {
  if (value === null || value === void 0) {
    if (location) {
      throw new TypeError(`Expected a non-null value for ${location}`);
    }
    throw new TypeError("Expected a non-null value");
  }
  return value;
};
var expectObject = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "object" && !Array.isArray(value)) {
    return value;
  }
  const receivedType = Array.isArray(value) ? "array" : typeof value;
  throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
var expectString = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value === "string") {
    return value;
  }
  if (["boolean", "number", "bigint"].includes(typeof value)) {
    logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
    return String(value);
  }
  throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
var strictParseFloat32 = (value) => {
  if (typeof value == "string") {
    return expectFloat32(parseNumber(value));
  }
  return expectFloat32(value);
};
var NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
var parseNumber = (value) => {
  const matches = value.match(NUMBER_REGEX);
  if (matches === null || matches[0].length !== value.length) {
    throw new TypeError(`Expected real number, got implicit NaN`);
  }
  return parseFloat(value);
};
var strictParseShort = (value) => {
  if (typeof value === "string") {
    return expectShort(parseNumber(value));
  }
  return expectShort(value);
};
var strictParseByte = (value) => {
  if (typeof value === "string") {
    return expectByte(parseNumber(value));
  }
  return expectByte(value);
};
var stackTraceWarning = (message) => {
  return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s2) => !s2.includes("stackTraceWarning")).join("\n");
};
var logger = {
  warn: console.warn
};

// ../../node_modules/@smithy/smithy-client/dist-es/date-utils.js
var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
var RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
var parseRfc3339DateTimeWithOffset = (value) => {
  if (value === null || value === void 0) {
    return void 0;
  }
  if (typeof value !== "string") {
    throw new TypeError("RFC-3339 date-times must be expressed as strings");
  }
  const match = RFC3339_WITH_OFFSET.exec(value);
  if (!match) {
    throw new TypeError("Invalid RFC-3339 date-time value");
  }
  const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
  const year = strictParseShort(stripLeadingZeroes(yearStr));
  const month = parseDateValue(monthStr, "month", 1, 12);
  const day = parseDateValue(dayStr, "day", 1, 31);
  const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
  if (offsetStr.toUpperCase() != "Z") {
    date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
  }
  return date;
};
var IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
var ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
var buildDate = (year, month, day, time) => {
  const adjustedMonth = month - 1;
  validateDayOfMonth(year, adjustedMonth, day);
  return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var validateDayOfMonth = (year, month, day) => {
  let maxDays = DAYS_IN_MONTH[month];
  if (month === 1 && isLeapYear(year)) {
    maxDays = 29;
  }
  if (day > maxDays) {
    throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
  }
};
var isLeapYear = (year) => {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
var parseDateValue = (value, type, lower, upper) => {
  const dateVal = strictParseByte(stripLeadingZeroes(value));
  if (dateVal < lower || dateVal > upper) {
    throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
  }
  return dateVal;
};
var parseMilliseconds = (value) => {
  if (value === null || value === void 0) {
    return 0;
  }
  return strictParseFloat32("0." + value) * 1e3;
};
var parseOffsetToMilliseconds = (value) => {
  const directionStr = value[0];
  let direction = 1;
  if (directionStr == "+") {
    direction = 1;
  } else if (directionStr == "-") {
    direction = -1;
  } else {
    throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
  }
  const hour = Number(value.substring(1, 3));
  const minute = Number(value.substring(4, 6));
  return direction * (hour * 60 + minute) * 60 * 1e3;
};
var stripLeadingZeroes = (value) => {
  let idx = 0;
  while (idx < value.length - 1 && value.charAt(idx) === "0") {
    idx++;
  }
  if (idx === 0) {
    return value;
  }
  return value.slice(idx);
};

// ../../node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/smithy-client/dist-es/exceptions.js
init_checked_fetch();
init_modules_watch_stub();
var ServiceException = class extends Error {
  constructor(options) {
    super(options.message);
    Object.setPrototypeOf(this, ServiceException.prototype);
    this.name = options.name;
    this.$fault = options.$fault;
    this.$metadata = options.$metadata;
  }
};
var decorateServiceException = (exception, additions = {}) => {
  Object.entries(additions).filter(([, v2]) => v2 !== void 0).forEach(([k2, v2]) => {
    if (exception[k2] == void 0 || exception[k2] === "") {
      exception[k2] = v2;
    }
  });
  const message = exception.message || exception.Message || "UnknownError";
  exception.message = message;
  delete exception.Message;
  return exception;
};

// ../../node_modules/@smithy/smithy-client/dist-es/default-error-handler.js
var throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
  const $metadata = deserializeMetadata(output);
  const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
  const response = new exceptionCtor({
    name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
    $fault: "client",
    $metadata
  });
  throw decorateServiceException(response, parsedBody);
};
var withBaseException = (ExceptionCtor) => {
  return ({ output, parsedBody, errorCode }) => {
    throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
  };
};
var deserializeMetadata = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});

// ../../node_modules/@smithy/smithy-client/dist-es/defaults-mode.js
init_checked_fetch();
init_modules_watch_stub();
var loadConfigsForDefaultMode = (mode) => {
  switch (mode) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
};

// ../../node_modules/@smithy/smithy-client/dist-es/emitWarningIfUnsupportedVersion.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/smithy-client/dist-es/extensions/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/smithy-client/dist-es/extensions/checksum.js
init_checked_fetch();
init_modules_watch_stub();
var getChecksumConfiguration2 = (runtimeConfig) => {
  const checksumAlgorithms = [];
  for (const id in AlgorithmId) {
    const algorithmId = AlgorithmId[id];
    if (runtimeConfig[algorithmId] === void 0) {
      continue;
    }
    checksumAlgorithms.push({
      algorithmId: () => algorithmId,
      checksumConstructor: () => runtimeConfig[algorithmId]
    });
  }
  return {
    _checksumAlgorithms: checksumAlgorithms,
    addChecksumAlgorithm(algo) {
      this._checksumAlgorithms.push(algo);
    },
    checksumAlgorithms() {
      return this._checksumAlgorithms;
    }
  };
};
var resolveChecksumRuntimeConfig2 = (clientConfig) => {
  const runtimeConfig = {};
  clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
    runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
  });
  return runtimeConfig;
};

// ../../node_modules/@smithy/smithy-client/dist-es/extensions/retry.js
init_checked_fetch();
init_modules_watch_stub();
var getRetryConfiguration = (runtimeConfig) => {
  let _retryStrategy = runtimeConfig.retryStrategy;
  return {
    setRetryStrategy(retryStrategy) {
      _retryStrategy = retryStrategy;
    },
    retryStrategy() {
      return _retryStrategy;
    }
  };
};
var resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
  const runtimeConfig = {};
  runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
  return runtimeConfig;
};

// ../../node_modules/@smithy/smithy-client/dist-es/extensions/defaultExtensionConfiguration.js
var getDefaultExtensionConfiguration = (runtimeConfig) => {
  return {
    ...getChecksumConfiguration2(runtimeConfig),
    ...getRetryConfiguration(runtimeConfig)
  };
};
var resolveDefaultRuntimeConfig = (config) => {
  return {
    ...resolveChecksumRuntimeConfig2(config),
    ...resolveRetryRuntimeConfig(config)
  };
};

// ../../node_modules/@smithy/smithy-client/dist-es/extended-encode-uri-component.js
init_checked_fetch();
init_modules_watch_stub();
function extendedEncodeURIComponent(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}

// ../../node_modules/@smithy/smithy-client/dist-es/get-array-if-single-item.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/smithy-client/dist-es/get-value-from-text-node.js
init_checked_fetch();
init_modules_watch_stub();
var getValueFromTextNode = (obj) => {
  const textNodeName = "#text";
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) {
      obj[key] = obj[key][textNodeName];
    } else if (typeof obj[key] === "object" && obj[key] !== null) {
      obj[key] = getValueFromTextNode(obj[key]);
    }
  }
  return obj;
};

// ../../node_modules/@smithy/smithy-client/dist-es/lazy-json.js
init_checked_fetch();
init_modules_watch_stub();
var StringWrapper = function() {
  const Class = Object.getPrototypeOf(this).constructor;
  const Constructor = Function.bind.apply(String, [null, ...arguments]);
  const instance = new Constructor();
  Object.setPrototypeOf(instance, Class.prototype);
  return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
  constructor: {
    value: StringWrapper,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Object.setPrototypeOf(StringWrapper, String);

// ../../node_modules/@smithy/smithy-client/dist-es/object-mapping.js
init_checked_fetch();
init_modules_watch_stub();
function map(arg0, arg1, arg2) {
  let target;
  let filter;
  let instructions;
  if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
    target = {};
    instructions = arg0;
  } else {
    target = arg0;
    if (typeof arg1 === "function") {
      filter = arg1;
      instructions = arg2;
      return mapWithFilter(target, filter, instructions);
    } else {
      instructions = arg1;
    }
  }
  for (const key of Object.keys(instructions)) {
    if (!Array.isArray(instructions[key])) {
      target[key] = instructions[key];
      continue;
    }
    applyInstruction(target, null, instructions, key);
  }
  return target;
}
var mapWithFilter = (target, filter, instructions) => {
  return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
    if (Array.isArray(value)) {
      _instructions[key] = value;
    } else {
      if (typeof value === "function") {
        _instructions[key] = [filter, value()];
      } else {
        _instructions[key] = [filter, value];
      }
    }
    return _instructions;
  }, {}));
};
var applyInstruction = (target, source, instructions, targetKey) => {
  if (source !== null) {
    let instruction = instructions[targetKey];
    if (typeof instruction === "function") {
      instruction = [, instruction];
    }
    const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
    if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
      target[targetKey] = valueFn(source[sourceKey]);
    }
    return;
  }
  let [filter, value] = instructions[targetKey];
  if (typeof value === "function") {
    let _value;
    const defaultFilterPassed = filter === void 0 && (_value = value()) != null;
    const customFilterPassed = typeof filter === "function" && !!filter(void 0) || typeof filter !== "function" && !!filter;
    if (defaultFilterPassed) {
      target[targetKey] = _value;
    } else if (customFilterPassed) {
      target[targetKey] = value();
    }
  } else {
    const defaultFilterPassed = filter === void 0 && value != null;
    const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
    if (defaultFilterPassed || customFilterPassed) {
      target[targetKey] = value;
    }
  }
};
var nonNullish = (_) => _ != null;
var pass = (_) => _;

// ../../node_modules/@smithy/smithy-client/dist-es/resolve-path.js
init_checked_fetch();
init_modules_watch_stub();
var resolvedPath = (resolvedPath2, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
  if (input != null && input[memberName] !== void 0) {
    const labelValue = labelValueProvider();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
    }
    resolvedPath2 = resolvedPath2.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent(segment)).join("/") : extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: " + memberName + ".");
  }
  return resolvedPath2;
};

// ../../node_modules/@smithy/smithy-client/dist-es/ser-utils.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/smithy-client/dist-es/serde-json.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/smithy-client/dist-es/split-every.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-endpoint-middleware.js
init_checked_fetch();
init_modules_watch_stub();
var regionRedirectEndpointMiddleware = (config) => {
  return (next, context) => async (args) => {
    const originalRegion = await config.region();
    const regionProviderRef = config.region;
    if (context.__s3RegionRedirect) {
      config.region = async () => {
        config.region = regionProviderRef;
        return context.__s3RegionRedirect;
      };
    }
    const result = await next(args);
    if (context.__s3RegionRedirect) {
      const region = await config.region();
      if (originalRegion !== region) {
        throw new Error("Region was not restored following S3 region redirect.");
      }
    }
    return result;
  };
};
var regionRedirectEndpointMiddlewareOptions = {
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectEndpointMiddleware",
  override: true,
  relation: "before",
  toMiddleware: "endpointV2Middleware"
};

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-middleware.js
init_checked_fetch();
init_modules_watch_stub();
function regionRedirectMiddleware(clientConfig) {
  return (next, context) => async (args) => {
    try {
      return await next(args);
    } catch (err2) {
      if (clientConfig.followRegionRedirects && err2?.$metadata?.httpStatusCode === 301) {
        try {
          const actualRegion = err2.$response.headers["x-amz-bucket-region"];
          context.logger?.debug(`Redirecting from ${await clientConfig.region()} to ${actualRegion}`);
          context.__s3RegionRedirect = actualRegion;
        } catch (e2) {
          throw new Error("Region redirect failed: " + e2);
        }
        return next(args);
      } else {
        throw err2;
      }
    }
  };
}
var regionRedirectMiddlewareOptions = {
  step: "initialize",
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectMiddleware",
  override: true
};
var getRegionRedirectMiddlewarePlugin = (clientConfig) => ({
  applyToStack: (clientStack) => {
    clientStack.add(regionRedirectMiddleware(clientConfig), regionRedirectMiddlewareOptions);
    clientStack.addRelativeTo(regionRedirectEndpointMiddleware(clientConfig), regionRedirectEndpointMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-expires-middleware.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCache.js
init_checked_fetch();
init_modules_watch_stub();
var S3ExpressIdentityCache = class {
  constructor(data = {}) {
    this.data = data;
    this.lastPurgeTime = Date.now();
  }
  get(key) {
    const entry = this.data[key];
    if (!entry) {
      return;
    }
    return entry;
  }
  set(key, entry) {
    this.data[key] = entry;
    return entry;
  }
  delete(key) {
    delete this.data[key];
  }
  async purgeExpired() {
    const now = Date.now();
    if (this.lastPurgeTime + S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > now) {
      return;
    }
    for (const key in this.data) {
      const entry = this.data[key];
      if (!entry.isRefreshing) {
        const credential = await entry.identity;
        if (credential.expiration) {
          if (credential.expiration.getTime() < now) {
            delete this.data[key];
          }
        }
      }
    }
  }
};
S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCacheEntry.js
init_checked_fetch();
init_modules_watch_stub();
var S3ExpressIdentityCacheEntry = class {
  constructor(_identity, isRefreshing = false, accessed = Date.now()) {
    this._identity = _identity;
    this.isRefreshing = isRefreshing;
    this.accessed = accessed;
  }
  get identity() {
    this.accessed = Date.now();
    return this._identity;
  }
};

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityProviderImpl.js
init_checked_fetch();
init_modules_watch_stub();
var S3ExpressIdentityProviderImpl = class {
  constructor(createSessionFn, cache = new S3ExpressIdentityCache()) {
    this.createSessionFn = createSessionFn;
    this.cache = cache;
  }
  async getS3ExpressIdentity(awsIdentity, identityProperties) {
    const key = identityProperties.Bucket;
    const { cache } = this;
    const entry = cache.get(key);
    if (entry) {
      return entry.identity.then((identity) => {
        const isExpired = (identity.expiration?.getTime() ?? 0) < Date.now();
        if (isExpired) {
          return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
        }
        const isExpiringSoon = (identity.expiration?.getTime() ?? 0) < Date.now() + S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;
        if (isExpiringSoon && !entry.isRefreshing) {
          entry.isRefreshing = true;
          this.getIdentity(key).then((id) => {
            cache.set(key, new S3ExpressIdentityCacheEntry(Promise.resolve(id)));
          });
        }
        return identity;
      });
    }
    return cache.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
  }
  async getIdentity(key) {
    await this.cache.purgeExpired().catch((error) => {
      console.warn("Error while clearing expired entries in S3ExpressIdentityCache: \n" + error);
    });
    const session = await this.createSessionFn(key);
    if (!session.Credentials?.AccessKeyId || !session.Credentials?.SecretAccessKey) {
      throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
    }
    const identity = {
      accessKeyId: session.Credentials.AccessKeyId,
      secretAccessKey: session.Credentials.SecretAccessKey,
      sessionToken: session.Credentials.SessionToken,
      expiration: session.Credentials.Expiration ? new Date(session.Credentials.Expiration) : void 0
    };
    return identity;
  }
};
S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS = 6e4;

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/signature-v4/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/signature-v4/dist-es/SignatureV4.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-middleware/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-middleware/dist-es/getSmithyContext.js
init_checked_fetch();
init_modules_watch_stub();
var getSmithyContext = (context) => context[SMITHY_CONTEXT_KEY] || (context[SMITHY_CONTEXT_KEY] = {});

// ../../node_modules/@smithy/util-middleware/dist-es/normalizeProvider.js
init_checked_fetch();
init_modules_watch_stub();
var normalizeProvider = (input) => {
  if (typeof input === "function")
    return input;
  const promisified = Promise.resolve(input);
  return () => promisified;
};

// ../../node_modules/@smithy/signature-v4/dist-es/constants.js
init_checked_fetch();
init_modules_watch_stub();
var ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
var CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
var SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
var EXPIRES_QUERY_PARAM = "X-Amz-Expires";
var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
var AUTH_HEADER = "authorization";
var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
var DATE_HEADER = "date";
var GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
var SHA256_HEADER = "x-amz-content-sha256";
var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
var ALWAYS_UNSIGNABLE_HEADERS = {
  authorization: true,
  "cache-control": true,
  connection: true,
  expect: true,
  from: true,
  "keep-alive": true,
  "max-forwards": true,
  pragma: true,
  referer: true,
  te: true,
  trailer: true,
  "transfer-encoding": true,
  upgrade: true,
  "user-agent": true,
  "x-amzn-trace-id": true
};
var PROXY_HEADER_PATTERN = /^proxy-/;
var SEC_HEADER_PATTERN = /^sec-/;
var ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
var EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
var MAX_CACHE_SIZE = 50;
var KEY_TYPE_IDENTIFIER = "aws4_request";
var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;

// ../../node_modules/@smithy/signature-v4/dist-es/credentialDerivation.js
init_checked_fetch();
init_modules_watch_stub();
var signingKeyCache = {};
var cacheQueue = [];
var createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
var getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
  const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
  const cacheKey = `${shortDate}:${region}:${service}:${toHex(credsHash)}:${credentials.sessionToken}`;
  if (cacheKey in signingKeyCache) {
    return signingKeyCache[cacheKey];
  }
  cacheQueue.push(cacheKey);
  while (cacheQueue.length > MAX_CACHE_SIZE) {
    delete signingKeyCache[cacheQueue.shift()];
  }
  let key = `AWS4${credentials.secretAccessKey}`;
  for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
    key = await hmac(sha256Constructor, key, signable);
  }
  return signingKeyCache[cacheKey] = key;
};
var hmac = (ctor, secret, data) => {
  const hash = new ctor(secret);
  hash.update(toUint8Array(data));
  return hash.digest();
};

// ../../node_modules/@smithy/signature-v4/dist-es/getCanonicalHeaders.js
init_checked_fetch();
init_modules_watch_stub();
var getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
  const canonical = {};
  for (const headerName of Object.keys(headers).sort()) {
    if (headers[headerName] == void 0) {
      continue;
    }
    const canonicalHeaderName = headerName.toLowerCase();
    if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
      if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
        continue;
      }
    }
    canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
  }
  return canonical;
};

// ../../node_modules/@smithy/signature-v4/dist-es/getCanonicalQuery.js
init_checked_fetch();
init_modules_watch_stub();
var getCanonicalQuery = ({ query = {} }) => {
  const keys = [];
  const serialized = {};
  for (const key of Object.keys(query).sort()) {
    if (key.toLowerCase() === SIGNATURE_HEADER) {
      continue;
    }
    keys.push(key);
    const value = query[key];
    if (typeof value === "string") {
      serialized[key] = `${escapeUri(key)}=${escapeUri(value)}`;
    } else if (Array.isArray(value)) {
      serialized[key] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${escapeUri(key)}=${escapeUri(value2)}`]), []).sort().join("&");
    }
  }
  return keys.map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
};

// ../../node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/is-array-buffer/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();
var isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

// ../../node_modules/@smithy/signature-v4/dist-es/getPayloadHash.js
var getPayloadHash = async ({ headers, body }, hashConstructor) => {
  for (const headerName of Object.keys(headers)) {
    if (headerName.toLowerCase() === SHA256_HEADER) {
      return headers[headerName];
    }
  }
  if (body == void 0) {
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer(body)) {
    const hashCtor = new hashConstructor();
    hashCtor.update(toUint8Array(body));
    return toHex(await hashCtor.digest());
  }
  return UNSIGNED_PAYLOAD;
};

// ../../node_modules/@smithy/signature-v4/dist-es/HeaderFormatter.js
init_checked_fetch();
init_modules_watch_stub();
var HeaderFormatter = class {
  format(headers) {
    const chunks = [];
    for (const headerName of Object.keys(headers)) {
      const bytes = fromUtf8(headerName);
      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
    }
    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
    let position = 0;
    for (const chunk of chunks) {
      out.set(chunk, position);
      position += chunk.byteLength;
    }
    return out;
  }
  formatHeaderValue(header) {
    switch (header.type) {
      case "boolean":
        return Uint8Array.from([header.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, header.value]);
      case "short":
        const shortView = new DataView(new ArrayBuffer(3));
        shortView.setUint8(0, 3);
        shortView.setInt16(1, header.value, false);
        return new Uint8Array(shortView.buffer);
      case "integer":
        const intView = new DataView(new ArrayBuffer(5));
        intView.setUint8(0, 4);
        intView.setInt32(1, header.value, false);
        return new Uint8Array(intView.buffer);
      case "long":
        const longBytes = new Uint8Array(9);
        longBytes[0] = 5;
        longBytes.set(header.value.bytes, 1);
        return longBytes;
      case "binary":
        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
        binView.setUint8(0, 6);
        binView.setUint16(1, header.value.byteLength, false);
        const binBytes = new Uint8Array(binView.buffer);
        binBytes.set(header.value, 3);
        return binBytes;
      case "string":
        const utf8Bytes = fromUtf8(header.value);
        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
        strView.setUint8(0, 7);
        strView.setUint16(1, utf8Bytes.byteLength, false);
        const strBytes = new Uint8Array(strView.buffer);
        strBytes.set(utf8Bytes, 3);
        return strBytes;
      case "timestamp":
        const tsBytes = new Uint8Array(9);
        tsBytes[0] = 8;
        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
        return tsBytes;
      case "uuid":
        if (!UUID_PATTERN.test(header.value)) {
          throw new Error(`Invalid UUID received: ${header.value}`);
        }
        const uuidBytes = new Uint8Array(17);
        uuidBytes[0] = 9;
        uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
        return uuidBytes;
    }
  }
};
var HEADER_VALUE_TYPE;
(function(HEADER_VALUE_TYPE3) {
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolTrue"] = 0] = "boolTrue";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolFalse"] = 1] = "boolFalse";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byte"] = 2] = "byte";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["short"] = 3] = "short";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["integer"] = 4] = "integer";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["long"] = 5] = "long";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byteArray"] = 6] = "byteArray";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["string"] = 7] = "string";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["timestamp"] = 8] = "timestamp";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
var Int64 = class {
  constructor(bytes) {
    this.bytes = bytes;
    if (bytes.byteLength !== 8) {
      throw new Error("Int64 buffers must be exactly 8 bytes");
    }
  }
  static fromNumber(number) {
    if (number > 9223372036854776e3 || number < -9223372036854776e3) {
      throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
    }
    const bytes = new Uint8Array(8);
    for (let i2 = 7, remaining = Math.abs(Math.round(number)); i2 > -1 && remaining > 0; i2--, remaining /= 256) {
      bytes[i2] = remaining;
    }
    if (number < 0) {
      negate(bytes);
    }
    return new Int64(bytes);
  }
  valueOf() {
    const bytes = this.bytes.slice(0);
    const negative = bytes[0] & 128;
    if (negative) {
      negate(bytes);
    }
    return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
};
function negate(bytes) {
  for (let i2 = 0; i2 < 8; i2++) {
    bytes[i2] ^= 255;
  }
  for (let i2 = 7; i2 > -1; i2--) {
    bytes[i2]++;
    if (bytes[i2] !== 0)
      break;
  }
}

// ../../node_modules/@smithy/signature-v4/dist-es/headerUtil.js
init_checked_fetch();
init_modules_watch_stub();
var hasHeader = (soughtHeader, headers) => {
  soughtHeader = soughtHeader.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      return true;
    }
  }
  return false;
};

// ../../node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/signature-v4/dist-es/cloneRequest.js
init_checked_fetch();
init_modules_watch_stub();
var cloneRequest = ({ headers, query, ...rest }) => ({
  ...rest,
  headers: { ...headers },
  query: query ? cloneQuery2(query) : void 0
});
var cloneQuery2 = (query) => Object.keys(query).reduce((carry, paramName) => {
  const param = query[paramName];
  return {
    ...carry,
    [paramName]: Array.isArray(param) ? [...param] : param
  };
}, {});

// ../../node_modules/@smithy/signature-v4/dist-es/moveHeadersToQuery.js
var moveHeadersToQuery = (request, options = {}) => {
  const { headers, query = {} } = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
  for (const name2 of Object.keys(headers)) {
    const lname = name2.toLowerCase();
    if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) {
      query[name2] = headers[name2];
      delete headers[name2];
    }
  }
  return {
    ...request,
    headers,
    query
  };
};

// ../../node_modules/@smithy/signature-v4/dist-es/prepareRequest.js
init_checked_fetch();
init_modules_watch_stub();
var prepareRequest = (request) => {
  request = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
  for (const headerName of Object.keys(request.headers)) {
    if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
      delete request.headers[headerName];
    }
  }
  return request;
};

// ../../node_modules/@smithy/signature-v4/dist-es/utilDate.js
init_checked_fetch();
init_modules_watch_stub();
var iso8601 = (time) => toDate(time).toISOString().replace(/\.\d{3}Z$/, "Z");
var toDate = (time) => {
  if (typeof time === "number") {
    return new Date(time * 1e3);
  }
  if (typeof time === "string") {
    if (Number(time)) {
      return new Date(Number(time) * 1e3);
    }
    return new Date(time);
  }
  return time;
};

// ../../node_modules/@smithy/signature-v4/dist-es/SignatureV4.js
var SignatureV4 = class {
  constructor({ applyChecksum, credentials, region, service, sha256: sha2562, uriEscapePath = true }) {
    this.headerFormatter = new HeaderFormatter();
    this.service = service;
    this.sha256 = sha2562;
    this.uriEscapePath = uriEscapePath;
    this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
    this.regionProvider = normalizeProvider(region);
    this.credentialProvider = normalizeProvider(credentials);
  }
  async presign(originalRequest, options = {}) {
    const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService } = options;
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const { longDate, shortDate } = formatDate(signingDate);
    if (expiresIn > MAX_PRESIGNED_TTL) {
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    }
    const scope = createScope(shortDate, region, signingService ?? this.service);
    const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });
    if (credentials.sessionToken) {
      request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
    }
    request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
    request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
    request.query[AMZ_DATE_QUERY_PARAM] = longDate;
    request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
    request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
    request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
    return request;
  }
  async sign(toSign, options) {
    if (typeof toSign === "string") {
      return this.signString(toSign, options);
    } else if (toSign.headers && toSign.payload) {
      return this.signEvent(toSign, options);
    } else if (toSign.message) {
      return this.signMessage(toSign, options);
    } else {
      return this.signRequest(toSign, options);
    }
  }
  async signEvent({ headers, payload }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate, longDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService ?? this.service);
    const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
    const hash = new this.sha256();
    hash.update(headers);
    const hashedHeaders = toHex(await hash.digest());
    const stringToSign = [
      EVENT_ALGORITHM_IDENTIFIER,
      longDate,
      scope,
      priorSignature,
      hashedHeaders,
      hashedPayload
    ].join("\n");
    return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
  }
  async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService }) {
    const promise = this.signEvent({
      headers: this.headerFormatter.format(signableMessage.message.headers),
      payload: signableMessage.message.body
    }, {
      signingDate,
      signingRegion,
      signingService,
      priorSignature: signableMessage.priorSignature
    });
    return promise.then((signature) => {
      return { message: signableMessage.message, signature };
    });
  }
  async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const { shortDate } = formatDate(signingDate);
    const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
    hash.update(toUint8Array(stringToSign));
    return toHex(await hash.digest());
  }
  async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
    const credentials = await this.credentialProvider();
    this.validateResolvedCredentials(credentials);
    const region = signingRegion ?? await this.regionProvider();
    const request = prepareRequest(requestToSign);
    const { longDate, shortDate } = formatDate(signingDate);
    const scope = createScope(shortDate, region, signingService ?? this.service);
    request.headers[AMZ_DATE_HEADER] = longDate;
    if (credentials.sessionToken) {
      request.headers[TOKEN_HEADER] = credentials.sessionToken;
    }
    const payloadHash = await getPayloadHash(request, this.sha256);
    if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
      request.headers[SHA256_HEADER] = payloadHash;
    }
    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
    const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
    request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature}`;
    return request;
  }
  createCanonicalRequest(request, canonicalHeaders, payloadHash) {
    const sortedHeaders = Object.keys(canonicalHeaders).sort();
    return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name2) => `${name2}:${canonicalHeaders[name2]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
  }
  async createStringToSign(longDate, credentialScope, canonicalRequest) {
    const hash = new this.sha256();
    hash.update(toUint8Array(canonicalRequest));
    const hashedRequest = await hash.digest();
    return `${ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${toHex(hashedRequest)}`;
  }
  getCanonicalPath({ path }) {
    if (this.uriEscapePath) {
      const normalizedPathSegments = [];
      for (const pathSegment of path.split("/")) {
        if (pathSegment?.length === 0)
          continue;
        if (pathSegment === ".")
          continue;
        if (pathSegment === "..") {
          normalizedPathSegments.pop();
        } else {
          normalizedPathSegments.push(pathSegment);
        }
      }
      const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
      const doubleEncoded = escapeUri(normalizedPath);
      return doubleEncoded.replace(/%2F/g, "/");
    }
    return path;
  }
  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
    const hash = new this.sha256(await keyPromise);
    hash.update(toUint8Array(stringToSign));
    return toHex(await hash.digest());
  }
  getSigningKey(credentials, region, shortDate, service) {
    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
  }
  validateResolvedCredentials(credentials) {
    if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
      throw new Error("Resolved credential object is not valid");
    }
  }
};
var formatDate = (now) => {
  const longDate = iso8601(now).replace(/[\-:]/g, "");
  return {
    longDate,
    shortDate: longDate.slice(0, 8)
  };
};
var getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(";");

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-config-provider/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-config-provider/dist-es/booleanSelector.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-config-provider/dist-es/numberSelector.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-config-provider/dist-es/types.js
init_checked_fetch();
init_modules_watch_stub();
var SelectorType;
(function(SelectorType2) {
  SelectorType2["ENV"] = "env";
  SelectorType2["CONFIG"] = "shared config entry";
})(SelectorType || (SelectorType = {}));

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js
var S3_EXPRESS_BUCKET_TYPE = "Directory";
var S3_EXPRESS_BACKEND = "S3Express";
var S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express";
var SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
var SESSION_TOKEN_HEADER = SESSION_TOKEN_QUERY_PARAM.toLowerCase();

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js
var SignatureV4S3Express = class extends SignatureV4 {
  async signWithCredentials(requestToSign, credentials, options) {
    const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
    requestToSign.headers[SESSION_TOKEN_HEADER] = credentials.sessionToken;
    const privateAccess = this;
    setSingleOverride(privateAccess, credentialsWithoutSessionToken);
    return privateAccess.signRequest(requestToSign, options ?? {});
  }
  async presignWithCredentials(requestToSign, credentials, options) {
    const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
    delete requestToSign.headers[SESSION_TOKEN_HEADER];
    requestToSign.headers[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
    requestToSign.query = requestToSign.query ?? {};
    requestToSign.query[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
    const privateAccess = this;
    setSingleOverride(privateAccess, credentialsWithoutSessionToken);
    return this.presign(requestToSign, options);
  }
};
function getCredentialsWithoutSessionToken(credentials) {
  const credentialsWithoutSessionToken = {
    accessKeyId: credentials.accessKeyId,
    secretAccessKey: credentials.secretAccessKey,
    expiration: credentials.expiration
  };
  return credentialsWithoutSessionToken;
}
function setSingleOverride(privateAccess, credentialsWithoutSessionToken) {
  const id = setTimeout(() => {
    throw new Error("SignatureV4S3Express credential override was created but not called.");
  }, 10);
  const currentCredentialProvider = privateAccess.credentialProvider;
  const overrideCredentialsProviderOnce = () => {
    clearTimeout(id);
    privateAccess.credentialProvider = currentCredentialProvider;
    return Promise.resolve(credentialsWithoutSessionToken);
  };
  privateAccess.credentialProvider = overrideCredentialsProviderOnce;
}

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressMiddleware.js
init_checked_fetch();
init_modules_watch_stub();
var s3ExpressMiddleware = (options) => {
  return (next, context) => async (args) => {
    if (context.endpointV2) {
      const endpoint = context.endpointV2;
      const isS3ExpressAuth = endpoint.properties?.authSchemes?.[0]?.name === S3_EXPRESS_AUTH_SCHEME;
      const isS3ExpressBucket = endpoint.properties?.backend === S3_EXPRESS_BACKEND || endpoint.properties?.bucketType === S3_EXPRESS_BUCKET_TYPE;
      if (isS3ExpressBucket) {
        context.isS3ExpressBucket = true;
      }
      if (isS3ExpressAuth) {
        const requestBucket = args.input.Bucket;
        if (requestBucket) {
          const s3ExpressIdentity = await options.s3ExpressIdentityProvider.getS3ExpressIdentity(await options.credentials(), {
            Bucket: requestBucket
          });
          context.s3ExpressIdentity = s3ExpressIdentity;
          if (HttpRequest.isInstance(args.request) && s3ExpressIdentity.sessionToken) {
            args.request.headers[SESSION_TOKEN_HEADER] = s3ExpressIdentity.sessionToken;
          }
        }
      }
    }
    return next(args);
  };
};
var s3ExpressMiddlewareOptions = {
  name: "s3ExpressMiddleware",
  step: "build",
  tags: ["S3", "S3_EXPRESS"],
  override: true
};
var getS3ExpressPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(s3ExpressMiddleware(options), s3ExpressMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3Configuration.js
init_checked_fetch();
init_modules_watch_stub();
var resolveS3Config = (input, { session }) => {
  const [s3ClientProvider, CreateSessionCommandCtor] = session;
  return {
    ...input,
    forcePathStyle: input.forcePathStyle ?? false,
    useAccelerateEndpoint: input.useAccelerateEndpoint ?? false,
    disableMultiregionAccessPoints: input.disableMultiregionAccessPoints ?? false,
    followRegionRedirects: input.followRegionRedirects ?? false,
    s3ExpressIdentityProvider: input.s3ExpressIdentityProvider ?? new S3ExpressIdentityProviderImpl(async (key) => s3ClientProvider().send(new CreateSessionCommandCtor({
      Bucket: key,
      SessionMode: "ReadWrite"
    }))),
    bucketEndpoint: input.bucketEndpoint ?? false
  };
};

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/throw-200-exceptions.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-arn-parser/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();
var validate = (str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6;

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/bucket-endpoint-middleware.js
init_checked_fetch();
init_modules_watch_stub();
function bucketEndpointMiddleware(options) {
  return (next, context) => async (args) => {
    if (options.bucketEndpoint) {
      const endpoint = context.endpointV2;
      if (endpoint) {
        const bucket = args.input.Bucket;
        if (typeof bucket === "string") {
          try {
            const bucketEndpointUrl = new URL(bucket);
            endpoint.url = bucketEndpointUrl;
          } catch (e2) {
            const warning = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${bucket} could not be parsed as URL.`;
            if (context.logger?.constructor?.name === "NoOpLogger") {
              console.warn(warning);
            } else {
              context.logger?.warn?.(warning);
            }
            throw e2;
          }
        }
      }
    }
    return next(args);
  };
}
var bucketEndpointMiddlewareOptions = {
  name: "bucketEndpointMiddleware",
  override: true,
  relation: "after",
  toMiddleware: "endpointV2Middleware"
};

// ../../node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js
function validateBucketNameMiddleware({ bucketEndpoint }) {
  return (next) => async (args) => {
    const { input: { Bucket } } = args;
    if (!bucketEndpoint && typeof Bucket === "string" && !validate(Bucket) && Bucket.indexOf("/") >= 0) {
      const err2 = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
      err2.name = "InvalidBucketName";
      throw err2;
    }
    return next({ ...args });
  };
}
var validateBucketNameMiddlewareOptions = {
  step: "initialize",
  tags: ["VALIDATE_BUCKET_NAME"],
  name: "validateBucketNameMiddleware",
  override: true
};
var getValidateBucketNamePlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(validateBucketNameMiddleware(options), validateBucketNameMiddlewareOptions);
    clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthConfiguration.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/property-provider/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/property-provider/dist-es/CredentialsProviderError.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/property-provider/dist-es/ProviderError.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/property-provider/dist-es/TokenProviderError.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/property-provider/dist-es/chain.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/property-provider/dist-es/fromStatic.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/property-provider/dist-es/memoize.js
init_checked_fetch();
init_modules_watch_stub();
var memoize = (provider, isExpired, requiresRefresh) => {
  let resolved;
  let pending;
  let hasResult;
  let isConstant = false;
  const coalesceProvider = async () => {
    if (!pending) {
      pending = provider();
    }
    try {
      resolved = await pending;
      hasResult = true;
      isConstant = false;
    } finally {
      pending = void 0;
    }
    return resolved;
  };
  if (isExpired === void 0) {
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider();
      }
      return resolved;
    };
  }
  return async (options) => {
    if (!hasResult || options?.forceRefresh) {
      resolved = await coalesceProvider();
    }
    if (isConstant) {
      return resolved;
    }
    if (requiresRefresh && !requiresRefresh(resolved)) {
      isConstant = true;
      return resolved;
    }
    if (isExpired(resolved)) {
      await coalesceProvider();
      return resolved;
    }
    return resolved;
  };
};

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthConfiguration.js
var CREDENTIAL_EXPIRE_WINDOW = 3e5;
var resolveAwsAuthConfig = (input) => {
  const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(Object.assign({}, input, {
    parentClientConfig: input
  }));
  const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256: sha2562 } = input;
  let signer;
  if (input.signer) {
    signer = normalizeProvider(input.signer);
  } else if (input.regionInfoProvider) {
    signer = () => normalizeProvider(input.region)().then(async (region) => [
      await input.regionInfoProvider(region, {
        useFipsEndpoint: await input.useFipsEndpoint(),
        useDualstackEndpoint: await input.useDualstackEndpoint()
      }) || {},
      region
    ]).then(([regionInfo, region]) => {
      const { signingRegion, signingService } = regionInfo;
      input.signingRegion = input.signingRegion || signingRegion || region;
      input.signingName = input.signingName || signingService || input.serviceId;
      const params = {
        ...input,
        credentials: normalizedCreds,
        region: input.signingRegion,
        service: input.signingName,
        sha256: sha2562,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    });
  } else {
    signer = async (authScheme) => {
      authScheme = Object.assign({}, {
        name: "sigv4",
        signingName: input.signingName || input.defaultSigningName,
        signingRegion: await normalizeProvider(input.region)(),
        properties: {}
      }, authScheme);
      const isSigv4a = authScheme?.name === "sigv4a";
      const signingRegion = authScheme.signingRegion;
      const signingService = authScheme.signingName;
      let regionForSigner;
      if (isSigv4a) {
        regionForSigner = input.signingRegion || signingRegion;
      } else {
        input.signingRegion = input.signingRegion || signingRegion;
        regionForSigner = input.signingRegion;
      }
      input.signingName = input.signingName || signingService || input.serviceId;
      const params = {
        ...input,
        credentials: normalizedCreds,
        region: regionForSigner,
        service: input.signingName,
        sha256: sha2562,
        uriEscapePath: signingEscapePath
      };
      const SignerCtor = input.signerConstructor || SignatureV4;
      return new SignerCtor(params);
    };
  }
  return {
    ...input,
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer
  };
};
var normalizeCredentialProvider = (credentials) => {
  if (typeof credentials === "function") {
    return memoize(credentials, (credentials2) => credentials2.expiration !== void 0 && credentials2.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (credentials2) => credentials2.expiration !== void 0);
  }
  return normalizeProvider(credentials);
};

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthMiddleware.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getSkewCorrectedDate.js
init_checked_fetch();
init_modules_watch_stub();
var getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getUpdatedSystemClockOffset.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/isClockSkewed.js
init_checked_fetch();
init_modules_watch_stub();
var isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5;

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
  const clockTimeInMs = Date.parse(clockTime);
  if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
    return clockTimeInMs - Date.now();
  }
  return currentSystemClockOffset;
};

// ../../node_modules/@aws-sdk/middleware-signing/dist-es/awsAuthMiddleware.js
var awsAuthMiddleware = (options) => (next, context) => async function(args) {
  if (!HttpRequest.isInstance(args.request))
    return next(args);
  let authScheme;
  let signer;
  const firstAuthScheme = context.endpointV2?.properties?.authSchemes?.[0];
  const secondAuthScheme = context.endpointV2?.properties?.authSchemes?.[1];
  const firstAuthSchemeIsSigv4a = firstAuthScheme?.name === "sigv4a";
  if (firstAuthSchemeIsSigv4a && secondAuthScheme) {
    signer = await options.signer(authScheme = firstAuthScheme);
    const uncheckedSigner = signer;
    const sigv4aAvailable = (() => {
      if (typeof uncheckedSigner?.getSigv4aSigner === "function") {
        if (uncheckedSigner?.signerOptions?.runtime !== "node") {
          return false;
        }
        try {
          uncheckedSigner.getSigv4aSigner();
          return true;
        } catch (e2) {
        }
      }
      return false;
    })();
    if (!sigv4aAvailable) {
      signer = await options.signer(authScheme = secondAuthScheme);
    }
  } else {
    signer = await options.signer(authScheme = firstAuthScheme);
  }
  let signedRequest;
  const multiRegionOverride = authScheme?.name === "sigv4a" ? authScheme?.signingRegionSet?.join(",") : void 0;
  const signingOptions = {
    signingDate: getSkewCorrectedDate(options.systemClockOffset),
    signingRegion: multiRegionOverride || context["signing_region"],
    signingService: context["signing_service"]
  };
  if (context.s3ExpressIdentity) {
    const sigV4MultiRegion = signer;
    signedRequest = await sigV4MultiRegion.signWithCredentials(args.request, context.s3ExpressIdentity, signingOptions);
    if (signedRequest.headers["X-Amz-Security-Token"] || signedRequest.headers["x-amz-security-token"]) {
      throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
    }
  } else {
    signedRequest = await signer.sign(args.request, signingOptions);
  }
  const output = await next({
    ...args,
    request: signedRequest
  }).catch((error) => {
    const serverTime = error.ServerTime ?? getDateHeader(error.$response);
    if (serverTime) {
      options.systemClockOffset = getUpdatedSystemClockOffset(serverTime, options.systemClockOffset);
    }
    throw error;
  });
  const dateHeader = getDateHeader(output.response);
  if (dateHeader) {
    options.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, options.systemClockOffset);
  }
  return output;
};
var getDateHeader = (response) => HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : void 0;
var awsAuthMiddlewareOptions = {
  name: "awsAuthMiddleware",
  tags: ["SIGNATURE", "AWSAUTH"],
  relation: "after",
  toMiddleware: "retryMiddleware",
  override: true
};
var getAwsAuthPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(awsAuthMiddleware(options), awsAuthMiddlewareOptions);
  }
});

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/configurations.js
init_checked_fetch();
init_modules_watch_stub();
function resolveUserAgentConfig(input) {
  return {
    ...input,
    customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent
  };
}

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/aws.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/isIpAddress.js
init_checked_fetch();
init_modules_watch_stub();
var IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
var isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/isValidHostLabel.js
init_checked_fetch();
init_modules_watch_stub();
var VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
var isValidHostLabel = (value, allowSubDomains = false) => {
  if (!allowSubDomains) {
    return VALID_HOST_LABEL_REGEX.test(value);
  }
  const labels = value.split(".");
  for (const label of labels) {
    if (!isValidHostLabel(label)) {
      return false;
    }
  }
  return true;
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/customEndpointFunctions.js
init_checked_fetch();
init_modules_watch_stub();
var customEndpointFunctions = {};

// ../../node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/debug/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/debug/debugId.js
init_checked_fetch();
init_modules_watch_stub();
var debugId = "endpoints";

// ../../node_modules/@smithy/util-endpoints/dist-es/debug/toDebugString.js
init_checked_fetch();
init_modules_watch_stub();
function toDebugString(input) {
  if (typeof input !== "object" || input == null) {
    return input;
  }
  if ("ref" in input) {
    return `$${toDebugString(input.ref)}`;
  }
  if ("fn" in input) {
    return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
  }
  return JSON.stringify(input, null, 2);
}

// ../../node_modules/@smithy/util-endpoints/dist-es/types/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/types/EndpointError.js
init_checked_fetch();
init_modules_watch_stub();
var EndpointError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "EndpointError";
  }
};

// ../../node_modules/@smithy/util-endpoints/dist-es/types/EndpointFunctions.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/types/EndpointRuleObject.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/types/ErrorRuleObject.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/types/RuleSetObject.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/types/TreeRuleObject.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/types/shared.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateEndpointRule.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/callFunction.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/endpointFunctions.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/booleanEquals.js
init_checked_fetch();
init_modules_watch_stub();
var booleanEquals = (value1, value2) => value1 === value2;

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/getAttr.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/getAttrPathList.js
init_checked_fetch();
init_modules_watch_stub();
var getAttrPathList = (path) => {
  const parts = path.split(".");
  const pathList = [];
  for (const part of parts) {
    const squareBracketIndex = part.indexOf("[");
    if (squareBracketIndex !== -1) {
      if (part.indexOf("]") !== part.length - 1) {
        throw new EndpointError(`Path: '${path}' does not end with ']'`);
      }
      const arrayIndex = part.slice(squareBracketIndex + 1, -1);
      if (Number.isNaN(parseInt(arrayIndex))) {
        throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
      }
      if (squareBracketIndex !== 0) {
        pathList.push(part.slice(0, squareBracketIndex));
      }
      pathList.push(arrayIndex);
    } else {
      pathList.push(part);
    }
  }
  return pathList;
};

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/getAttr.js
var getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {
  if (typeof acc !== "object") {
    throw new EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
  } else if (Array.isArray(acc)) {
    return acc[parseInt(index)];
  }
  return acc[index];
}, value);

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/isSet.js
init_checked_fetch();
init_modules_watch_stub();
var isSet = (value) => value != null;

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/not.js
init_checked_fetch();
init_modules_watch_stub();
var not = (value) => !value;

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/parseURL.js
init_checked_fetch();
init_modules_watch_stub();
var DEFAULT_PORTS = {
  [EndpointURLScheme.HTTP]: 80,
  [EndpointURLScheme.HTTPS]: 443
};
var parseURL = (value) => {
  const whatwgURL = (() => {
    try {
      if (value instanceof URL) {
        return value;
      }
      if (typeof value === "object" && "hostname" in value) {
        const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
        const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
        url.search = Object.entries(query).map(([k2, v2]) => `${k2}=${v2}`).join("&");
        return url;
      }
      return new URL(value);
    } catch (error) {
      return null;
    }
  })();
  if (!whatwgURL) {
    console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
    return null;
  }
  const urlString = whatwgURL.href;
  const { host, hostname, pathname, protocol, search } = whatwgURL;
  if (search) {
    return null;
  }
  const scheme = protocol.slice(0, -1);
  if (!Object.values(EndpointURLScheme).includes(scheme)) {
    return null;
  }
  const isIp = isIpAddress(hostname);
  const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
  const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
  return {
    scheme,
    authority,
    path: pathname,
    normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
    isIp
  };
};

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/stringEquals.js
init_checked_fetch();
init_modules_watch_stub();
var stringEquals = (value1, value2) => value1 === value2;

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/substring.js
init_checked_fetch();
init_modules_watch_stub();
var substring = (input, start, stop, reverse) => {
  if (start >= stop || input.length < stop) {
    return null;
  }
  if (!reverse) {
    return input.substring(start, stop);
  }
  return input.substring(input.length - stop, input.length - start);
};

// ../../node_modules/@smithy/util-endpoints/dist-es/lib/uriEncode.js
init_checked_fetch();
init_modules_watch_stub();
var uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c2) => `%${c2.charCodeAt(0).toString(16).toUpperCase()}`);

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/endpointFunctions.js
var endpointFunctions = {
  booleanEquals,
  getAttr,
  isSet,
  isValidHostLabel,
  not,
  parseURL,
  stringEquals,
  substring,
  uriEncode
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateExpression.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTemplate.js
init_checked_fetch();
init_modules_watch_stub();
var evaluateTemplate = (template, options) => {
  const evaluatedTemplateArr = [];
  const templateContext = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  let currentIndex = 0;
  while (currentIndex < template.length) {
    const openingBraceIndex = template.indexOf("{", currentIndex);
    if (openingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(currentIndex));
      break;
    }
    evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
    const closingBraceIndex = template.indexOf("}", openingBraceIndex);
    if (closingBraceIndex === -1) {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex));
      break;
    }
    if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
      evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
      currentIndex = closingBraceIndex + 2;
    }
    const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
    if (parameterName.includes("#")) {
      const [refName, attrName] = parameterName.split("#");
      evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
    } else {
      evaluatedTemplateArr.push(templateContext[parameterName]);
    }
    currentIndex = closingBraceIndex + 1;
  }
  return evaluatedTemplateArr.join("");
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/getReferenceValue.js
init_checked_fetch();
init_modules_watch_stub();
var getReferenceValue = ({ ref }, options) => {
  const referenceRecord = {
    ...options.endpointParams,
    ...options.referenceRecord
  };
  return referenceRecord[ref];
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateExpression.js
var evaluateExpression = (obj, keyName, options) => {
  if (typeof obj === "string") {
    return evaluateTemplate(obj, options);
  } else if (obj["fn"]) {
    return callFunction(obj, options);
  } else if (obj["ref"]) {
    return getReferenceValue(obj, options);
  }
  throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/callFunction.js
var callFunction = ({ fn, argv }, options) => {
  const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : evaluateExpression(arg, "arg", options));
  const fnSegments = fn.split(".");
  if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
    return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
  }
  return endpointFunctions[fn](...evaluatedArgs);
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateCondition.js
var evaluateCondition = ({ assign, ...fnArgs }, options) => {
  if (assign && assign in options.referenceRecord) {
    throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
  }
  const value = callFunction(fnArgs, options);
  options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
  return {
    result: value === "" ? true : !!value,
    ...assign != null && { toAssign: { name: assign, value } }
  };
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateConditions.js
var evaluateConditions = (conditions = [], options) => {
  const conditionsReferenceRecord = {};
  for (const condition of conditions) {
    const { result, toAssign } = evaluateCondition(condition, {
      ...options,
      referenceRecord: {
        ...options.referenceRecord,
        ...conditionsReferenceRecord
      }
    });
    if (!result) {
      return { result };
    }
    if (toAssign) {
      conditionsReferenceRecord[toAssign.name] = toAssign.value;
      options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
    }
  }
  return { result: true, referenceRecord: conditionsReferenceRecord };
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointHeaders.js
init_checked_fetch();
init_modules_watch_stub();
var getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
  ...acc,
  [headerKey]: headerVal.map((headerValEntry) => {
    const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
    if (typeof processedExpr !== "string") {
      throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
    }
    return processedExpr;
  })
}), {});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperties.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperty.js
init_checked_fetch();
init_modules_watch_stub();
var getEndpointProperty = (property, options) => {
  if (Array.isArray(property)) {
    return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
  }
  switch (typeof property) {
    case "string":
      return evaluateTemplate(property, options);
    case "object":
      if (property === null) {
        throw new EndpointError(`Unexpected endpoint property: ${property}`);
      }
      return getEndpointProperties(property, options);
    case "boolean":
      return property;
    default:
      throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
  }
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointProperties.js
var getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
  ...acc,
  [propertyKey]: getEndpointProperty(propertyVal, options)
}), {});

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/getEndpointUrl.js
init_checked_fetch();
init_modules_watch_stub();
var getEndpointUrl = (endpointUrl, options) => {
  const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
  if (typeof expression === "string") {
    try {
      return new URL(expression);
    } catch (error) {
      console.error(`Failed to construct URL with ${expression}`, error);
      throw error;
    }
  }
  throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateEndpointRule.js
var evaluateEndpointRule = (endpointRule, options) => {
  const { conditions, endpoint } = endpointRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  const endpointRuleOptions = {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  };
  const { url, properties, headers } = endpoint;
  options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
  return {
    ...headers != void 0 && {
      headers: getEndpointHeaders(headers, endpointRuleOptions)
    },
    ...properties != void 0 && {
      properties: getEndpointProperties(properties, endpointRuleOptions)
    },
    url: getEndpointUrl(url, endpointRuleOptions)
  };
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateErrorRule.js
init_checked_fetch();
init_modules_watch_stub();
var evaluateErrorRule = (errorRule, options) => {
  const { conditions, error } = errorRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  throw new EndpointError(evaluateExpression(error, "Error", {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  }));
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateTreeRule.js
init_checked_fetch();
init_modules_watch_stub();
var evaluateTreeRule = (treeRule, options) => {
  const { conditions, rules } = treeRule;
  const { result, referenceRecord } = evaluateConditions(conditions, options);
  if (!result) {
    return;
  }
  return evaluateRules(rules, {
    ...options,
    referenceRecord: { ...options.referenceRecord, ...referenceRecord }
  });
};

// ../../node_modules/@smithy/util-endpoints/dist-es/utils/evaluateRules.js
var evaluateRules = (rules, options) => {
  for (const rule of rules) {
    if (rule.type === "endpoint") {
      const endpointOrUndefined = evaluateEndpointRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else if (rule.type === "error") {
      evaluateErrorRule(rule, options);
    } else if (rule.type === "tree") {
      const endpointOrUndefined = evaluateTreeRule(rule, options);
      if (endpointOrUndefined) {
        return endpointOrUndefined;
      }
    } else {
      throw new EndpointError(`Unknown endpoint rule: ${rule}`);
    }
  }
  throw new EndpointError(`Rules evaluation failed`);
};

// ../../node_modules/@smithy/util-endpoints/dist-es/resolveEndpoint.js
var resolveEndpoint = (ruleSetObject, options) => {
  const { endpointParams, logger: logger2 } = options;
  const { parameters, rules } = ruleSetObject;
  options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
  const paramsWithDefault = Object.entries(parameters).filter(([, v2]) => v2.default != null).map(([k2, v2]) => [k2, v2.default]);
  if (paramsWithDefault.length > 0) {
    for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
      endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
    }
  }
  const requiredParams = Object.entries(parameters).filter(([, v2]) => v2.required).map(([k2]) => k2);
  for (const requiredParam of requiredParams) {
    if (endpointParams[requiredParam] == null) {
      throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
    }
  }
  const endpoint = evaluateRules(rules, { endpointParams, logger: logger2, referenceRecord: {} });
  if (options.endpointParams?.Endpoint) {
    try {
      const givenEndpoint = new URL(options.endpointParams.Endpoint);
      const { protocol, port } = givenEndpoint;
      endpoint.url.protocol = protocol;
      endpoint.url.port = port;
    } catch (e2) {
    }
  }
  options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
  return endpoint;
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/isIpAddress.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/isVirtualHostableS3Bucket.js
var isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
  if (allowSubDomains) {
    for (const label of value.split(".")) {
      if (!isVirtualHostableS3Bucket(label)) {
        return false;
      }
    }
    return true;
  }
  if (!isValidHostLabel(value)) {
    return false;
  }
  if (value.length < 3 || value.length > 63) {
    return false;
  }
  if (value !== value.toLowerCase()) {
    return false;
  }
  if (isIpAddress(value)) {
    return false;
  }
  return true;
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/parseArn.js
init_checked_fetch();
init_modules_watch_stub();
var parseArn = (value) => {
  const segments = value.split(":");
  if (segments.length < 6)
    return null;
  const [arn, partition2, service, region, accountId, ...resourceId] = segments;
  if (arn !== "arn" || partition2 === "" || service === "" || resourceId[0] === "")
    return null;
  return {
    partition: partition2,
    service,
    region,
    accountId,
    resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId
  };
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json
var partitions_default = {
  partitions: [{
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-east-1",
      name: "aws",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "ca-west-1": {
        description: "Canada West (Calgary)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "il-central-1": {
        description: "Israel (Tel Aviv)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  }, {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      implicitGlobalRegion: "cn-northwest-1",
      name: "aws-cn",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  }, {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-gov-west-1",
      name: "aws-us-gov",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  }, {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      implicitGlobalRegion: "us-iso-east-1",
      name: "aws-iso",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  }, {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      implicitGlobalRegion: "us-isob-east-1",
      name: "aws-iso-b",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  }, {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      implicitGlobalRegion: "eu-isoe-west-1",
      name: "aws-iso-e",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {}
  }, {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      implicitGlobalRegion: "us-isof-south-1",
      name: "aws-iso-f",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
  }],
  version: "1.1"
};

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partition.js
var selectedPartitionsInfo = partitions_default;
var selectedUserAgentPrefix = "";
var partition = (value) => {
  const { partitions } = selectedPartitionsInfo;
  for (const partition2 of partitions) {
    const { regions, outputs } = partition2;
    for (const [region, regionData] of Object.entries(regions)) {
      if (region === value) {
        return {
          ...outputs,
          ...regionData
        };
      }
    }
  }
  for (const partition2 of partitions) {
    const { regionRegex, outputs } = partition2;
    if (new RegExp(regionRegex).test(value)) {
      return {
        ...outputs
      };
    }
  }
  const DEFAULT_PARTITION = partitions.find((partition2) => partition2.id === "aws");
  if (!DEFAULT_PARTITION) {
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  }
  return {
    ...DEFAULT_PARTITION.outputs
  };
};
var getUserAgentPrefix = () => selectedUserAgentPrefix;

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/aws.js
var awsEndpointFunctions = {
  isVirtualHostableS3Bucket,
  parseArn,
  partition
};
customEndpointFunctions.aws = awsEndpointFunctions;

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/resolveEndpoint.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointError.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/EndpointRuleObject.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/ErrorRuleObject.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/RuleSetObject.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/TreeRuleObject.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-endpoints/dist-es/types/shared.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/constants.js
init_checked_fetch();
init_modules_watch_stub();
var USER_AGENT = "user-agent";
var X_AMZ_USER_AGENT = "x-amz-user-agent";
var SPACE = " ";
var UA_NAME_SEPARATOR = "/";
var UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
var UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
var UA_ESCAPE_CHAR = "-";

// ../../node_modules/@aws-sdk/middleware-user-agent/dist-es/user-agent-middleware.js
var userAgentMiddleware = (options) => (next, context) => async (args) => {
  const { request } = args;
  if (!HttpRequest.isInstance(request))
    return next(args);
  const { headers } = request;
  const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
  const defaultUserAgent2 = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
  const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
  const prefix = getUserAgentPrefix();
  const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent2, ...userAgent, ...customUserAgent]).join(SPACE);
  const normalUAValue = [
    ...defaultUserAgent2.filter((section) => section.startsWith("aws-sdk-")),
    ...customUserAgent
  ].join(SPACE);
  if (options.runtime !== "browser") {
    if (normalUAValue) {
      headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
    }
    headers[USER_AGENT] = sdkUserAgentValue;
  } else {
    headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
  }
  return next({
    ...args,
    request
  });
};
var escapeUserAgent = (userAgentPair) => {
  const name2 = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
  const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
  const prefixSeparatorIndex = name2.indexOf(UA_NAME_SEPARATOR);
  const prefix = name2.substring(0, prefixSeparatorIndex);
  let uaName = name2.substring(prefixSeparatorIndex + 1);
  if (prefix === "api") {
    uaName = uaName.toLowerCase();
  }
  return [prefix, uaName, version].filter((item) => item && item.length > 0).reduce((acc, item, index) => {
    switch (index) {
      case 0:
        return item;
      case 1:
        return `${acc}/${item}`;
      default:
        return `${acc}#${item}`;
    }
  }, "");
};
var getUserAgentMiddlewareOptions = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: true
};
var getUserAgentPlugin = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
  }
});

// ../../node_modules/@smithy/config-resolver/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseDualstackEndpointConfigOptions.js
init_checked_fetch();
init_modules_watch_stub();
var DEFAULT_USE_DUALSTACK_ENDPOINT = false;

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/NodeUseFipsEndpointConfigOptions.js
init_checked_fetch();
init_modules_watch_stub();
var DEFAULT_USE_FIPS_ENDPOINT = false;

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveCustomEndpointsConfig.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/resolveEndpointsConfig.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/endpointsConfig/utils/getEndpointFromRegion.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/config.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/isFipsRegion.js
init_checked_fetch();
init_modules_watch_stub();
var isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/getRealRegion.js
var getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;

// ../../node_modules/@smithy/config-resolver/dist-es/regionConfig/resolveRegionConfig.js
var resolveRegionConfig = (input) => {
  const { region, useFipsEndpoint } = input;
  if (!region) {
    throw new Error("Region is missing");
  }
  return {
    ...input,
    region: async () => {
      if (typeof region === "string") {
        return getRealRegion(region);
      }
      const providedRegion = await region();
      return getRealRegion(providedRegion);
    },
    useFipsEndpoint: async () => {
      const providedRegion = typeof region === "string" ? region : await region();
      if (isFipsRegion(providedRegion)) {
        return true;
      }
      return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
    }
  };
};

// ../../node_modules/@smithy/config-resolver/dist-es/regionInfo/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/regionInfo/PartitionHash.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/regionInfo/RegionHash.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/regionInfo/getRegionInfo.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/regionInfo/getHostnameFromVariants.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedHostname.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedPartition.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/config-resolver/dist-es/regionInfo/getResolvedSigningRegion.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-serde-config-resolver/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-serde-config-resolver/dist-es/EventStreamSerdeConfig.js
init_checked_fetch();
init_modules_watch_stub();
var resolveEventStreamSerdeConfig = (input) => ({
  ...input,
  eventStreamMarshaller: input.eventStreamSerdeProvider(input)
});

// ../../node_modules/@smithy/middleware-content-length/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();
var CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
  return (next) => async (args) => {
    const request = args.request;
    if (HttpRequest.isInstance(request)) {
      const { body, headers } = request;
      if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
        try {
          const length = bodyLengthChecker(body);
          request.headers = {
            ...request.headers,
            [CONTENT_LENGTH_HEADER]: String(length)
          };
        } catch (error) {
        }
      }
    }
    return next({
      ...args,
      request
    });
  };
}
var contentLengthMiddlewareOptions = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: true
};
var getContentLengthPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
  }
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-endpoint/dist-es/service-customizations/s3.js
init_checked_fetch();
init_modules_watch_stub();
var resolveParamsForS3 = async (endpointParams) => {
  const bucket = endpointParams?.Bucket || "";
  if (typeof endpointParams.Bucket === "string") {
    endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
  }
  if (isArnBucketName(bucket)) {
    if (endpointParams.ForcePathStyle === true) {
      throw new Error("Path-style addressing cannot be used with ARN buckets");
    }
  } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
    endpointParams.ForcePathStyle = true;
  }
  if (endpointParams.DisableMultiRegionAccessPoints) {
    endpointParams.disableMultiRegionAccessPoints = true;
    endpointParams.DisableMRAP = true;
  }
  return endpointParams;
};
var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
var DOTS_PATTERN = /\.\./;
var isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
var isArnBucketName = (bucketName) => {
  const [arn, partition2, service, , , bucket] = bucketName.split(":");
  const isArn = arn === "arn" && bucketName.split(":").length >= 6;
  const isValidArn = Boolean(isArn && partition2 && service && bucket);
  if (isArn && !isValidArn) {
    throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
  }
  return isValidArn;
};

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/createConfigValueProvider.js
init_checked_fetch();
init_modules_watch_stub();
var createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
  const configProvider = async () => {
    const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
    if (typeof configValue === "function") {
      return configValue();
    }
    return configValue;
  };
  if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
    return async () => {
      const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
      const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
      return configValue;
    };
  }
  if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
    return async () => {
      const endpoint = await configProvider();
      if (endpoint && typeof endpoint === "object") {
        if ("url" in endpoint) {
          return endpoint.url.href;
        }
        if ("hostname" in endpoint) {
          const { protocol, hostname, port, path } = endpoint;
          return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
        }
      }
      return endpoint;
    };
  }
  return configProvider;
};

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromConfig.browser.js
init_checked_fetch();
init_modules_watch_stub();
var getEndpointFromConfig = async (serviceId) => void 0;

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/url-parser/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/querystring-parser/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();
function parseQueryString(querystring) {
  const query = {};
  querystring = querystring.replace(/^\?/, "");
  if (querystring) {
    for (const pair of querystring.split("&")) {
      let [key, value = null] = pair.split("=");
      key = decodeURIComponent(key);
      if (value) {
        value = decodeURIComponent(value);
      }
      if (!(key in query)) {
        query[key] = value;
      } else if (Array.isArray(query[key])) {
        query[key].push(value);
      } else {
        query[key] = [query[key], value];
      }
    }
  }
  return query;
}

// ../../node_modules/@smithy/url-parser/dist-es/index.js
var parseUrl = (url) => {
  if (typeof url === "string") {
    return parseUrl(new URL(url));
  }
  const { hostname, pathname, port, protocol, search } = url;
  let query;
  if (search) {
    query = parseQueryString(search);
  }
  return {
    hostname,
    port: port ? parseInt(port) : void 0,
    protocol,
    path: pathname,
    query
  };
};

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/toEndpointV1.js
var toEndpointV1 = (endpoint) => {
  if (typeof endpoint === "object") {
    if ("url" in endpoint) {
      return parseUrl(endpoint.url);
    }
    return endpoint;
  }
  return parseUrl(endpoint);
};

// ../../node_modules/@smithy/middleware-endpoint/dist-es/adaptors/getEndpointFromInstructions.js
var getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
  if (!clientConfig.endpoint) {
    const endpointFromConfig = await getEndpointFromConfig(clientConfig.serviceId || "");
    if (endpointFromConfig) {
      clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
    }
  }
  const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
  if (typeof clientConfig.endpointProvider !== "function") {
    throw new Error("config.endpointProvider is not set.");
  }
  const endpoint = clientConfig.endpointProvider(endpointParams, context);
  return endpoint;
};
var resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
  const endpointParams = {};
  const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
  for (const [name2, instruction] of Object.entries(instructions)) {
    switch (instruction.type) {
      case "staticContextParams":
        endpointParams[name2] = instruction.value;
        break;
      case "contextParams":
        endpointParams[name2] = commandInput[instruction.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        endpointParams[name2] = await createConfigValueProvider(instruction.name, name2, clientConfig)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
    }
  }
  if (Object.keys(instructions).length === 0) {
    Object.assign(endpointParams, clientConfig);
  }
  if (String(clientConfig.serviceId).toLowerCase() === "s3") {
    await resolveParamsForS3(endpointParams);
  }
  return endpointParams;
};

// ../../node_modules/@smithy/middleware-endpoint/dist-es/endpointMiddleware.js
init_checked_fetch();
init_modules_watch_stub();
var endpointMiddleware = ({ config, instructions }) => {
  return (next, context) => async (args) => {
    const endpoint = await getEndpointFromInstructions(args.input, {
      getEndpointParameterInstructions() {
        return instructions;
      }
    }, { ...config }, context);
    context.endpointV2 = endpoint;
    context.authSchemes = endpoint.properties?.authSchemes;
    const authScheme = context.authSchemes?.[0];
    if (authScheme) {
      context["signing_region"] = authScheme.signingRegion;
      context["signing_service"] = authScheme.signingName;
      const smithyContext = getSmithyContext(context);
      const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
      if (httpAuthOption) {
        httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
          signing_region: authScheme.signingRegion,
          signingRegion: authScheme.signingRegion,
          signing_service: authScheme.signingName,
          signingName: authScheme.signingName,
          signingRegionSet: authScheme.signingRegionSet
        }, authScheme.properties);
      }
    }
    return next({
      ...args
    });
  };
};

// ../../node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-serde/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-serde/dist-es/deserializerMiddleware.js
init_checked_fetch();
init_modules_watch_stub();
var deserializerMiddleware = (options, deserializer) => (next) => async (args) => {
  const { response } = await next(args);
  try {
    const parsed = await deserializer(response, options);
    return {
      response,
      output: parsed
    };
  } catch (error) {
    Object.defineProperty(error, "$response", {
      value: response
    });
    if (!("$metadata" in error)) {
      const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
      error.message += "\n  " + hint;
      if (typeof error.$responseBodyText !== "undefined") {
        if (error.$response) {
          error.$response.body = error.$responseBodyText;
        }
      }
    }
    throw error;
  }
};

// ../../node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-serde/dist-es/serializerMiddleware.js
init_checked_fetch();
init_modules_watch_stub();
var serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
  const endpoint = context.endpointV2?.url && options.urlParser ? async () => options.urlParser(context.endpointV2.url) : options.endpoint;
  if (!endpoint) {
    throw new Error("No valid endpoint provider available.");
  }
  const request = await serializer(args.input, { ...options, endpoint });
  return next({
    ...args,
    request
  });
};

// ../../node_modules/@smithy/middleware-serde/dist-es/serdePlugin.js
var deserializerMiddlewareOption = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: true
};
var serializerMiddlewareOption = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: true
};
function getSerdePlugin(config, serializer, deserializer) {
  return {
    applyToStack: (commandStack) => {
      commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
      commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
    }
  };
}

// ../../node_modules/@smithy/middleware-endpoint/dist-es/getEndpointPlugin.js
var endpointMiddlewareOptions = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: true,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
};
var getEndpointPlugin = (config, instructions) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(endpointMiddleware({
      config,
      instructions
    }), endpointMiddlewareOptions);
  }
});

// ../../node_modules/@smithy/middleware-endpoint/dist-es/resolveEndpointConfig.js
init_checked_fetch();
init_modules_watch_stub();
var resolveEndpointConfig = (input) => {
  const tls = input.tls ?? true;
  const { endpoint } = input;
  const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await normalizeProvider(endpoint)()) : void 0;
  const isCustomEndpoint = !!endpoint;
  return {
    ...input,
    endpoint: customEndpointProvider,
    tls,
    isCustomEndpoint,
    useDualstackEndpoint: normalizeProvider(input.useDualstackEndpoint ?? false),
    useFipsEndpoint: normalizeProvider(input.useFipsEndpoint ?? false)
  };
};

// ../../node_modules/@smithy/middleware-endpoint/dist-es/types.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-retry/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-retry/dist-es/AdaptiveRetryStrategy.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-retry/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-retry/dist-es/config.js
init_checked_fetch();
init_modules_watch_stub();
var RETRY_MODES;
(function(RETRY_MODES2) {
  RETRY_MODES2["STANDARD"] = "standard";
  RETRY_MODES2["ADAPTIVE"] = "adaptive";
})(RETRY_MODES || (RETRY_MODES = {}));
var DEFAULT_MAX_ATTEMPTS = 3;
var DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;

// ../../node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/service-error-classification/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/service-error-classification/dist-es/constants.js
init_checked_fetch();
init_modules_watch_stub();
var THROTTLING_ERROR_CODES = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
];
var TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
var TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];

// ../../node_modules/@smithy/service-error-classification/dist-es/index.js
var isClockSkewCorrectedError = (error) => error.$metadata?.clockSkewCorrected;
var isThrottlingError = (error) => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error.name) || error.$retryable?.throttling == true;
var isTransientError = (error) => isClockSkewCorrectedError(error) || TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0);
var isServerError = (error) => {
  if (error.$metadata?.httpStatusCode !== void 0) {
    const statusCode = error.$metadata.httpStatusCode;
    if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
      return true;
    }
    return false;
  }
  return false;
};

// ../../node_modules/@smithy/util-retry/dist-es/DefaultRateLimiter.js
var DefaultRateLimiter = class {
  constructor(options) {
    this.currentCapacity = 0;
    this.enabled = false;
    this.lastMaxRate = 0;
    this.measuredTxRate = 0;
    this.requestCount = 0;
    this.lastTimestamp = 0;
    this.timeWindow = 0;
    this.beta = options?.beta ?? 0.7;
    this.minCapacity = options?.minCapacity ?? 1;
    this.minFillRate = options?.minFillRate ?? 0.5;
    this.scaleConstant = options?.scaleConstant ?? 0.4;
    this.smooth = options?.smooth ?? 0.8;
    const currentTimeInSeconds = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = currentTimeInSeconds;
    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
    this.fillRate = this.minFillRate;
    this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(amount) {
    if (!this.enabled) {
      return;
    }
    this.refillTokenBucket();
    if (amount > this.currentCapacity) {
      const delay = (amount - this.currentCapacity) / this.fillRate * 1e3;
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
    this.currentCapacity = this.currentCapacity - amount;
  }
  refillTokenBucket() {
    const timestamp = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = timestamp;
      return;
    }
    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
    this.lastTimestamp = timestamp;
  }
  updateClientSendingRate(response) {
    let calculatedRate;
    this.updateMeasuredRate();
    if (isThrottlingError(response)) {
      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
      this.lastMaxRate = rateToUse;
      this.calculateTimeWindow();
      this.lastThrottleTime = this.getCurrentTimeInSeconds();
      calculatedRate = this.cubicThrottle(rateToUse);
      this.enableTokenBucket();
    } else {
      this.calculateTimeWindow();
      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
    }
    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(newRate);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(rateToUse) {
    return this.getPrecise(rateToUse * this.beta);
  }
  cubicSuccess(timestamp) {
    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = true;
  }
  updateTokenBucketRate(newRate) {
    this.refillTokenBucket();
    this.fillRate = Math.max(newRate, this.minFillRate);
    this.maxCapacity = Math.max(newRate, this.minCapacity);
    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const t2 = this.getCurrentTimeInSeconds();
    const timeBucket = Math.floor(t2 * 2) / 2;
    this.requestCount++;
    if (timeBucket > this.lastTxRateBucket) {
      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
      this.requestCount = 0;
      this.lastTxRateBucket = timeBucket;
    }
  }
  getPrecise(num) {
    return parseFloat(num.toFixed(8));
  }
};

// ../../node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-retry/dist-es/constants.js
init_checked_fetch();
init_modules_watch_stub();
var DEFAULT_RETRY_DELAY_BASE = 100;
var MAXIMUM_RETRY_DELAY = 20 * 1e3;
var THROTTLING_RETRY_DELAY_BASE = 500;
var INITIAL_RETRY_TOKENS = 500;
var RETRY_COST = 5;
var TIMEOUT_RETRY_COST = 10;
var NO_RETRY_INCREMENT = 1;
var INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
var REQUEST_HEADER = "amz-sdk-request";

// ../../node_modules/@smithy/util-retry/dist-es/defaultRetryBackoffStrategy.js
init_checked_fetch();
init_modules_watch_stub();
var getDefaultRetryBackoffStrategy = () => {
  let delayBase = DEFAULT_RETRY_DELAY_BASE;
  const computeNextBackoffDelay = (attempts) => {
    return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
  };
  const setDelayBase = (delay) => {
    delayBase = delay;
  };
  return {
    computeNextBackoffDelay,
    setDelayBase
  };
};

// ../../node_modules/@smithy/util-retry/dist-es/defaultRetryToken.js
init_checked_fetch();
init_modules_watch_stub();
var createDefaultRetryToken = ({ retryDelay, retryCount, retryCost }) => {
  const getRetryCount = () => retryCount;
  const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
  const getRetryCost = () => retryCost;
  return {
    getRetryCount,
    getRetryDelay,
    getRetryCost
  };
};

// ../../node_modules/@smithy/util-retry/dist-es/StandardRetryStrategy.js
var StandardRetryStrategy = class {
  constructor(maxAttempts) {
    this.maxAttempts = maxAttempts;
    this.mode = RETRY_MODES.STANDARD;
    this.capacity = INITIAL_RETRY_TOKENS;
    this.retryBackoffStrategy = getDefaultRetryBackoffStrategy();
    this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
  }
  async acquireInitialRetryToken(retryTokenScope) {
    return createDefaultRetryToken({
      retryDelay: DEFAULT_RETRY_DELAY_BASE,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(token, errorInfo) {
    const maxAttempts = await this.getMaxAttempts();
    if (this.shouldRetry(token, errorInfo, maxAttempts)) {
      const errorType = errorInfo.errorType;
      this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
      const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
      const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
      const capacityCost = this.getCapacityCost(errorType);
      this.capacity -= capacityCost;
      return createDefaultRetryToken({
        retryDelay,
        retryCount: token.getRetryCount() + 1,
        retryCost: capacityCost
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(token) {
    this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch (error) {
      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
      return DEFAULT_MAX_ATTEMPTS;
    }
  }
  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
    const attempts = tokenToRenew.getRetryCount() + 1;
    return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
  }
  getCapacityCost(errorType) {
    return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
  }
  isRetryableError(errorType) {
    return errorType === "THROTTLING" || errorType === "TRANSIENT";
  }
};

// ../../node_modules/@smithy/util-retry/dist-es/AdaptiveRetryStrategy.js
var AdaptiveRetryStrategy = class {
  constructor(maxAttemptsProvider, options) {
    this.maxAttemptsProvider = maxAttemptsProvider;
    this.mode = RETRY_MODES.ADAPTIVE;
    const { rateLimiter } = options ?? {};
    this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
    this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
  }
  async acquireInitialRetryToken(retryTokenScope) {
    await this.rateLimiter.getSendToken();
    return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
  }
  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
    this.rateLimiter.updateClientSendingRate(errorInfo);
    return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
  }
  recordSuccess(token) {
    this.rateLimiter.updateClientSendingRate({});
    this.standardRetryStrategy.recordSuccess(token);
  }
};

// ../../node_modules/@smithy/util-retry/dist-es/ConfiguredRetryStrategy.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-retry/dist-es/types.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-retry/dist-es/StandardRetryStrategy.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-browser/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-browser/rng.js
init_checked_fetch();
init_modules_watch_stub();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// ../../node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-browser/stringify.js
init_checked_fetch();
init_modules_watch_stub();
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// ../../node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-browser/v4.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-browser/native.js
init_checked_fetch();
init_modules_watch_stub();
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// ../../node_modules/@smithy/middleware-retry/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../../node_modules/@smithy/middleware-retry/dist-es/defaultRetryQuota.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-retry/dist-es/delayDecider.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-retry/dist-es/retryDecider.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-retry/dist-es/util.js
init_checked_fetch();
init_modules_watch_stub();
var asSdkError = (error) => {
  if (error instanceof Error)
    return error;
  if (error instanceof Object)
    return Object.assign(new Error(), error);
  if (typeof error === "string")
    return new Error(error);
  return new Error(`AWS SDK error wrapper for ${error}`);
};

// ../../node_modules/@smithy/middleware-retry/dist-es/configurations.js
init_checked_fetch();
init_modules_watch_stub();
var resolveRetryConfig = (input) => {
  const { retryStrategy } = input;
  const maxAttempts = normalizeProvider(input.maxAttempts ?? DEFAULT_MAX_ATTEMPTS);
  return {
    ...input,
    maxAttempts,
    retryStrategy: async () => {
      if (retryStrategy) {
        return retryStrategy;
      }
      const retryMode = await normalizeProvider(input.retryMode)();
      if (retryMode === RETRY_MODES.ADAPTIVE) {
        return new AdaptiveRetryStrategy(maxAttempts);
      }
      return new StandardRetryStrategy(maxAttempts);
    }
  };
};

// ../../node_modules/@smithy/middleware-retry/dist-es/omitRetryHeadersMiddleware.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/middleware-retry/dist-es/isStreamingPayload/isStreamingPayload.browser.js
init_checked_fetch();
init_modules_watch_stub();
var isStreamingPayload = (request) => request?.body instanceof ReadableStream;

// ../../node_modules/@smithy/middleware-retry/dist-es/retryMiddleware.js
var retryMiddleware = (options) => (next, context) => async (args) => {
  let retryStrategy = await options.retryStrategy();
  const maxAttempts = await options.maxAttempts();
  if (isRetryStrategyV2(retryStrategy)) {
    retryStrategy = retryStrategy;
    let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
    let lastError = new Error();
    let attempts = 0;
    let totalRetryDelay = 0;
    const { request } = args;
    const isRequest = HttpRequest.isInstance(request);
    if (isRequest) {
      request.headers[INVOCATION_ID_HEADER] = v4_default();
    }
    while (true) {
      try {
        if (isRequest) {
          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
        }
        const { response, output } = await next(args);
        retryStrategy.recordSuccess(retryToken);
        output.$metadata.attempts = attempts + 1;
        output.$metadata.totalRetryDelay = totalRetryDelay;
        return { response, output };
      } catch (e2) {
        const retryErrorInfo = getRetryErrorInfo(e2);
        lastError = asSdkError(e2);
        if (isRequest && isStreamingPayload(request)) {
          (context.logger instanceof NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
          throw lastError;
        }
        try {
          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
        } catch (refreshError) {
          if (!lastError.$metadata) {
            lastError.$metadata = {};
          }
          lastError.$metadata.attempts = attempts + 1;
          lastError.$metadata.totalRetryDelay = totalRetryDelay;
          throw lastError;
        }
        attempts = retryToken.getRetryCount();
        const delay = retryToken.getRetryDelay();
        totalRetryDelay += delay;
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  } else {
    retryStrategy = retryStrategy;
    if (retryStrategy?.mode)
      context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
    return retryStrategy.retry(next, args);
  }
};
var isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
var getRetryErrorInfo = (error) => {
  const errorInfo = {
    error,
    errorType: getRetryErrorType(error)
  };
  const retryAfterHint = getRetryAfterHint(error.$response);
  if (retryAfterHint) {
    errorInfo.retryAfterHint = retryAfterHint;
  }
  return errorInfo;
};
var getRetryErrorType = (error) => {
  if (isThrottlingError(error))
    return "THROTTLING";
  if (isTransientError(error))
    return "TRANSIENT";
  if (isServerError(error))
    return "SERVER_ERROR";
  return "CLIENT_ERROR";
};
var retryMiddlewareOptions = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: true
};
var getRetryPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
  }
});
var getRetryAfterHint = (response) => {
  if (!HttpResponse.isInstance(response))
    return;
  const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
  if (!retryAfterHeaderName)
    return;
  const retryAfter = response.headers[retryAfterHeaderName];
  const retryAfterSeconds = Number(retryAfter);
  if (!Number.isNaN(retryAfterSeconds))
    return new Date(retryAfterSeconds * 1e3);
  const retryAfterDate = new Date(retryAfter);
  return retryAfterDate;
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/commands/CreateSessionCommand.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/client-s3/dist-es/endpoint/EndpointParameters.js
init_checked_fetch();
init_modules_watch_stub();
var resolveClientEndpointParameters = (options) => {
  return {
    ...options,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    forcePathStyle: options.forcePathStyle ?? false,
    useAccelerateEndpoint: options.useAccelerateEndpoint ?? false,
    useGlobalEndpoint: options.useGlobalEndpoint ?? false,
    disableMultiregionAccessPoints: options.disableMultiregionAccessPoints ?? false,
    defaultSigningName: "s3"
  };
};
var commonParams = {
  ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
  UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
  DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
  Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
  DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
  UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/client-s3/dist-es/models/S3ServiceException.js
init_checked_fetch();
init_modules_watch_stub();
var S3ServiceException = class extends ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, S3ServiceException.prototype);
  }
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
var NoSuchUpload = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "NoSuchUpload",
      $fault: "client",
      ...opts
    });
    this.name = "NoSuchUpload";
    this.$fault = "client";
    Object.setPrototypeOf(this, NoSuchUpload.prototype);
  }
};
var ObjectNotInActiveTierError = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "ObjectNotInActiveTierError",
      $fault: "client",
      ...opts
    });
    this.name = "ObjectNotInActiveTierError";
    this.$fault = "client";
    Object.setPrototypeOf(this, ObjectNotInActiveTierError.prototype);
  }
};
var BucketAlreadyExists = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "BucketAlreadyExists",
      $fault: "client",
      ...opts
    });
    this.name = "BucketAlreadyExists";
    this.$fault = "client";
    Object.setPrototypeOf(this, BucketAlreadyExists.prototype);
  }
};
var BucketAlreadyOwnedByYou = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "BucketAlreadyOwnedByYou",
      $fault: "client",
      ...opts
    });
    this.name = "BucketAlreadyOwnedByYou";
    this.$fault = "client";
    Object.setPrototypeOf(this, BucketAlreadyOwnedByYou.prototype);
  }
};
var NoSuchBucket = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "NoSuchBucket",
      $fault: "client",
      ...opts
    });
    this.name = "NoSuchBucket";
    this.$fault = "client";
    Object.setPrototypeOf(this, NoSuchBucket.prototype);
  }
};
var AnalyticsFilter;
(function(AnalyticsFilter2) {
  AnalyticsFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(AnalyticsFilter || (AnalyticsFilter = {}));
var LifecycleRuleFilter;
(function(LifecycleRuleFilter2) {
  LifecycleRuleFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.ObjectSizeGreaterThan !== void 0)
      return visitor.ObjectSizeGreaterThan(value.ObjectSizeGreaterThan);
    if (value.ObjectSizeLessThan !== void 0)
      return visitor.ObjectSizeLessThan(value.ObjectSizeLessThan);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(LifecycleRuleFilter || (LifecycleRuleFilter = {}));
var MetricsFilter;
(function(MetricsFilter2) {
  MetricsFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.AccessPointArn !== void 0)
      return visitor.AccessPointArn(value.AccessPointArn);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(MetricsFilter || (MetricsFilter = {}));
var ReplicationRuleFilter;
(function(ReplicationRuleFilter2) {
  ReplicationRuleFilter2.visit = (value, visitor) => {
    if (value.Prefix !== void 0)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== void 0)
      return visitor.Tag(value.Tag);
    if (value.And !== void 0)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(ReplicationRuleFilter || (ReplicationRuleFilter = {}));
var InvalidObjectState = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "InvalidObjectState",
      $fault: "client",
      ...opts
    });
    this.name = "InvalidObjectState";
    this.$fault = "client";
    Object.setPrototypeOf(this, InvalidObjectState.prototype);
    this.StorageClass = opts.StorageClass;
    this.AccessTier = opts.AccessTier;
  }
};
var NoSuchKey = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "NoSuchKey",
      $fault: "client",
      ...opts
    });
    this.name = "NoSuchKey";
    this.$fault = "client";
    Object.setPrototypeOf(this, NoSuchKey.prototype);
  }
};
var NotFound = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "NotFound",
      $fault: "client",
      ...opts
    });
    this.name = "NotFound";
    this.$fault = "client";
    Object.setPrototypeOf(this, NotFound.prototype);
  }
};
var SessionCredentialsFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SecretAccessKey && { SecretAccessKey: SENSITIVE_STRING },
  ...obj.SessionToken && { SessionToken: SENSITIVE_STRING }
});
var CreateSessionOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Credentials && { Credentials: SessionCredentialsFilterSensitiveLog(obj.Credentials) }
});

// ../../node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js
init_checked_fetch();
init_modules_watch_stub();
var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
  step: "serialize",
  tags: ["HTTP_AUTH_SCHEME"],
  name: "httpAuthSchemeMiddleware",
  override: true,
  relation: "before",
  toMiddleware: endpointMiddlewareOptions.name
};

// ../../node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js
init_checked_fetch();
init_modules_watch_stub();
var httpAuthSchemeMiddlewareOptions = {
  step: "serialize",
  tags: ["HTTP_AUTH_SCHEME"],
  name: "httpAuthSchemeMiddleware",
  override: true,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
};

// ../../node_modules/@smithy/core/dist-es/middleware-http-signing/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js
init_checked_fetch();
init_modules_watch_stub();
var httpSigningMiddlewareOptions = {
  step: "finalizeRequest",
  tags: ["HTTP_SIGNING"],
  name: "httpSigningMiddleware",
  aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
  override: true,
  relation: "after",
  toMiddleware: retryMiddlewareOptions.name
};

// ../../node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js
init_checked_fetch();
init_modules_watch_stub();
var createIsIdentityExpiredFunction = (expirationMs) => (identity) => doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
var EXPIRATION_MS = 3e5;
var isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
var doesIdentityRequireRefresh = (identity) => identity.expiration !== void 0;

// ../../node_modules/@smithy/core/dist-es/getSmithyContext.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/normalizeProvider.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/core/dist-es/protocols/requestBuilder.js
init_checked_fetch();
init_modules_watch_stub();
function requestBuilder(input, context) {
  return new RequestBuilder(input, context);
}
var RequestBuilder = class {
  constructor(input, context) {
    this.input = input;
    this.context = context;
    this.query = {};
    this.method = "";
    this.headers = {};
    this.path = "";
    this.body = null;
    this.hostname = "";
    this.resolvePathStack = [];
  }
  async build() {
    const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
    this.path = basePath;
    for (const resolvePath of this.resolvePathStack) {
      resolvePath(this.path);
    }
    return new HttpRequest({
      protocol,
      hostname: this.hostname || hostname,
      port,
      method: this.method,
      path: this.path,
      query: this.query,
      body: this.body,
      headers: this.headers
    });
  }
  hn(hostname) {
    this.hostname = hostname;
    return this;
  }
  bp(uriLabel) {
    this.resolvePathStack.push((basePath) => {
      this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
    });
    return this;
  }
  p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
    this.resolvePathStack.push((path) => {
      this.path = resolvedPath(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
    });
    return this;
  }
  h(headers) {
    this.headers = headers;
    return this;
  }
  q(query) {
    this.query = query;
    return this;
  }
  b(body) {
    this.body = body;
    return this;
  }
  m(method) {
    this.method = method;
    return this;
  }
};

// ../../node_modules/@smithy/core/dist-es/pagination/createPaginator.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/core/dist-es/submodules/protocols/common.js
init_checked_fetch();
init_modules_watch_stub();
var collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));

// ../../node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js
init_checked_fetch();
init_modules_watch_stub();
var import_fast_xml_parser = __toESM(require_fxp());
var parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
  if (encoded.length) {
    const parser = new import_fast_xml_parser.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val2) => val2.trim() === "" && val2.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    let parsedObj;
    try {
      parsedObj = parser.parse(encoded, true);
    } catch (e2) {
      if (e2 && typeof e2 === "object") {
        Object.defineProperty(e2, "$responseBodyText", {
          value: encoded
        });
      }
      throw e2;
    }
    const textNodeName = "#text";
    const key = Object.keys(parsedObj)[0];
    const parsedObjToReturn = parsedObj[key];
    if (parsedObjToReturn[textNodeName]) {
      parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
      delete parsedObjToReturn[textNodeName];
    }
    return getValueFromTextNode(parsedObjToReturn);
  }
  return {};
});
var parseXmlErrorBody = async (errorBody, context) => {
  const value = await parseXmlBody(errorBody, context);
  if (value.Error) {
    value.Error.message = value.Error.message ?? value.Error.Message;
  }
  return value;
};
var loadRestXmlErrorCode = (output, data) => {
  if (data?.Error?.Code !== void 0) {
    return data.Error.Code;
  }
  if (data?.Code !== void 0) {
    return data.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
};

// ../../node_modules/@aws-sdk/xml-builder/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/xml-builder/dist-es/XmlNode.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/xml-builder/dist-es/escape-attribute.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/xml-builder/dist-es/XmlText.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/xml-builder/dist-es/escape-element.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/client-s3/dist-es/models/models_1.js
init_checked_fetch();
init_modules_watch_stub();
var ObjectAlreadyInActiveTierError = class extends S3ServiceException {
  constructor(opts) {
    super({
      name: "ObjectAlreadyInActiveTierError",
      $fault: "client",
      ...opts
    });
    this.name = "ObjectAlreadyInActiveTierError";
    this.$fault = "client";
    Object.setPrototypeOf(this, ObjectAlreadyInActiveTierError.prototype);
  }
};
var SelectObjectContentEventStream;
(function(SelectObjectContentEventStream2) {
  SelectObjectContentEventStream2.visit = (value, visitor) => {
    if (value.Records !== void 0)
      return visitor.Records(value.Records);
    if (value.Stats !== void 0)
      return visitor.Stats(value.Stats);
    if (value.Progress !== void 0)
      return visitor.Progress(value.Progress);
    if (value.Cont !== void 0)
      return visitor.Cont(value.Cont);
    if (value.End !== void 0)
      return visitor.End(value.End);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(SelectObjectContentEventStream || (SelectObjectContentEventStream = {}));

// ../../node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
var se_CreateSessionCommand = async (input, context) => {
  const b2 = requestBuilder(input, context);
  const headers = map({}, isSerializableHeaderValue, {
    [_xacsm]: input[_SM]
  });
  b2.bp("/");
  b2.p("Bucket", () => input.Bucket, "{Bucket}", false);
  const query = map({
    [_s]: [, ""]
  });
  let body;
  b2.m("GET").h(headers).q(query).b(body);
  return b2.build();
};
var de_CreateSessionCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const contents = map({
    $metadata: deserializeMetadata2(output)
  });
  const data = expectNonNull(expectObject(await parseXmlBody(output.body, context)), "body");
  if (data[_C] != null) {
    contents[_C] = de_SessionCredentials(data[_C], context);
  }
  return contents;
};
var de_CommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseXmlErrorBody(output.body, context)
  };
  const errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NoSuchUpload":
    case "com.amazonaws.s3#NoSuchUpload":
      throw await de_NoSuchUploadRes(parsedOutput, context);
    case "ObjectNotInActiveTierError":
    case "com.amazonaws.s3#ObjectNotInActiveTierError":
      throw await de_ObjectNotInActiveTierErrorRes(parsedOutput, context);
    case "BucketAlreadyExists":
    case "com.amazonaws.s3#BucketAlreadyExists":
      throw await de_BucketAlreadyExistsRes(parsedOutput, context);
    case "BucketAlreadyOwnedByYou":
    case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
      throw await de_BucketAlreadyOwnedByYouRes(parsedOutput, context);
    case "NoSuchBucket":
    case "com.amazonaws.s3#NoSuchBucket":
      throw await de_NoSuchBucketRes(parsedOutput, context);
    case "InvalidObjectState":
    case "com.amazonaws.s3#InvalidObjectState":
      throw await de_InvalidObjectStateRes(parsedOutput, context);
    case "NoSuchKey":
    case "com.amazonaws.s3#NoSuchKey":
      throw await de_NoSuchKeyRes(parsedOutput, context);
    case "NotFound":
    case "com.amazonaws.s3#NotFound":
      throw await de_NotFoundRes(parsedOutput, context);
    case "ObjectAlreadyInActiveTierError":
    case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
      throw await de_ObjectAlreadyInActiveTierErrorRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError2({
        output,
        parsedBody,
        errorCode
      });
  }
};
var throwDefaultError2 = withBaseException(S3ServiceException);
var de_BucketAlreadyExistsRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new BucketAlreadyExists({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_BucketAlreadyOwnedByYouRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new BucketAlreadyOwnedByYou({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_InvalidObjectStateRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  if (data[_AT] != null) {
    contents[_AT] = expectString(data[_AT]);
  }
  if (data[_SC] != null) {
    contents[_SC] = expectString(data[_SC]);
  }
  const exception = new InvalidObjectState({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_NoSuchBucketRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new NoSuchBucket({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_NoSuchKeyRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new NoSuchKey({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_NoSuchUploadRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new NoSuchUpload({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_NotFoundRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new NotFound({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_ObjectAlreadyInActiveTierErrorRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new ObjectAlreadyInActiveTierError({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_ObjectNotInActiveTierErrorRes = async (parsedOutput, context) => {
  const contents = map({});
  const data = parsedOutput.body;
  const exception = new ObjectNotInActiveTierError({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return decorateServiceException(exception, parsedOutput.body);
};
var de_SessionCredentials = (output, context) => {
  const contents = {};
  if (output[_AKI] != null) {
    contents[_AKI] = expectString(output[_AKI]);
  }
  if (output[_SAK] != null) {
    contents[_SAK] = expectString(output[_SAK]);
  }
  if (output[_ST] != null) {
    contents[_ST] = expectString(output[_ST]);
  }
  if (output[_Exp] != null) {
    contents[_Exp] = expectNonNull(parseRfc3339DateTimeWithOffset(output[_Exp]));
  }
  return contents;
};
var deserializeMetadata2 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var isSerializableHeaderValue = (value) => value !== void 0 && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
var _AKI = "AccessKeyId";
var _AT = "AccessTier";
var _C = "Credentials";
var _Exp = "Expiration";
var _SAK = "SecretAccessKey";
var _SC = "StorageClass";
var _SM = "SessionMode";
var _ST = "SessionToken";
var _s = "session";
var _xacsm = "x-amz-create-session-mode";

// ../../node_modules/@aws-sdk/client-s3/dist-es/commands/CreateSessionCommand.js
var CreateSessionCommand = class extends Command.classBuilder().ep({
  ...commonParams,
  DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
  Bucket: { type: "contextParams", name: "Bucket" }
}).m(function(Command2, cs2, config, o2) {
  return [
    getSerdePlugin(config, this.serialize, this.deserialize),
    getEndpointPlugin(config, Command2.getEndpointParameterInstructions())
  ];
}).s("AmazonS3", "CreateSession", {}).n("S3Client", "CreateSessionCommand").f(void 0, CreateSessionOutputFilterSensitiveLog).ser(se_CreateSessionCommand).de(de_CreateSessionCommand).build() {
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.browser.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/client-s3/package.json
var package_default = {
  name: "@aws-sdk/client-s3",
  description: "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
  version: "3.577.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline client-s3",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
    test: "yarn test:unit",
    "test:e2e": "yarn test:e2e:node && yarn test:e2e:browser",
    "test:e2e:browser": "ts-mocha test/**/*.browser.ispec.ts && karma start karma.conf.js",
    "test:e2e:node": "jest --c jest.config.e2e.js",
    "test:unit": "ts-mocha test/unit/**/*.spec.ts"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha1-browser": "3.0.0",
    "@aws-crypto/sha256-browser": "3.0.0",
    "@aws-crypto/sha256-js": "3.0.0",
    "@aws-sdk/client-sso-oidc": "3.577.0",
    "@aws-sdk/client-sts": "3.577.0",
    "@aws-sdk/core": "3.576.0",
    "@aws-sdk/credential-provider-node": "3.577.0",
    "@aws-sdk/middleware-bucket-endpoint": "3.577.0",
    "@aws-sdk/middleware-expect-continue": "3.577.0",
    "@aws-sdk/middleware-flexible-checksums": "3.577.0",
    "@aws-sdk/middleware-host-header": "3.577.0",
    "@aws-sdk/middleware-location-constraint": "3.577.0",
    "@aws-sdk/middleware-logger": "3.577.0",
    "@aws-sdk/middleware-recursion-detection": "3.577.0",
    "@aws-sdk/middleware-sdk-s3": "3.577.0",
    "@aws-sdk/middleware-signing": "3.577.0",
    "@aws-sdk/middleware-ssec": "3.577.0",
    "@aws-sdk/middleware-user-agent": "3.577.0",
    "@aws-sdk/region-config-resolver": "3.577.0",
    "@aws-sdk/signature-v4-multi-region": "3.577.0",
    "@aws-sdk/types": "3.577.0",
    "@aws-sdk/util-endpoints": "3.577.0",
    "@aws-sdk/util-user-agent-browser": "3.577.0",
    "@aws-sdk/util-user-agent-node": "3.577.0",
    "@aws-sdk/xml-builder": "3.575.0",
    "@smithy/config-resolver": "^3.0.0",
    "@smithy/core": "^2.0.0",
    "@smithy/eventstream-serde-browser": "^3.0.0",
    "@smithy/eventstream-serde-config-resolver": "^3.0.0",
    "@smithy/eventstream-serde-node": "^3.0.0",
    "@smithy/fetch-http-handler": "^3.0.0",
    "@smithy/hash-blob-browser": "^3.0.0",
    "@smithy/hash-node": "^3.0.0",
    "@smithy/hash-stream-node": "^3.0.0",
    "@smithy/invalid-dependency": "^3.0.0",
    "@smithy/md5-js": "^3.0.0",
    "@smithy/middleware-content-length": "^3.0.0",
    "@smithy/middleware-endpoint": "^3.0.0",
    "@smithy/middleware-retry": "^3.0.0",
    "@smithy/middleware-serde": "^3.0.0",
    "@smithy/middleware-stack": "^3.0.0",
    "@smithy/node-config-provider": "^3.0.0",
    "@smithy/node-http-handler": "^3.0.0",
    "@smithy/protocol-http": "^4.0.0",
    "@smithy/smithy-client": "^3.0.0",
    "@smithy/types": "^3.0.0",
    "@smithy/url-parser": "^3.0.0",
    "@smithy/util-base64": "^3.0.0",
    "@smithy/util-body-length-browser": "^3.0.0",
    "@smithy/util-body-length-node": "^3.0.0",
    "@smithy/util-defaults-mode-browser": "^3.0.0",
    "@smithy/util-defaults-mode-node": "^3.0.0",
    "@smithy/util-endpoints": "^2.0.0",
    "@smithy/util-retry": "^3.0.0",
    "@smithy/util-stream": "^3.0.0",
    "@smithy/util-utf8": "^3.0.0",
    "@smithy/util-waiter": "^3.0.0",
    tslib: "^2.6.2"
  },
  devDependencies: {
    "@aws-sdk/signature-v4-crt": "3.577.0",
    "@tsconfig/node16": "16.1.3",
    "@types/chai": "^4.2.11",
    "@types/mocha": "^8.0.4",
    "@types/node": "^16.18.96",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typescript: "~4.9.5"
  },
  engines: {
    node: ">=16.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-s3"
  }
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.browser.js
var import_sha1_browser = __toESM(require_build4());
var import_sha256_browser = __toESM(require_build6());

// ../../node_modules/@aws-sdk/util-user-agent-browser/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();
var import_bowser = __toESM(require_es5());
var defaultUserAgent = ({ serviceId, clientVersion }) => async () => {
  const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent ? import_bowser.default.parse(window.navigator.userAgent) : void 0;
  const sections = [
    ["aws-sdk-js", clientVersion],
    ["ua", "2.0"],
    [`os/${parsedUA?.os?.name || "other"}`, parsedUA?.os?.version],
    ["lang/js"],
    ["md/browser", `${parsedUA?.browser?.name ?? "unknown"}_${parsedUA?.browser?.version ?? "unknown"}`]
  ];
  if (serviceId) {
    sections.push([`api/${serviceId}`, clientVersion]);
  }
  return sections;
};

// ../../node_modules/@smithy/eventstream-serde-browser/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-serde-browser/dist-es/EventStreamMarshaller.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-serde-universal/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-serde-universal/dist-es/EventStreamMarshaller.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-codec/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-codec/node_modules/@aws-crypto/crc32/build/module/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/tslib/tslib.es6.mjs
init_checked_fetch();
init_modules_watch_stub();
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_ = 0)), _)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

// ../../node_modules/@smithy/eventstream-codec/node_modules/@aws-crypto/util/build/module/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-codec/node_modules/@aws-crypto/util/build/module/convertToBuffer.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-codec/node_modules/@smithy/util-utf8/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-codec/node_modules/@smithy/util-utf8/dist-es/fromUtf8.browser.js
init_checked_fetch();
init_modules_watch_stub();
var fromUtf82 = (input) => new TextEncoder().encode(input);

// ../../node_modules/@smithy/eventstream-codec/node_modules/@smithy/util-utf8/dist-es/toUint8Array.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-codec/node_modules/@smithy/util-utf8/dist-es/toUtf8.browser.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-codec/node_modules/@aws-crypto/util/build/module/convertToBuffer.js
var fromUtf83 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
  return Buffer.from(input, "utf8");
} : fromUtf82;
function convertToBuffer(data) {
  if (data instanceof Uint8Array)
    return data;
  if (typeof data === "string") {
    return fromUtf83(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}

// ../../node_modules/@smithy/eventstream-codec/node_modules/@aws-crypto/util/build/module/isEmptyData.js
init_checked_fetch();
init_modules_watch_stub();
function isEmptyData(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}

// ../../node_modules/@smithy/eventstream-codec/node_modules/@aws-crypto/util/build/module/numToUint8.js
init_checked_fetch();
init_modules_watch_stub();
function numToUint8(num) {
  return new Uint8Array([
    (num & 4278190080) >> 24,
    (num & 16711680) >> 16,
    (num & 65280) >> 8,
    num & 255
  ]);
}

// ../../node_modules/@smithy/eventstream-codec/node_modules/@aws-crypto/util/build/module/uint32ArrayFrom.js
init_checked_fetch();
init_modules_watch_stub();
function uint32ArrayFrom(a_lookUpTable2) {
  if (!Uint32Array.from) {
    var return_array = new Uint32Array(a_lookUpTable2.length);
    var a_index = 0;
    while (a_index < a_lookUpTable2.length) {
      return_array[a_index] = a_lookUpTable2[a_index];
      a_index += 1;
    }
    return return_array;
  }
  return Uint32Array.from(a_lookUpTable2);
}

// ../../node_modules/@smithy/eventstream-codec/node_modules/@aws-crypto/crc32/build/module/aws_crc32.js
init_checked_fetch();
init_modules_watch_stub();
var AwsCrc32 = (
  /** @class */
  function() {
    function AwsCrc322() {
      this.crc32 = new Crc32();
    }
    AwsCrc322.prototype.update = function(toHash) {
      if (isEmptyData(toHash))
        return;
      this.crc32.update(convertToBuffer(toHash));
    };
    AwsCrc322.prototype.digest = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          return [2, numToUint8(this.crc32.digest())];
        });
      });
    };
    AwsCrc322.prototype.reset = function() {
      this.crc32 = new Crc32();
    };
    return AwsCrc322;
  }()
);

// ../../node_modules/@smithy/eventstream-codec/node_modules/@aws-crypto/crc32/build/module/index.js
var Crc32 = (
  /** @class */
  function() {
    function Crc322() {
      this.checksum = 4294967295;
    }
    Crc322.prototype.update = function(data) {
      var e_1, _a2;
      try {
        for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
          var byte = data_1_1.value;
          this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
            _a2.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return this;
    };
    Crc322.prototype.digest = function() {
      return (this.checksum ^ 4294967295) >>> 0;
    };
    return Crc322;
  }()
);
var a_lookUpTable = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
var lookupTable = uint32ArrayFrom(a_lookUpTable);

// ../../node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-codec/dist-es/Int64.js
init_checked_fetch();
init_modules_watch_stub();
var Int642 = class {
  constructor(bytes) {
    this.bytes = bytes;
    if (bytes.byteLength !== 8) {
      throw new Error("Int64 buffers must be exactly 8 bytes");
    }
  }
  static fromNumber(number) {
    if (number > 9223372036854776e3 || number < -9223372036854776e3) {
      throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
    }
    const bytes = new Uint8Array(8);
    for (let i2 = 7, remaining = Math.abs(Math.round(number)); i2 > -1 && remaining > 0; i2--, remaining /= 256) {
      bytes[i2] = remaining;
    }
    if (number < 0) {
      negate2(bytes);
    }
    return new Int642(bytes);
  }
  valueOf() {
    const bytes = this.bytes.slice(0);
    const negative = bytes[0] & 128;
    if (negative) {
      negate2(bytes);
    }
    return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
};
function negate2(bytes) {
  for (let i2 = 0; i2 < 8; i2++) {
    bytes[i2] ^= 255;
  }
  for (let i2 = 7; i2 > -1; i2--) {
    bytes[i2]++;
    if (bytes[i2] !== 0)
      break;
  }
}

// ../../node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
var HeaderMarshaller = class {
  constructor(toUtf82, fromUtf84) {
    this.toUtf8 = toUtf82;
    this.fromUtf8 = fromUtf84;
  }
  format(headers) {
    const chunks = [];
    for (const headerName of Object.keys(headers)) {
      const bytes = this.fromUtf8(headerName);
      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
    }
    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
    let position = 0;
    for (const chunk of chunks) {
      out.set(chunk, position);
      position += chunk.byteLength;
    }
    return out;
  }
  formatHeaderValue(header) {
    switch (header.type) {
      case "boolean":
        return Uint8Array.from([header.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, header.value]);
      case "short":
        const shortView = new DataView(new ArrayBuffer(3));
        shortView.setUint8(0, 3);
        shortView.setInt16(1, header.value, false);
        return new Uint8Array(shortView.buffer);
      case "integer":
        const intView = new DataView(new ArrayBuffer(5));
        intView.setUint8(0, 4);
        intView.setInt32(1, header.value, false);
        return new Uint8Array(intView.buffer);
      case "long":
        const longBytes = new Uint8Array(9);
        longBytes[0] = 5;
        longBytes.set(header.value.bytes, 1);
        return longBytes;
      case "binary":
        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
        binView.setUint8(0, 6);
        binView.setUint16(1, header.value.byteLength, false);
        const binBytes = new Uint8Array(binView.buffer);
        binBytes.set(header.value, 3);
        return binBytes;
      case "string":
        const utf8Bytes = this.fromUtf8(header.value);
        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
        strView.setUint8(0, 7);
        strView.setUint16(1, utf8Bytes.byteLength, false);
        const strBytes = new Uint8Array(strView.buffer);
        strBytes.set(utf8Bytes, 3);
        return strBytes;
      case "timestamp":
        const tsBytes = new Uint8Array(9);
        tsBytes[0] = 8;
        tsBytes.set(Int642.fromNumber(header.value.valueOf()).bytes, 1);
        return tsBytes;
      case "uuid":
        if (!UUID_PATTERN2.test(header.value)) {
          throw new Error(`Invalid UUID received: ${header.value}`);
        }
        const uuidBytes = new Uint8Array(17);
        uuidBytes[0] = 9;
        uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
        return uuidBytes;
    }
  }
  parse(headers) {
    const out = {};
    let position = 0;
    while (position < headers.byteLength) {
      const nameLength = headers.getUint8(position++);
      const name2 = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
      position += nameLength;
      switch (headers.getUint8(position++)) {
        case 0:
          out[name2] = {
            type: BOOLEAN_TAG,
            value: true
          };
          break;
        case 1:
          out[name2] = {
            type: BOOLEAN_TAG,
            value: false
          };
          break;
        case 2:
          out[name2] = {
            type: BYTE_TAG,
            value: headers.getInt8(position++)
          };
          break;
        case 3:
          out[name2] = {
            type: SHORT_TAG,
            value: headers.getInt16(position, false)
          };
          position += 2;
          break;
        case 4:
          out[name2] = {
            type: INT_TAG,
            value: headers.getInt32(position, false)
          };
          position += 4;
          break;
        case 5:
          out[name2] = {
            type: LONG_TAG,
            value: new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
          };
          position += 8;
          break;
        case 6:
          const binaryLength = headers.getUint16(position, false);
          position += 2;
          out[name2] = {
            type: BINARY_TAG,
            value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
          };
          position += binaryLength;
          break;
        case 7:
          const stringLength = headers.getUint16(position, false);
          position += 2;
          out[name2] = {
            type: STRING_TAG,
            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
          };
          position += stringLength;
          break;
        case 8:
          out[name2] = {
            type: TIMESTAMP_TAG,
            value: new Date(new Int642(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
          };
          position += 8;
          break;
        case 9:
          const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
          position += 16;
          out[name2] = {
            type: UUID_TAG,
            value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`
          };
          break;
        default:
          throw new Error(`Unrecognized header type tag`);
      }
    }
    return out;
  }
};
var HEADER_VALUE_TYPE2;
(function(HEADER_VALUE_TYPE3) {
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolTrue"] = 0] = "boolTrue";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["boolFalse"] = 1] = "boolFalse";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byte"] = 2] = "byte";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["short"] = 3] = "short";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["integer"] = 4] = "integer";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["long"] = 5] = "long";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["byteArray"] = 6] = "byteArray";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["string"] = 7] = "string";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["timestamp"] = 8] = "timestamp";
  HEADER_VALUE_TYPE3[HEADER_VALUE_TYPE3["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE2 || (HEADER_VALUE_TYPE2 = {}));
var BOOLEAN_TAG = "boolean";
var BYTE_TAG = "byte";
var SHORT_TAG = "short";
var INT_TAG = "integer";
var LONG_TAG = "long";
var BINARY_TAG = "binary";
var STRING_TAG = "string";
var TIMESTAMP_TAG = "timestamp";
var UUID_TAG = "uuid";
var UUID_PATTERN2 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

// ../../node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js
init_checked_fetch();
init_modules_watch_stub();
var PRELUDE_MEMBER_LENGTH = 4;
var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
var CHECKSUM_LENGTH = 4;
var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
function splitMessage({ byteLength, byteOffset, buffer }) {
  if (byteLength < MINIMUM_MESSAGE_LENGTH) {
    throw new Error("Provided message too short to accommodate event stream message overhead");
  }
  const view = new DataView(buffer, byteOffset, byteLength);
  const messageLength = view.getUint32(0, false);
  if (byteLength !== messageLength) {
    throw new Error("Reported message length does not match received message length");
  }
  const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
  const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
  const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
  const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
  if (expectedPreludeChecksum !== checksummer.digest()) {
    throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
  }
  checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
  if (expectedMessageChecksum !== checksummer.digest()) {
    throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
  }
  return {
    headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
    body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
  };
}

// ../../node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js
var EventStreamCodec = class {
  constructor(toUtf82, fromUtf84) {
    this.headerMarshaller = new HeaderMarshaller(toUtf82, fromUtf84);
    this.messageBuffer = [];
    this.isEndOfStream = false;
  }
  feed(message) {
    this.messageBuffer.push(this.decode(message));
  }
  endOfStream() {
    this.isEndOfStream = true;
  }
  getMessage() {
    const message = this.messageBuffer.pop();
    const isEndOfStream = this.isEndOfStream;
    return {
      getMessage() {
        return message;
      },
      isEndOfStream() {
        return isEndOfStream;
      }
    };
  }
  getAvailableMessages() {
    const messages = this.messageBuffer;
    this.messageBuffer = [];
    const isEndOfStream = this.isEndOfStream;
    return {
      getMessages() {
        return messages;
      },
      isEndOfStream() {
        return isEndOfStream;
      }
    };
  }
  encode({ headers: rawHeaders, body }) {
    const headers = this.headerMarshaller.format(rawHeaders);
    const length = headers.byteLength + body.byteLength + 16;
    const out = new Uint8Array(length);
    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    const checksum = new Crc32();
    view.setUint32(0, length, false);
    view.setUint32(4, headers.byteLength, false);
    view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
    out.set(headers, 12);
    out.set(body, headers.byteLength + 12);
    view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
    return out;
  }
  decode(message) {
    const { headers, body } = splitMessage(message);
    return { headers: this.headerMarshaller.parse(headers), body };
  }
  formatHeaders(rawHeaders) {
    return this.headerMarshaller.format(rawHeaders);
  }
};

// ../../node_modules/@smithy/eventstream-codec/dist-es/Message.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js
init_checked_fetch();
init_modules_watch_stub();
var MessageDecoderStream = class {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const bytes of this.options.inputStream) {
      const decoded = this.options.decoder.decode(bytes);
      yield decoded;
    }
  }
};

// ../../node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js
init_checked_fetch();
init_modules_watch_stub();
var MessageEncoderStream = class {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const msg of this.options.messageStream) {
      const encoded = this.options.encoder.encode(msg);
      yield encoded;
    }
    if (this.options.includeEndFrame) {
      yield new Uint8Array(0);
    }
  }
};

// ../../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js
init_checked_fetch();
init_modules_watch_stub();
var SmithyMessageDecoderStream = class {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const message of this.options.messageStream) {
      const deserialized = await this.options.deserializer(message);
      if (deserialized === void 0)
        continue;
      yield deserialized;
    }
  }
};

// ../../node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js
init_checked_fetch();
init_modules_watch_stub();
var SmithyMessageEncoderStream = class {
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const chunk of this.options.inputStream) {
      const payloadBuf = this.options.serializer(chunk);
      yield payloadBuf;
    }
  }
};

// ../../node_modules/@smithy/eventstream-serde-universal/dist-es/getChunkedStream.js
init_checked_fetch();
init_modules_watch_stub();
function getChunkedStream(source) {
  let currentMessageTotalLength = 0;
  let currentMessagePendingLength = 0;
  let currentMessage = null;
  let messageLengthBuffer = null;
  const allocateMessage = (size) => {
    if (typeof size !== "number") {
      throw new Error("Attempted to allocate an event message where size was not a number: " + size);
    }
    currentMessageTotalLength = size;
    currentMessagePendingLength = 4;
    currentMessage = new Uint8Array(size);
    const currentMessageView = new DataView(currentMessage.buffer);
    currentMessageView.setUint32(0, size, false);
  };
  const iterator = async function* () {
    const sourceIterator = source[Symbol.asyncIterator]();
    while (true) {
      const { value, done } = await sourceIterator.next();
      if (done) {
        if (!currentMessageTotalLength) {
          return;
        } else if (currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
        } else {
          throw new Error("Truncated event message received.");
        }
        return;
      }
      const chunkLength = value.length;
      let currentOffset = 0;
      while (currentOffset < chunkLength) {
        if (!currentMessage) {
          const bytesRemaining = chunkLength - currentOffset;
          if (!messageLengthBuffer) {
            messageLengthBuffer = new Uint8Array(4);
          }
          const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
          messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
          currentMessagePendingLength += numBytesForTotal;
          currentOffset += numBytesForTotal;
          if (currentMessagePendingLength < 4) {
            break;
          }
          allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
          messageLengthBuffer = null;
        }
        const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
        currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
        currentMessagePendingLength += numBytesToWrite;
        currentOffset += numBytesToWrite;
        if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
          currentMessage = null;
          currentMessageTotalLength = 0;
          currentMessagePendingLength = 0;
        }
      }
    }
  };
  return {
    [Symbol.asyncIterator]: iterator
  };
}

// ../../node_modules/@smithy/eventstream-serde-universal/dist-es/getUnmarshalledStream.js
init_checked_fetch();
init_modules_watch_stub();
function getMessageUnmarshaller(deserializer, toUtf82) {
  return async function(message) {
    const { value: messageType } = message.headers[":message-type"];
    if (messageType === "error") {
      const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
      unmodeledError.name = message.headers[":error-code"].value;
      throw unmodeledError;
    } else if (messageType === "exception") {
      const code = message.headers[":exception-type"].value;
      const exception = { [code]: message };
      const deserializedException = await deserializer(exception);
      if (deserializedException.$unknown) {
        const error = new Error(toUtf82(message.body));
        error.name = code;
        throw error;
      }
      throw deserializedException[code];
    } else if (messageType === "event") {
      const event = {
        [message.headers[":event-type"].value]: message
      };
      const deserialized = await deserializer(event);
      if (deserialized.$unknown)
        return;
      return deserialized;
    } else {
      throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
    }
  };
}

// ../../node_modules/@smithy/eventstream-serde-universal/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller = class {
  constructor({ utf8Encoder, utf8Decoder }) {
    this.eventStreamCodec = new EventStreamCodec(utf8Encoder, utf8Decoder);
    this.utfEncoder = utf8Encoder;
  }
  deserialize(body, deserializer) {
    const inputStream = getChunkedStream(body);
    return new SmithyMessageDecoderStream({
      messageStream: new MessageDecoderStream({ inputStream, decoder: this.eventStreamCodec }),
      deserializer: getMessageUnmarshaller(deserializer, this.utfEncoder)
    });
  }
  serialize(inputStream, serializer) {
    return new MessageEncoderStream({
      messageStream: new SmithyMessageEncoderStream({ inputStream, serializer }),
      encoder: this.eventStreamCodec,
      includeEndFrame: true
    });
  }
};

// ../../node_modules/@smithy/eventstream-serde-universal/dist-es/provider.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/eventstream-serde-browser/dist-es/utils.js
init_checked_fetch();
init_modules_watch_stub();
var readableStreamtoIterable = (readableStream) => ({
  [Symbol.asyncIterator]: async function* () {
    const reader = readableStream.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          return;
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  }
});
var iterableToReadableStream = (asyncIterable) => {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  return new ReadableStream({
    async pull(controller) {
      const { done, value } = await iterator.next();
      if (done) {
        return controller.close();
      }
      controller.enqueue(value);
    }
  });
};

// ../../node_modules/@smithy/eventstream-serde-browser/dist-es/EventStreamMarshaller.js
var EventStreamMarshaller2 = class {
  constructor({ utf8Encoder, utf8Decoder }) {
    this.universalMarshaller = new EventStreamMarshaller({
      utf8Decoder,
      utf8Encoder
    });
  }
  deserialize(body, deserializer) {
    const bodyIterable = isReadableStream(body) ? readableStreamtoIterable(body) : body;
    return this.universalMarshaller.deserialize(bodyIterable, deserializer);
  }
  serialize(input, serializer) {
    const serialziedIterable = this.universalMarshaller.serialize(input, serializer);
    return typeof ReadableStream === "function" ? iterableToReadableStream(serialziedIterable) : serialziedIterable;
  }
};
var isReadableStream = (body) => typeof ReadableStream === "function" && body instanceof ReadableStream;

// ../../node_modules/@smithy/eventstream-serde-browser/dist-es/provider.js
init_checked_fetch();
init_modules_watch_stub();
var eventStreamSerdeProvider = (options) => new EventStreamMarshaller2(options);

// ../../node_modules/@smithy/hash-blob-browser/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/chunked-blob-reader/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();
function blobReader(blob, onChunk, chunkSize = 1024 * 1024) {
  return new Promise((resolve, reject) => {
    const fileReader = new FileReader();
    fileReader.addEventListener("error", reject);
    fileReader.addEventListener("abort", reject);
    const size = blob.size;
    let totalBytesRead = 0;
    function read() {
      if (totalBytesRead >= size) {
        resolve();
        return;
      }
      fileReader.readAsArrayBuffer(blob.slice(totalBytesRead, Math.min(size, totalBytesRead + chunkSize)));
    }
    fileReader.addEventListener("load", (event) => {
      const result = event.target.result;
      onChunk(new Uint8Array(result));
      totalBytesRead += result.byteLength;
      read();
    });
    read();
  });
}

// ../../node_modules/@smithy/hash-blob-browser/dist-es/index.js
var blobHasher = async function blobHasher2(hashCtor, blob) {
  const hash = new hashCtor();
  await blobReader(blob, (chunk) => {
    hash.update(chunk);
  });
  return hash.digest();
};

// ../../node_modules/@smithy/invalid-dependency/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/invalid-dependency/dist-es/invalidFunction.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/invalid-dependency/dist-es/invalidProvider.js
init_checked_fetch();
init_modules_watch_stub();
var invalidProvider = (message) => () => Promise.reject(message);

// ../../node_modules/@smithy/md5-js/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/md5-js/dist-es/constants.js
init_checked_fetch();
init_modules_watch_stub();
var BLOCK_SIZE = 64;
var DIGEST_LENGTH = 16;
var INIT = [1732584193, 4023233417, 2562383102, 271733878];

// ../../node_modules/@smithy/md5-js/dist-es/index.js
var Md5 = class {
  constructor() {
    this.reset();
  }
  update(sourceData) {
    if (isEmptyData2(sourceData)) {
      return;
    } else if (this.finished) {
      throw new Error("Attempted to update an already finished hash.");
    }
    const data = convertToBuffer2(sourceData);
    let position = 0;
    let { byteLength } = data;
    this.bytesHashed += byteLength;
    while (byteLength > 0) {
      this.buffer.setUint8(this.bufferLength++, data[position++]);
      byteLength--;
      if (this.bufferLength === BLOCK_SIZE) {
        this.hashBuffer();
        this.bufferLength = 0;
      }
    }
  }
  async digest() {
    if (!this.finished) {
      const { buffer, bufferLength: undecoratedLength, bytesHashed } = this;
      const bitsHashed = bytesHashed * 8;
      buffer.setUint8(this.bufferLength++, 128);
      if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
        for (let i2 = this.bufferLength; i2 < BLOCK_SIZE; i2++) {
          buffer.setUint8(i2, 0);
        }
        this.hashBuffer();
        this.bufferLength = 0;
      }
      for (let i2 = this.bufferLength; i2 < BLOCK_SIZE - 8; i2++) {
        buffer.setUint8(i2, 0);
      }
      buffer.setUint32(BLOCK_SIZE - 8, bitsHashed >>> 0, true);
      buffer.setUint32(BLOCK_SIZE - 4, Math.floor(bitsHashed / 4294967296), true);
      this.hashBuffer();
      this.finished = true;
    }
    const out = new DataView(new ArrayBuffer(DIGEST_LENGTH));
    for (let i2 = 0; i2 < 4; i2++) {
      out.setUint32(i2 * 4, this.state[i2], true);
    }
    return new Uint8Array(out.buffer, out.byteOffset, out.byteLength);
  }
  hashBuffer() {
    const { buffer, state } = this;
    let a2 = state[0], b2 = state[1], c2 = state[2], d2 = state[3];
    a2 = ff(a2, b2, c2, d2, buffer.getUint32(0, true), 7, 3614090360);
    d2 = ff(d2, a2, b2, c2, buffer.getUint32(4, true), 12, 3905402710);
    c2 = ff(c2, d2, a2, b2, buffer.getUint32(8, true), 17, 606105819);
    b2 = ff(b2, c2, d2, a2, buffer.getUint32(12, true), 22, 3250441966);
    a2 = ff(a2, b2, c2, d2, buffer.getUint32(16, true), 7, 4118548399);
    d2 = ff(d2, a2, b2, c2, buffer.getUint32(20, true), 12, 1200080426);
    c2 = ff(c2, d2, a2, b2, buffer.getUint32(24, true), 17, 2821735955);
    b2 = ff(b2, c2, d2, a2, buffer.getUint32(28, true), 22, 4249261313);
    a2 = ff(a2, b2, c2, d2, buffer.getUint32(32, true), 7, 1770035416);
    d2 = ff(d2, a2, b2, c2, buffer.getUint32(36, true), 12, 2336552879);
    c2 = ff(c2, d2, a2, b2, buffer.getUint32(40, true), 17, 4294925233);
    b2 = ff(b2, c2, d2, a2, buffer.getUint32(44, true), 22, 2304563134);
    a2 = ff(a2, b2, c2, d2, buffer.getUint32(48, true), 7, 1804603682);
    d2 = ff(d2, a2, b2, c2, buffer.getUint32(52, true), 12, 4254626195);
    c2 = ff(c2, d2, a2, b2, buffer.getUint32(56, true), 17, 2792965006);
    b2 = ff(b2, c2, d2, a2, buffer.getUint32(60, true), 22, 1236535329);
    a2 = gg(a2, b2, c2, d2, buffer.getUint32(4, true), 5, 4129170786);
    d2 = gg(d2, a2, b2, c2, buffer.getUint32(24, true), 9, 3225465664);
    c2 = gg(c2, d2, a2, b2, buffer.getUint32(44, true), 14, 643717713);
    b2 = gg(b2, c2, d2, a2, buffer.getUint32(0, true), 20, 3921069994);
    a2 = gg(a2, b2, c2, d2, buffer.getUint32(20, true), 5, 3593408605);
    d2 = gg(d2, a2, b2, c2, buffer.getUint32(40, true), 9, 38016083);
    c2 = gg(c2, d2, a2, b2, buffer.getUint32(60, true), 14, 3634488961);
    b2 = gg(b2, c2, d2, a2, buffer.getUint32(16, true), 20, 3889429448);
    a2 = gg(a2, b2, c2, d2, buffer.getUint32(36, true), 5, 568446438);
    d2 = gg(d2, a2, b2, c2, buffer.getUint32(56, true), 9, 3275163606);
    c2 = gg(c2, d2, a2, b2, buffer.getUint32(12, true), 14, 4107603335);
    b2 = gg(b2, c2, d2, a2, buffer.getUint32(32, true), 20, 1163531501);
    a2 = gg(a2, b2, c2, d2, buffer.getUint32(52, true), 5, 2850285829);
    d2 = gg(d2, a2, b2, c2, buffer.getUint32(8, true), 9, 4243563512);
    c2 = gg(c2, d2, a2, b2, buffer.getUint32(28, true), 14, 1735328473);
    b2 = gg(b2, c2, d2, a2, buffer.getUint32(48, true), 20, 2368359562);
    a2 = hh(a2, b2, c2, d2, buffer.getUint32(20, true), 4, 4294588738);
    d2 = hh(d2, a2, b2, c2, buffer.getUint32(32, true), 11, 2272392833);
    c2 = hh(c2, d2, a2, b2, buffer.getUint32(44, true), 16, 1839030562);
    b2 = hh(b2, c2, d2, a2, buffer.getUint32(56, true), 23, 4259657740);
    a2 = hh(a2, b2, c2, d2, buffer.getUint32(4, true), 4, 2763975236);
    d2 = hh(d2, a2, b2, c2, buffer.getUint32(16, true), 11, 1272893353);
    c2 = hh(c2, d2, a2, b2, buffer.getUint32(28, true), 16, 4139469664);
    b2 = hh(b2, c2, d2, a2, buffer.getUint32(40, true), 23, 3200236656);
    a2 = hh(a2, b2, c2, d2, buffer.getUint32(52, true), 4, 681279174);
    d2 = hh(d2, a2, b2, c2, buffer.getUint32(0, true), 11, 3936430074);
    c2 = hh(c2, d2, a2, b2, buffer.getUint32(12, true), 16, 3572445317);
    b2 = hh(b2, c2, d2, a2, buffer.getUint32(24, true), 23, 76029189);
    a2 = hh(a2, b2, c2, d2, buffer.getUint32(36, true), 4, 3654602809);
    d2 = hh(d2, a2, b2, c2, buffer.getUint32(48, true), 11, 3873151461);
    c2 = hh(c2, d2, a2, b2, buffer.getUint32(60, true), 16, 530742520);
    b2 = hh(b2, c2, d2, a2, buffer.getUint32(8, true), 23, 3299628645);
    a2 = ii(a2, b2, c2, d2, buffer.getUint32(0, true), 6, 4096336452);
    d2 = ii(d2, a2, b2, c2, buffer.getUint32(28, true), 10, 1126891415);
    c2 = ii(c2, d2, a2, b2, buffer.getUint32(56, true), 15, 2878612391);
    b2 = ii(b2, c2, d2, a2, buffer.getUint32(20, true), 21, 4237533241);
    a2 = ii(a2, b2, c2, d2, buffer.getUint32(48, true), 6, 1700485571);
    d2 = ii(d2, a2, b2, c2, buffer.getUint32(12, true), 10, 2399980690);
    c2 = ii(c2, d2, a2, b2, buffer.getUint32(40, true), 15, 4293915773);
    b2 = ii(b2, c2, d2, a2, buffer.getUint32(4, true), 21, 2240044497);
    a2 = ii(a2, b2, c2, d2, buffer.getUint32(32, true), 6, 1873313359);
    d2 = ii(d2, a2, b2, c2, buffer.getUint32(60, true), 10, 4264355552);
    c2 = ii(c2, d2, a2, b2, buffer.getUint32(24, true), 15, 2734768916);
    b2 = ii(b2, c2, d2, a2, buffer.getUint32(52, true), 21, 1309151649);
    a2 = ii(a2, b2, c2, d2, buffer.getUint32(16, true), 6, 4149444226);
    d2 = ii(d2, a2, b2, c2, buffer.getUint32(44, true), 10, 3174756917);
    c2 = ii(c2, d2, a2, b2, buffer.getUint32(8, true), 15, 718787259);
    b2 = ii(b2, c2, d2, a2, buffer.getUint32(36, true), 21, 3951481745);
    state[0] = a2 + state[0] & 4294967295;
    state[1] = b2 + state[1] & 4294967295;
    state[2] = c2 + state[2] & 4294967295;
    state[3] = d2 + state[3] & 4294967295;
  }
  reset() {
    this.state = Uint32Array.from(INIT);
    this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE));
    this.bufferLength = 0;
    this.bytesHashed = 0;
    this.finished = false;
  }
};
function cmn(q2, a2, b2, x2, s2, t2) {
  a2 = (a2 + q2 & 4294967295) + (x2 + t2 & 4294967295) & 4294967295;
  return (a2 << s2 | a2 >>> 32 - s2) + b2 & 4294967295;
}
function ff(a2, b2, c2, d2, x2, s2, t2) {
  return cmn(b2 & c2 | ~b2 & d2, a2, b2, x2, s2, t2);
}
function gg(a2, b2, c2, d2, x2, s2, t2) {
  return cmn(b2 & d2 | c2 & ~d2, a2, b2, x2, s2, t2);
}
function hh(a2, b2, c2, d2, x2, s2, t2) {
  return cmn(b2 ^ c2 ^ d2, a2, b2, x2, s2, t2);
}
function ii(a2, b2, c2, d2, x2, s2, t2) {
  return cmn(c2 ^ (b2 | ~d2), a2, b2, x2, s2, t2);
}
function isEmptyData2(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}
function convertToBuffer2(data) {
  if (typeof data === "string") {
    return fromUtf8(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}

// ../../node_modules/@smithy/util-body-length-browser/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-body-length-browser/dist-es/calculateBodyLength.js
init_checked_fetch();
init_modules_watch_stub();
var TEXT_ENCODER = typeof TextEncoder == "function" ? new TextEncoder() : null;
var calculateBodyLength = (body) => {
  if (typeof body === "string") {
    if (TEXT_ENCODER) {
      return TEXT_ENCODER.encode(body).byteLength;
    }
    let len = body.length;
    for (let i2 = len - 1; i2 >= 0; i2--) {
      const code = body.charCodeAt(i2);
      if (code > 127 && code <= 2047)
        len++;
      else if (code > 2047 && code <= 65535)
        len += 2;
      if (code >= 56320 && code <= 57343)
        i2--;
    }
    return len;
  } else if (typeof body.byteLength === "number") {
    return body.byteLength;
  } else if (typeof body.size === "number") {
    return body.size;
  }
  throw new Error(`Body Length computation failed for ${body}`);
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.shared.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/signature-v4-crt-container.js
init_checked_fetch();
init_modules_watch_stub();
var signatureV4CrtContainer = {
  CrtSignerV4: null
};

// ../../node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
var SignatureV4MultiRegion = class {
  constructor(options) {
    this.sigv4Signer = new SignatureV4S3Express(options);
    this.signerOptions = options;
  }
  async sign(requestToSign, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().sign(requestToSign, options);
    }
    return this.sigv4Signer.sign(requestToSign, options);
  }
  async signWithCredentials(requestToSign, credentials, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().signWithCredentials(requestToSign, credentials, options);
    }
    return this.sigv4Signer.signWithCredentials(requestToSign, credentials, options);
  }
  async presign(originalRequest, options = {}) {
    if (options.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().presign(originalRequest, options);
    }
    return this.sigv4Signer.presign(originalRequest, options);
  }
  async presignWithCredentials(originalRequest, credentials, options = {}) {
    if (options.signingRegion === "*") {
      throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
    }
    return this.sigv4Signer.presignWithCredentials(originalRequest, credentials, options);
  }
  getSigv4aSigner() {
    if (!this.sigv4aSigner) {
      let CrtSignerV4 = null;
      try {
        CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
        if (typeof CrtSignerV4 !== "function")
          throw new Error();
      } catch (e2) {
        e2.message = `${e2.message}
Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. 
You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`;
        throw e2;
      }
      this.sigv4aSigner = new CrtSignerV4({
        ...this.signerOptions,
        signingAlgorithm: 1
      });
    }
    return this.sigv4aSigner;
  }
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/client-s3/dist-es/endpoint/ruleset.js
init_checked_fetch();
init_modules_watch_stub();
var ce = "required";
var cf = "type";
var cg = "conditions";
var ch = "fn";
var ci = "argv";
var cj = "ref";
var ck = "assign";
var cl = "url";
var cm = "properties";
var cn = "backend";
var co = "authSchemes";
var cp = "disableDoubleEncoding";
var cq = "signingName";
var cr = "signingRegion";
var cs = "headers";
var ct = "signingRegionSet";
var a = false;
var b = true;
var c = "isSet";
var d = "booleanEquals";
var e = "error";
var f = "aws.partition";
var g = "stringEquals";
var h = "getAttr";
var i = "name";
var j = "substring";
var k = "bucketSuffix";
var l = "parseURL";
var m = "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}";
var n = "endpoint";
var o = "tree";
var p = "aws.isVirtualHostableS3Bucket";
var q = "{url#scheme}://{Bucket}.{url#authority}{url#path}";
var r = "not";
var s = "{url#scheme}://{url#authority}{url#path}";
var t = "hardwareType";
var u = "regionPrefix";
var v = "bucketAliasSuffix";
var w = "outpostId";
var x = "isValidHostLabel";
var y = "sigv4a";
var z2 = "s3-outposts";
var A = "s3";
var B = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}";
var C = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}";
var D = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
var E = "aws.parseArn";
var F = "bucketArn";
var G = "arnType";
var H = "";
var I = "s3-object-lambda";
var J = "accesspoint";
var K = "accessPointName";
var L = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
var M = "mrapPartition";
var N = "outpostType";
var O = "arnPrefix";
var P = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}";
var Q = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}";
var R = "https://s3.{partitionResult#dnsSuffix}";
var S = { [ce]: false, [cf]: "String" };
var T = { [ce]: true, "default": false, [cf]: "Boolean" };
var U = { [ce]: false, [cf]: "Boolean" };
var V = { [ch]: d, [ci]: [{ [cj]: "Accelerate" }, true] };
var W = { [ch]: d, [ci]: [{ [cj]: "UseFIPS" }, true] };
var X = { [ch]: d, [ci]: [{ [cj]: "UseDualStack" }, true] };
var Y = { [ch]: c, [ci]: [{ [cj]: "Endpoint" }] };
var Z = { [ch]: f, [ci]: [{ [cj]: "Region" }], [ck]: "partitionResult" };
var aa = { [ch]: g, [ci]: [{ [ch]: h, [ci]: [{ [cj]: "partitionResult" }, i] }, "aws-cn"] };
var ab = { [ch]: c, [ci]: [{ [cj]: "Bucket" }] };
var ac = { [cj]: "Bucket" };
var ad = { [ch]: l, [ci]: [{ [cj]: "Endpoint" }], [ck]: "url" };
var ae = { [ch]: d, [ci]: [{ [ch]: h, [ci]: [{ [cj]: "url" }, "isIp"] }, true] };
var af = { [cj]: "url" };
var ag = { [ch]: "uriEncode", [ci]: [ac], [ck]: "uri_encoded_bucket" };
var ah = { [cn]: "S3Express", [co]: [{ [cp]: true, [i]: "sigv4", [cq]: "s3express", [cr]: "{Region}" }] };
var ai = {};
var aj = { [ch]: p, [ci]: [ac, false] };
var ak = { [e]: "S3Express bucket name is not a valid virtual hostable name.", [cf]: e };
var al = { [cn]: "S3Express", [co]: [{ [cp]: true, [i]: "sigv4-s3express", [cq]: "s3express", [cr]: "{Region}" }] };
var am = { [ch]: c, [ci]: [{ [cj]: "UseS3ExpressControlEndpoint" }] };
var an = { [ch]: d, [ci]: [{ [cj]: "UseS3ExpressControlEndpoint" }, true] };
var ao = { [ch]: r, [ci]: [Y] };
var ap = { [e]: "Unrecognized S3Express bucket name format.", [cf]: e };
var aq = { [ch]: r, [ci]: [ab] };
var ar = { [cj]: t };
var as = { [cg]: [ao], [e]: "Expected a endpoint to be specified but no endpoint was found", [cf]: e };
var at = { [co]: [{ [cp]: true, [i]: y, [cq]: z2, [ct]: ["*"] }, { [cp]: true, [i]: "sigv4", [cq]: z2, [cr]: "{Region}" }] };
var au = { [ch]: d, [ci]: [{ [cj]: "ForcePathStyle" }, false] };
var av = { [cj]: "ForcePathStyle" };
var aw = { [ch]: d, [ci]: [{ [cj]: "Accelerate" }, false] };
var ax = { [ch]: g, [ci]: [{ [cj]: "Region" }, "aws-global"] };
var ay = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: A, [cr]: "us-east-1" }] };
var az = { [ch]: r, [ci]: [ax] };
var aA = { [ch]: d, [ci]: [{ [cj]: "UseGlobalEndpoint" }, true] };
var aB = { [cl]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: A, [cr]: "{Region}" }] }, [cs]: {} };
var aC = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: A, [cr]: "{Region}" }] };
var aD = { [ch]: d, [ci]: [{ [cj]: "UseGlobalEndpoint" }, false] };
var aE = { [ch]: d, [ci]: [{ [cj]: "UseDualStack" }, false] };
var aF = { [cl]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var aG = { [ch]: d, [ci]: [{ [cj]: "UseFIPS" }, false] };
var aH = { [cl]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var aI = { [cl]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var aJ = { [ch]: d, [ci]: [{ [ch]: h, [ci]: [af, "isIp"] }, false] };
var aK = { [cl]: B, [cm]: aC, [cs]: {} };
var aL = { [cl]: q, [cm]: aC, [cs]: {} };
var aM = { [n]: aL, [cf]: n };
var aN = { [cl]: C, [cm]: aC, [cs]: {} };
var aO = { [cl]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var aP = { [e]: "Invalid region: region was not a valid DNS name.", [cf]: e };
var aQ = { [cj]: F };
var aR = { [cj]: G };
var aS = { [ch]: h, [ci]: [aQ, "service"] };
var aT = { [cj]: K };
var aU = { [cg]: [X], [e]: "S3 Object Lambda does not support Dual-stack", [cf]: e };
var aV = { [cg]: [V], [e]: "S3 Object Lambda does not support S3 Accelerate", [cf]: e };
var aW = { [cg]: [{ [ch]: c, [ci]: [{ [cj]: "DisableAccessPoints" }] }, { [ch]: d, [ci]: [{ [cj]: "DisableAccessPoints" }, true] }], [e]: "Access points are not supported for this operation", [cf]: e };
var aX = { [cg]: [{ [ch]: c, [ci]: [{ [cj]: "UseArnRegion" }] }, { [ch]: d, [ci]: [{ [cj]: "UseArnRegion" }, false] }, { [ch]: r, [ci]: [{ [ch]: g, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }, "{Region}"] }] }], [e]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [cf]: e };
var aY = { [ch]: h, [ci]: [{ [cj]: "bucketPartition" }, i] };
var aZ = { [ch]: h, [ci]: [aQ, "accountId"] };
var ba = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: I, [cr]: "{bucketArn#region}" }] };
var bb = { [e]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [cf]: e };
var bc = { [e]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [cf]: e };
var bd = { [e]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [cf]: e };
var be = { [e]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [cf]: e };
var bf = { [e]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [cf]: e };
var bg = { [e]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [cf]: e };
var bh = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: A, [cr]: "{bucketArn#region}" }] };
var bi = { [co]: [{ [cp]: true, [i]: y, [cq]: z2, [ct]: ["*"] }, { [cp]: true, [i]: "sigv4", [cq]: z2, [cr]: "{bucketArn#region}" }] };
var bj = { [ch]: E, [ci]: [ac] };
var bk = { [cl]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} };
var bl = { [cl]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} };
var bm = { [cl]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} };
var bn = { [cl]: P, [cm]: aC, [cs]: {} };
var bo = { [cl]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: aC, [cs]: {} };
var bp = { [cj]: "UseObjectLambdaEndpoint" };
var bq = { [co]: [{ [cp]: true, [i]: "sigv4", [cq]: I, [cr]: "{Region}" }] };
var br = { [cl]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var bs = { [cl]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var bt = { [cl]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var bu = { [cl]: s, [cm]: aC, [cs]: {} };
var bv = { [cl]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [cm]: aC, [cs]: {} };
var bw = [{ [cj]: "Region" }];
var bx = [{ [cj]: "Endpoint" }];
var by = [ac];
var bz = [X];
var bA = [V];
var bB = [Y, ad];
var bC = [{ [ch]: c, [ci]: [{ [cj]: "DisableS3ExpressSessionAuth" }] }, { [ch]: d, [ci]: [{ [cj]: "DisableS3ExpressSessionAuth" }, true] }];
var bD = [ae];
var bE = [ag];
var bF = [aj];
var bG = [W];
var bH = [{ [ch]: j, [ci]: [ac, 6, 14, true], [ck]: "s3expressAvailabilityZoneId" }, { [ch]: j, [ci]: [ac, 14, 16, true], [ck]: "s3expressAvailabilityZoneDelim" }, { [ch]: g, [ci]: [{ [cj]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bI = [{ [cg]: [W], [n]: { [cl]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: ah, [cs]: {} }, [cf]: n }, { [n]: { [cl]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: ah, [cs]: {} }, [cf]: n }];
var bJ = [{ [ch]: j, [ci]: [ac, 6, 15, true], [ck]: "s3expressAvailabilityZoneId" }, { [ch]: j, [ci]: [ac, 15, 17, true], [ck]: "s3expressAvailabilityZoneDelim" }, { [ch]: g, [ci]: [{ [cj]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bK = [{ [cg]: [W], [n]: { [cl]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: al, [cs]: {} }, [cf]: n }, { [n]: { [cl]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [cm]: al, [cs]: {} }, [cf]: n }];
var bL = [ab];
var bM = [{ [ch]: x, [ci]: [{ [cj]: w }, false] }];
var bN = [{ [ch]: g, [ci]: [{ [cj]: u }, "beta"] }];
var bO = ["*"];
var bP = [Z];
var bQ = [{ [ch]: x, [ci]: [{ [cj]: "Region" }, false] }];
var bR = [{ [ch]: g, [ci]: [{ [cj]: "Region" }, "us-east-1"] }];
var bS = [{ [ch]: g, [ci]: [aR, J] }];
var bT = [{ [ch]: h, [ci]: [aQ, "resourceId[1]"], [ck]: K }, { [ch]: r, [ci]: [{ [ch]: g, [ci]: [aT, H] }] }];
var bU = [aQ, "resourceId[1]"];
var bV = [{ [ch]: r, [ci]: [{ [ch]: g, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }, H] }] }];
var bW = [{ [ch]: r, [ci]: [{ [ch]: c, [ci]: [{ [ch]: h, [ci]: [aQ, "resourceId[2]"] }] }] }];
var bX = [aQ, "resourceId[2]"];
var bY = [{ [ch]: f, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }], [ck]: "bucketPartition" }];
var bZ = [{ [ch]: g, [ci]: [aY, { [ch]: h, [ci]: [{ [cj]: "partitionResult" }, i] }] }];
var ca = [{ [ch]: x, [ci]: [{ [ch]: h, [ci]: [aQ, "region"] }, true] }];
var cb = [{ [ch]: x, [ci]: [aZ, false] }];
var cc = [{ [ch]: x, [ci]: [aT, false] }];
var cd = [{ [ch]: x, [ci]: [{ [cj]: "Region" }, true] }];
var _data = { version: "1.0", parameters: { Bucket: S, Region: S, UseFIPS: T, UseDualStack: T, Endpoint: S, ForcePathStyle: T, Accelerate: T, UseGlobalEndpoint: T, UseObjectLambdaEndpoint: U, Key: S, Prefix: S, DisableAccessPoints: U, DisableMultiRegionAccessPoints: T, UseArnRegion: U, UseS3ExpressControlEndpoint: U, DisableS3ExpressSessionAuth: U }, rules: [{ [cg]: [{ [ch]: c, [ci]: bw }], rules: [{ [cg]: [V, W], error: "Accelerate cannot be used with FIPS", [cf]: e }, { [cg]: [X, Y], error: "Cannot set dual-stack in combination with a custom endpoint.", [cf]: e }, { [cg]: [Y, W], error: "A custom endpoint cannot be combined with FIPS", [cf]: e }, { [cg]: [Y, V], error: "A custom endpoint cannot be combined with S3 Accelerate", [cf]: e }, { [cg]: [W, Z, aa], error: "Partition does not support FIPS", [cf]: e }, { [cg]: [ab, { [ch]: j, [ci]: [ac, 0, 6, b], [ck]: k }, { [ch]: g, [ci]: [{ [cj]: k }, "--x-s3"] }], rules: [{ [cg]: bz, error: "S3Express does not support Dual-stack.", [cf]: e }, { [cg]: bA, error: "S3Express does not support S3 Accelerate.", [cf]: e }, { [cg]: bB, rules: [{ [cg]: bC, rules: [{ [cg]: bD, rules: [{ [cg]: bE, rules: [{ endpoint: { [cl]: m, [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }], [cf]: o }, { [cg]: bF, rules: [{ endpoint: { [cl]: q, [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }, ak], [cf]: o }, { [cg]: bD, rules: [{ [cg]: bE, rules: [{ endpoint: { [cl]: m, [cm]: al, [cs]: ai }, [cf]: n }], [cf]: o }], [cf]: o }, { [cg]: bF, rules: [{ endpoint: { [cl]: q, [cm]: al, [cs]: ai }, [cf]: n }], [cf]: o }, ak], [cf]: o }, { [cg]: [am, an], rules: [{ [cg]: [ag, ao], rules: [{ [cg]: bG, endpoint: { [cl]: "https://s3express-control-fips.{Region}.amazonaws.com/{uri_encoded_bucket}", [cm]: ah, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://s3express-control.{Region}.amazonaws.com/{uri_encoded_bucket}", [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }], [cf]: o }, { [cg]: bF, rules: [{ [cg]: bC, rules: [{ [cg]: bH, rules: bI, [cf]: o }, { [cg]: bJ, rules: bI, [cf]: o }, ap], [cf]: o }, { [cg]: bH, rules: bK, [cf]: o }, { [cg]: bJ, rules: bK, [cf]: o }, ap], [cf]: o }, ak], [cf]: o }, { [cg]: [aq, am, an], rules: [{ [cg]: bB, endpoint: { [cl]: s, [cm]: ah, [cs]: ai }, [cf]: n }, { [cg]: bG, endpoint: { [cl]: "https://s3express-control-fips.{Region}.amazonaws.com", [cm]: ah, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://s3express-control.{Region}.amazonaws.com", [cm]: ah, [cs]: ai }, [cf]: n }], [cf]: o }, { [cg]: [ab, { [ch]: j, [ci]: [ac, 49, 50, b], [ck]: t }, { [ch]: j, [ci]: [ac, 8, 12, b], [ck]: u }, { [ch]: j, [ci]: [ac, 0, 7, b], [ck]: v }, { [ch]: j, [ci]: [ac, 32, 49, b], [ck]: w }, { [ch]: f, [ci]: bw, [ck]: "regionPartition" }, { [ch]: g, [ci]: [{ [cj]: v }, "--op-s3"] }], rules: [{ [cg]: bM, rules: [{ [cg]: [{ [ch]: g, [ci]: [ar, "e"] }], rules: [{ [cg]: bN, rules: [as, { [cg]: bB, endpoint: { [cl]: "https://{Bucket}.ec2.{url#authority}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { endpoint: { [cl]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { [cg]: [{ [ch]: g, [ci]: [ar, "o"] }], rules: [{ [cg]: bN, rules: [as, { [cg]: bB, endpoint: { [cl]: "https://{Bucket}.op-{outpostId}.{url#authority}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { endpoint: { [cl]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cm]: at, [cs]: ai }, [cf]: n }], [cf]: o }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [cf]: e }], [cf]: o }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [cf]: e }], [cf]: o }, { [cg]: bL, rules: [{ [cg]: [Y, { [ch]: r, [ci]: [{ [ch]: c, [ci]: [{ [ch]: l, [ci]: bx }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [cf]: e }, { [cg]: [au, aj], rules: [{ [cg]: bP, rules: [{ [cg]: bQ, rules: [{ [cg]: [V, aa], error: "S3 Accelerate cannot be used in this region", [cf]: e }, { [cg]: [X, W, aw, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, W, aw, ao, az, aA], rules: [{ endpoint: aB, [cf]: n }], [cf]: o }, { [cg]: [X, W, aw, ao, az, aD], endpoint: aB, [cf]: n }, { [cg]: [aE, W, aw, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, W, aw, ao, az, aA], rules: [{ endpoint: aF, [cf]: n }], [cf]: o }, { [cg]: [aE, W, aw, ao, az, aD], endpoint: aF, [cf]: n }, { [cg]: [X, aG, V, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, aG, V, ao, az, aA], rules: [{ endpoint: aH, [cf]: n }], [cf]: o }, { [cg]: [X, aG, V, ao, az, aD], endpoint: aH, [cf]: n }, { [cg]: [X, aG, aw, ao, ax], endpoint: { [cl]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, aG, aw, ao, az, aA], rules: [{ endpoint: aI, [cf]: n }], [cf]: o }, { [cg]: [X, aG, aw, ao, az, aD], endpoint: aI, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, ae, ax], endpoint: { [cl]: B, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, aJ, ax], endpoint: { [cl]: q, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, ae, az, aA], rules: [{ [cg]: bR, endpoint: aK, [cf]: n }, { endpoint: aK, [cf]: n }], [cf]: o }, { [cg]: [aE, aG, aw, Y, ad, aJ, az, aA], rules: [{ [cg]: bR, endpoint: aL, [cf]: n }, aM], [cf]: o }, { [cg]: [aE, aG, aw, Y, ad, ae, az, aD], endpoint: aK, [cf]: n }, { [cg]: [aE, aG, aw, Y, ad, aJ, az, aD], endpoint: aL, [cf]: n }, { [cg]: [aE, aG, V, ao, ax], endpoint: { [cl]: C, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, V, ao, az, aA], rules: [{ [cg]: bR, endpoint: aN, [cf]: n }, { endpoint: aN, [cf]: n }], [cf]: o }, { [cg]: [aE, aG, V, ao, az, aD], endpoint: aN, [cf]: n }, { [cg]: [aE, aG, aw, ao, ax], endpoint: { [cl]: D, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, aG, aw, ao, az, aA], rules: [{ [cg]: bR, endpoint: { [cl]: D, [cm]: aC, [cs]: ai }, [cf]: n }, { endpoint: aO, [cf]: n }], [cf]: o }, { [cg]: [aE, aG, aw, ao, az, aD], endpoint: aO, [cf]: n }], [cf]: o }, aP], [cf]: o }], [cf]: o }, { [cg]: [Y, ad, { [ch]: g, [ci]: [{ [ch]: h, [ci]: [af, "scheme"] }, "http"] }, { [ch]: p, [ci]: [ac, b] }, au, aG, aE, aw], rules: [{ [cg]: bP, rules: [{ [cg]: bQ, rules: [aM], [cf]: o }, aP], [cf]: o }], [cf]: o }, { [cg]: [au, { [ch]: E, [ci]: by, [ck]: F }], rules: [{ [cg]: [{ [ch]: h, [ci]: [aQ, "resourceId[0]"], [ck]: G }, { [ch]: r, [ci]: [{ [ch]: g, [ci]: [aR, H] }] }], rules: [{ [cg]: [{ [ch]: g, [ci]: [aS, I] }], rules: [{ [cg]: bS, rules: [{ [cg]: bT, rules: [aU, aV, { [cg]: bV, rules: [aW, { [cg]: bW, rules: [aX, { [cg]: bY, rules: [{ [cg]: bP, rules: [{ [cg]: bZ, rules: [{ [cg]: ca, rules: [{ [cg]: [{ [ch]: g, [ci]: [aZ, H] }], error: "Invalid ARN: Missing account id", [cf]: e }, { [cg]: cb, rules: [{ [cg]: cc, rules: [{ [cg]: bB, endpoint: { [cl]: L, [cm]: ba, [cs]: ai }, [cf]: n }, { [cg]: bG, endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: ba, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: ba, [cs]: ai }, [cf]: n }], [cf]: o }, bb], [cf]: o }, bc], [cf]: o }, bd], [cf]: o }, be], [cf]: o }], [cf]: o }], [cf]: o }, bf], [cf]: o }, { error: "Invalid ARN: bucket ARN is missing a region", [cf]: e }], [cf]: o }, bg], [cf]: o }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [cf]: e }], [cf]: o }, { [cg]: bS, rules: [{ [cg]: bT, rules: [{ [cg]: bV, rules: [{ [cg]: bS, rules: [{ [cg]: bV, rules: [aW, { [cg]: bW, rules: [aX, { [cg]: bY, rules: [{ [cg]: bP, rules: [{ [cg]: [{ [ch]: g, [ci]: [aY, "{partitionResult#name}"] }], rules: [{ [cg]: ca, rules: [{ [cg]: [{ [ch]: g, [ci]: [aS, A] }], rules: [{ [cg]: cb, rules: [{ [cg]: cc, rules: [{ [cg]: bA, error: "Access Points do not support S3 Accelerate", [cf]: e }, { [cg]: [W, X], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [W, aE], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [aG, X], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE, Y, ad], endpoint: { [cl]: L, [cm]: bh, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE], endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bh, [cs]: ai }, [cf]: n }], [cf]: o }, bb], [cf]: o }, bc], [cf]: o }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [cf]: e }], [cf]: o }, bd], [cf]: o }, be], [cf]: o }], [cf]: o }], [cf]: o }, bf], [cf]: o }], [cf]: o }], [cf]: o }, { [cg]: [{ [ch]: x, [ci]: [aT, b] }], rules: [{ [cg]: bz, error: "S3 MRAP does not support dual-stack", [cf]: e }, { [cg]: bG, error: "S3 MRAP does not support FIPS", [cf]: e }, { [cg]: bA, error: "S3 MRAP does not support S3 Accelerate", [cf]: e }, { [cg]: [{ [ch]: d, [ci]: [{ [cj]: "DisableMultiRegionAccessPoints" }, b] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [cf]: e }, { [cg]: [{ [ch]: f, [ci]: bw, [ck]: M }], rules: [{ [cg]: [{ [ch]: g, [ci]: [{ [ch]: h, [ci]: [{ [cj]: M }, i] }, { [ch]: h, [ci]: [aQ, "partition"] }] }], rules: [{ endpoint: { [cl]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [cm]: { [co]: [{ [cp]: b, name: y, [cq]: A, [ct]: bO }] }, [cs]: ai }, [cf]: n }], [cf]: o }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [cf]: e }], [cf]: o }], [cf]: o }, { error: "Invalid Access Point Name", [cf]: e }], [cf]: o }, bg], [cf]: o }, { [cg]: [{ [ch]: g, [ci]: [aS, z2] }], rules: [{ [cg]: bz, error: "S3 Outposts does not support Dual-stack", [cf]: e }, { [cg]: bG, error: "S3 Outposts does not support FIPS", [cf]: e }, { [cg]: bA, error: "S3 Outposts does not support S3 Accelerate", [cf]: e }, { [cg]: [{ [ch]: c, [ci]: [{ [ch]: h, [ci]: [aQ, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [cf]: e }, { [cg]: [{ [ch]: h, [ci]: bU, [ck]: w }], rules: [{ [cg]: bM, rules: [aX, { [cg]: bY, rules: [{ [cg]: bP, rules: [{ [cg]: bZ, rules: [{ [cg]: ca, rules: [{ [cg]: cb, rules: [{ [cg]: [{ [ch]: h, [ci]: bX, [ck]: N }], rules: [{ [cg]: [{ [ch]: h, [ci]: [aQ, "resourceId[3]"], [ck]: K }], rules: [{ [cg]: [{ [ch]: g, [ci]: [{ [cj]: N }, J] }], rules: [{ [cg]: bB, endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [cm]: bi, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cm]: bi, [cs]: ai }, [cf]: n }], [cf]: o }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [cf]: e }], [cf]: o }, { error: "Invalid ARN: expected an access point name", [cf]: e }], [cf]: o }, { error: "Invalid ARN: Expected a 4-component resource", [cf]: e }], [cf]: o }, bc], [cf]: o }, bd], [cf]: o }, be], [cf]: o }], [cf]: o }], [cf]: o }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [cf]: e }], [cf]: o }, { error: "Invalid ARN: The Outpost Id was not set", [cf]: e }], [cf]: o }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [cf]: e }], [cf]: o }, { error: "Invalid ARN: No ARN type specified", [cf]: e }], [cf]: o }, { [cg]: [{ [ch]: j, [ci]: [ac, 0, 4, a], [ck]: O }, { [ch]: g, [ci]: [{ [cj]: O }, "arn:"] }, { [ch]: r, [ci]: [{ [ch]: c, [ci]: [bj] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [cf]: e }, { [cg]: [{ [ch]: d, [ci]: [av, b] }, bj], error: "Path-style addressing cannot be used with ARN buckets", [cf]: e }, { [cg]: bE, rules: [{ [cg]: bP, rules: [{ [cg]: [aw], rules: [{ [cg]: [X, ao, W, ax], endpoint: { [cl]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, ao, W, az, aA], rules: [{ endpoint: bk, [cf]: n }], [cf]: o }, { [cg]: [X, ao, W, az, aD], endpoint: bk, [cf]: n }, { [cg]: [aE, ao, W, ax], endpoint: { [cl]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, ao, W, az, aA], rules: [{ endpoint: bl, [cf]: n }], [cf]: o }, { [cg]: [aE, ao, W, az, aD], endpoint: bl, [cf]: n }, { [cg]: [X, ao, aG, ax], endpoint: { [cl]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [X, ao, aG, az, aA], rules: [{ endpoint: bm, [cf]: n }], [cf]: o }, { [cg]: [X, ao, aG, az, aD], endpoint: bm, [cf]: n }, { [cg]: [aE, Y, ad, aG, ax], endpoint: { [cl]: P, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, Y, ad, aG, az, aA], rules: [{ [cg]: bR, endpoint: bn, [cf]: n }, { endpoint: bn, [cf]: n }], [cf]: o }, { [cg]: [aE, Y, ad, aG, az, aD], endpoint: bn, [cf]: n }, { [cg]: [aE, ao, aG, ax], endpoint: { [cl]: Q, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aE, ao, aG, az, aA], rules: [{ [cg]: bR, endpoint: { [cl]: Q, [cm]: aC, [cs]: ai }, [cf]: n }, { endpoint: bo, [cf]: n }], [cf]: o }, { [cg]: [aE, ao, aG, az, aD], endpoint: bo, [cf]: n }], [cf]: o }, { error: "Path-style addressing cannot be used with S3 Accelerate", [cf]: e }], [cf]: o }], [cf]: o }], [cf]: o }, { [cg]: [{ [ch]: c, [ci]: [bp] }, { [ch]: d, [ci]: [bp, b] }], rules: [{ [cg]: bP, rules: [{ [cg]: cd, rules: [aU, aV, { [cg]: bB, endpoint: { [cl]: s, [cm]: bq, [cs]: ai }, [cf]: n }, { [cg]: bG, endpoint: { [cl]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [cm]: bq, [cs]: ai }, [cf]: n }, { endpoint: { [cl]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [cm]: bq, [cs]: ai }, [cf]: n }], [cf]: o }, aP], [cf]: o }], [cf]: o }, { [cg]: [aq], rules: [{ [cg]: bP, rules: [{ [cg]: cd, rules: [{ [cg]: [W, X, ao, ax], endpoint: { [cl]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [W, X, ao, az, aA], rules: [{ endpoint: br, [cf]: n }], [cf]: o }, { [cg]: [W, X, ao, az, aD], endpoint: br, [cf]: n }, { [cg]: [W, aE, ao, ax], endpoint: { [cl]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [W, aE, ao, az, aA], rules: [{ endpoint: bs, [cf]: n }], [cf]: o }, { [cg]: [W, aE, ao, az, aD], endpoint: bs, [cf]: n }, { [cg]: [aG, X, ao, ax], endpoint: { [cl]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aG, X, ao, az, aA], rules: [{ endpoint: bt, [cf]: n }], [cf]: o }, { [cg]: [aG, X, ao, az, aD], endpoint: bt, [cf]: n }, { [cg]: [aG, aE, Y, ad, ax], endpoint: { [cl]: s, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE, Y, ad, az, aA], rules: [{ [cg]: bR, endpoint: bu, [cf]: n }, { endpoint: bu, [cf]: n }], [cf]: o }, { [cg]: [aG, aE, Y, ad, az, aD], endpoint: bu, [cf]: n }, { [cg]: [aG, aE, ao, ax], endpoint: { [cl]: R, [cm]: ay, [cs]: ai }, [cf]: n }, { [cg]: [aG, aE, ao, az, aA], rules: [{ [cg]: bR, endpoint: { [cl]: R, [cm]: aC, [cs]: ai }, [cf]: n }, { endpoint: bv, [cf]: n }], [cf]: o }, { [cg]: [aG, aE, ao, az, aD], endpoint: bv, [cf]: n }], [cf]: o }, aP], [cf]: o }], [cf]: o }], [cf]: o }, { error: "A region must be set when sending requests to S3.", [cf]: e }] };
var ruleSet = _data;

// ../../node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js
var defaultEndpointResolver = (endpointParams, context = {}) => {
  return resolveEndpoint(ruleSet, {
    endpointParams,
    logger: context.logger
  });
};
customEndpointFunctions.aws = awsEndpointFunctions;

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.shared.js
var getRuntimeConfig = (config) => {
  return {
    apiVersion: "2006-03-01",
    base64Decoder: config?.base64Decoder ?? fromBase64,
    base64Encoder: config?.base64Encoder ?? toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
    extensions: config?.extensions ?? [],
    getAwsChunkedEncodingStream: config?.getAwsChunkedEncodingStream ?? getAwsChunkedEncodingStream,
    logger: config?.logger ?? new NoOpLogger(),
    sdkStreamMixin: config?.sdkStreamMixin ?? sdkStreamMixin,
    serviceId: config?.serviceId ?? "S3",
    signerConstructor: config?.signerConstructor ?? SignatureV4MultiRegion,
    signingEscapePath: config?.signingEscapePath ?? false,
    urlParser: config?.urlParser ?? parseUrl,
    useArnRegion: config?.useArnRegion ?? false,
    utf8Decoder: config?.utf8Decoder ?? fromUtf8,
    utf8Encoder: config?.utf8Encoder ?? toUtf8
  };
};

// ../../node_modules/@smithy/util-defaults-mode-browser/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@smithy/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js
init_checked_fetch();
init_modules_watch_stub();
var import_bowser2 = __toESM(require_es5());

// ../../node_modules/@smithy/util-defaults-mode-browser/dist-es/constants.js
init_checked_fetch();
init_modules_watch_stub();
var DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];

// ../../node_modules/@smithy/util-defaults-mode-browser/dist-es/resolveDefaultsModeConfig.js
var resolveDefaultsModeConfig = ({ defaultsMode } = {}) => memoize(async () => {
  const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
  switch (mode?.toLowerCase()) {
    case "auto":
      return Promise.resolve(isMobileBrowser() ? "mobile" : "standard");
    case "mobile":
    case "in-region":
    case "cross-region":
    case "standard":
    case "legacy":
      return Promise.resolve(mode?.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
  }
});
var isMobileBrowser = () => {
  const parsedUA = typeof window !== "undefined" && window?.navigator?.userAgent ? import_bowser2.default.parse(window.navigator.userAgent) : void 0;
  const platform = parsedUA?.platform?.type;
  return platform === "tablet" || platform === "mobile";
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.browser.js
var getRuntimeConfig2 = (config) => {
  const defaultsMode = resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig(config);
  return {
    ...clientSharedValues,
    ...config,
    runtime: "browser",
    defaultsMode,
    bodyLengthChecker: config?.bodyLengthChecker ?? calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? ((_) => () => Promise.reject(new Error("Credential is missing"))),
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? defaultUserAgent({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
    eventStreamSerdeProvider: config?.eventStreamSerdeProvider ?? eventStreamSerdeProvider,
    maxAttempts: config?.maxAttempts ?? DEFAULT_MAX_ATTEMPTS,
    md5: config?.md5 ?? Md5,
    region: config?.region ?? invalidProvider("Region is missing"),
    requestHandler: FetchHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
    retryMode: config?.retryMode ?? (async () => (await defaultConfigProvider()).retryMode || DEFAULT_RETRY_MODE),
    sha1: config?.sha1 ?? import_sha1_browser.Sha1,
    sha256: config?.sha256 ?? import_sha256_browser.Sha256,
    streamCollector: config?.streamCollector ?? streamCollector,
    streamHasher: config?.streamHasher ?? blobHasher,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),
    useFipsEndpoint: config?.useFipsEndpoint ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT))
  };
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeExtensions.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/region-config-resolver/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/region-config-resolver/dist-es/extensions/index.js
init_checked_fetch();
init_modules_watch_stub();
var getAwsRegionExtensionConfiguration = (runtimeConfig) => {
  let runtimeConfigRegion = async () => {
    if (runtimeConfig.region === void 0) {
      throw new Error("Region is missing from runtimeConfig");
    }
    const region = runtimeConfig.region;
    if (typeof region === "string") {
      return region;
    }
    return region();
  };
  return {
    setRegion(region) {
      runtimeConfigRegion = region;
    },
    region() {
      return runtimeConfigRegion;
    }
  };
};
var resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
  return {
    region: awsRegionExtensionConfiguration.region()
  };
};

// ../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/config.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/resolveRegionConfig.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/getRealRegion.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/region-config-resolver/dist-es/regionConfig/isFipsRegion.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/client-s3/dist-es/runtimeExtensions.js
var asPartial = (t2) => t2;
var resolveRuntimeExtensions = (runtimeConfig, extensions) => {
  const extensionConfiguration = {
    ...asPartial(getAwsRegionExtensionConfiguration(runtimeConfig)),
    ...asPartial(getDefaultExtensionConfiguration(runtimeConfig)),
    ...asPartial(getHttpHandlerExtensionConfiguration(runtimeConfig))
  };
  extensions.forEach((extension) => extension.configure(extensionConfiguration));
  return {
    ...runtimeConfig,
    ...resolveAwsRegionExtensionConfiguration(extensionConfiguration),
    ...resolveDefaultRuntimeConfig(extensionConfiguration),
    ...resolveHttpHandlerRuntimeConfig(extensionConfiguration)
  };
};

// ../../node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
var S3Client = class extends Client {
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig2(configuration || {});
    const _config_1 = resolveClientEndpointParameters(_config_0);
    const _config_2 = resolveRegionConfig(_config_1);
    const _config_3 = resolveEndpointConfig(_config_2);
    const _config_4 = resolveRetryConfig(_config_3);
    const _config_5 = resolveHostHeaderConfig(_config_4);
    const _config_6 = resolveAwsAuthConfig(_config_5);
    const _config_7 = resolveS3Config(_config_6, { session: [() => this, CreateSessionCommand] });
    const _config_8 = resolveUserAgentConfig(_config_7);
    const _config_9 = resolveEventStreamSerdeConfig(_config_8);
    const _config_10 = resolveRuntimeExtensions(_config_9, configuration?.extensions || []);
    super(_config_10);
    this.config = _config_10;
    this.middlewareStack.use(getRetryPlugin(this.config));
    this.middlewareStack.use(getContentLengthPlugin(this.config));
    this.middlewareStack.use(getHostHeaderPlugin(this.config));
    this.middlewareStack.use(getLoggerPlugin(this.config));
    this.middlewareStack.use(getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(getAwsAuthPlugin(this.config));
    this.middlewareStack.use(getValidateBucketNamePlugin(this.config));
    this.middlewareStack.use(getAddExpectContinuePlugin(this.config));
    this.middlewareStack.use(getRegionRedirectMiddlewarePlugin(this.config));
    this.middlewareStack.use(getS3ExpressPlugin(this.config));
    this.middlewareStack.use(getUserAgentPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
};

// ../../node_modules/@aws-sdk/s3-request-presigner/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/s3-request-presigner/dist-es/getSignedUrl.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/util-format-url/dist-es/index.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/s3-request-presigner/dist-es/presigner.js
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@aws-sdk/s3-request-presigner/dist-es/constants.js
init_checked_fetch();
init_modules_watch_stub();

// src/lib/cloudflare-r2.ts
var generateS3Client = (accountId, accessKeyId, secretAccessKey) => {
  return new S3Client({
    region: "auto",
    endpoint: `https://${accountId}.r2.cloudflarestorage.com`,
    credentials: {
      accessKeyId,
      secretAccessKey
    }
  });
};
var getPresignedUrl = async (key) => {
  const bucketName = getBucketName();
  return key;
};

// src/lib/prisma.ts
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@prisma/adapter-d1/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();

// ../../node_modules/@prisma/driver-adapter-utils/dist/index.mjs
init_checked_fetch();
init_modules_watch_stub();
var import_debug5 = __toESM(require_dist(), 1);
function ok(value) {
  return {
    ok: true,
    value,
    map(fn) {
      return ok(fn(value));
    },
    flatMap(fn) {
      return fn(value);
    }
  };
}
function err(error) {
  return {
    ok: false,
    error,
    map() {
      return err(error);
    },
    flatMap() {
      return err(error);
    }
  };
}
var ColumnTypeEnum = {
  // Scalars
  Int32: 0,
  Int64: 1,
  Float: 2,
  Double: 3,
  Numeric: 4,
  Boolean: 5,
  Character: 6,
  Text: 7,
  Date: 8,
  Time: 9,
  DateTime: 10,
  Json: 11,
  Enum: 12,
  Bytes: 13,
  Set: 14,
  Uuid: 15,
  // Arrays
  Int32Array: 64,
  Int64Array: 65,
  FloatArray: 66,
  DoubleArray: 67,
  NumericArray: 68,
  BooleanArray: 69,
  CharacterArray: 70,
  TextArray: 71,
  DateArray: 72,
  TimeArray: 73,
  DateTimeArray: 74,
  JsonArray: 75,
  EnumArray: 76,
  BytesArray: 77,
  UuidArray: 78,
  // Custom
  UnknownNumber: 128
};

// ../../node_modules/@prisma/adapter-d1/dist/index.mjs
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
var $ = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY)
};
function init(x2, y2) {
  let rgx = new RegExp(`\\x1b\\[${y2}m`, "g");
  let open = `\x1B[${x2}m`, close = `\x1B[${y2}m`;
  return function(txt) {
    if (!$.enabled || txt == null)
      return txt;
    return open + (!!~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
  };
}
var reset = init(0, 0);
var bold = init(1, 22);
var dim = init(2, 22);
var italic = init(3, 23);
var underline = init(4, 24);
var inverse = init(7, 27);
var hidden = init(8, 28);
var strikethrough = init(9, 29);
var black = init(30, 39);
var red = init(31, 39);
var green = init(32, 39);
var yellow = init(33, 39);
var blue = init(34, 39);
var magenta = init(35, 39);
var cyan = init(36, 39);
var white = init(37, 39);
var gray = init(90, 39);
var grey = init(90, 39);
var bgBlack = init(40, 49);
var bgRed = init(41, 49);
var bgGreen = init(42, 49);
var bgYellow = init(43, 49);
var bgBlue = init(44, 49);
var bgMagenta = init(45, 49);
var bgCyan = init(46, 49);
var bgWhite = init(47, 49);
var name = "@prisma/adapter-d1";
function getColumnTypes(columnNames, rows) {
  const columnTypes = [];
  columnLoop:
    for (let columnIndex = 0; columnIndex < columnNames.length; columnIndex++) {
      for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
        const candidateValue = rows[rowIndex][columnIndex];
        if (candidateValue !== null) {
          columnTypes[columnIndex] = inferColumnType(candidateValue);
          continue columnLoop;
        }
      }
      columnTypes[columnIndex] = ColumnTypeEnum.Int32;
    }
  return columnTypes;
}
function inferColumnType(value) {
  switch (typeof value) {
    case "string":
      return inferStringType(value);
    case "number":
      return inferNumberType(value);
    case "object":
      return inferObjectType(value);
    default:
      throw new UnexpectedTypeError(value);
  }
}
var isoDateRegex = new RegExp(
  /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/
);
var sqliteDateRegex = /^\d{4}-[0-1]\d-[0-3]\d [0-2]\d:[0-5]\d:[0-5]\d$/;
function isISODate(str) {
  return isoDateRegex.test(str) || sqliteDateRegex.test(str);
}
function inferStringType(value) {
  if (isISODate(value)) {
    return ColumnTypeEnum.DateTime;
  }
  return ColumnTypeEnum.Text;
}
function inferNumberType(_) {
  return ColumnTypeEnum.Double;
}
function inferObjectType(value) {
  if (value instanceof Array) {
    return ColumnTypeEnum.Bytes;
  }
  throw new UnexpectedTypeError(value);
}
var UnexpectedTypeError = class extends Error {
  constructor(value) {
    const type = typeof value;
    const repr = type === "object" ? JSON.stringify(value) : String(value);
    super(`unexpected value of type ${type}: ${repr}`);
    this.name = "UnexpectedTypeError";
  }
};
function mapRow(result, columnTypes) {
  for (let i2 = 0; i2 < result.length; i2++) {
    const value = result[i2];
    if (value instanceof ArrayBuffer) {
      result[i2] = Array.from(new Uint8Array(value));
      continue;
    }
    if (typeof value === "number" && (columnTypes[i2] === ColumnTypeEnum.Int32 || columnTypes[i2] === ColumnTypeEnum.Int64) && !Number.isInteger(value)) {
      result[i2] = Math.trunc(value);
      continue;
    }
    if (typeof value === "bigint") {
      result[i2] = value.toString();
      continue;
    }
    if (columnTypes[i2] === ColumnTypeEnum.Boolean) {
      result[i2] = JSON.parse(value);
    }
  }
  return result;
}
function cleanArg(arg) {
  if (arg === true) {
    return 1;
  }
  if (arg === false) {
    return 0;
  }
  if (arg instanceof Uint8Array) {
    return Array.from(arg);
  }
  if (typeof arg === "bigint") {
    return String(arg);
  }
  return arg;
}
function matchSQLiteErrorCode(message) {
  let extendedCode = 1;
  if (!message)
    return extendedCode;
  if (message.startsWith("D1_ERROR: UNIQUE constraint failed:")) {
    extendedCode = 2067;
  } else if (message.startsWith("D1_ERROR: FOREIGN KEY constraint failed")) {
    extendedCode = 787;
  } else if (message.startsWith("D1_ERROR: NOT NULL constraint failed")) {
    extendedCode = 1299;
  } else if (message.startsWith("D1_ERROR: CHECK constraint failed")) {
    extendedCode = 1811;
  } else if (message.startsWith("D1_ERROR: PRIMARY KEY constraint failed")) {
    extendedCode = 1555;
  }
  return extendedCode;
}
var debug = (0, import_debug5.Debug)("prisma:driver-adapter:d1");
var D1Queryable = class {
  constructor(client) {
    this.client = client;
    this.provider = "sqlite";
    this.adapterName = name;
  }
  /**
   * Execute a query given as SQL, interpolating the given parameters.
   */
  async queryRaw(query) {
    const tag = "[js::query_raw]";
    debug(`${tag} %O`, query);
    const ioResult = await this.performIO(query);
    return ioResult.map((data) => {
      const convertedData = this.convertData(data);
      return convertedData;
    });
  }
  convertData(ioResult) {
    const columnNames = ioResult[0];
    const results = ioResult[1];
    if (results.length === 0) {
      return {
        columnNames: [],
        columnTypes: [],
        rows: []
      };
    }
    const columnTypes = Object.values(getColumnTypes(columnNames, results));
    const rows = results.map((value) => mapRow(value, columnTypes));
    return {
      columnNames,
      // * Note: without Object.values the array looks like
      // * columnTypes: [ id: 128 ],
      // * and errors with:
      // * ✘ [ERROR] A hanging Promise was canceled. This happens when the worker runtime is waiting for a Promise from JavaScript to resolve, but has detected that the Promise cannot possibly ever resolve because all code and events related to the Promise's I/O context have already finished.
      columnTypes,
      rows
    };
  }
  /**
   * Execute a query given as SQL, interpolating the given parameters and
   * returning the number of affected rows.
   * Note: Queryable expects a u64, but napi.rs only supports u32.
   */
  async executeRaw(query) {
    const tag = "[js::execute_raw]";
    debug(`${tag} %O`, query);
    const res = await this.performIO(query, true);
    return res.map((result) => result.meta.changes ?? 0);
  }
  async performIO(query, executeRaw = false) {
    try {
      query.args = query.args.map((arg) => cleanArg(arg));
      const stmt = this.client.prepare(query.sql).bind(...query.args);
      if (executeRaw) {
        return ok(await stmt.run());
      } else {
        const [columnNames, ...rows] = await stmt.raw({ columnNames: true });
        return ok([columnNames, rows]);
      }
    } catch (e2) {
      console.error("Error in performIO: %O", e2);
      const { message } = e2;
      return err({
        kind: "Sqlite",
        extendedCode: matchSQLiteErrorCode(message),
        message
      });
    }
  }
};
var D1Transaction = class extends D1Queryable {
  constructor(client, options) {
    super(client);
    this.options = options;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async commit() {
    debug(`[js::commit]`);
    return ok(void 0);
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async rollback() {
    debug(`[js::rollback]`);
    return ok(void 0);
  }
};
var PrismaD1 = class extends D1Queryable {
  constructor(client) {
    super(client);
    this.tags = {
      error: red("prisma:error"),
      warn: yellow("prisma:warn"),
      info: cyan("prisma:info"),
      query: blue("prisma:query")
    };
    this.alreadyWarned = /* @__PURE__ */ new Set();
    this.warnOnce = (key, message, ...args) => {
      if (!this.alreadyWarned.has(key)) {
        this.alreadyWarned.add(key);
        console.info(`${this.tags.warn} ${message}`, ...args);
      }
    };
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async startTransaction() {
    const options = {
      // TODO: D1 does not have a Transaction API.
      usePhantomQuery: true
    };
    const tag = "[js::startTransaction]";
    debug(`${tag} options: %O`, options);
    this.warnOnce(
      "D1 Transaction",
      "Cloudflare D1 does not support transactions yet. When using Prisma's D1 adapter, implicit & explicit transactions will be ignored and run as individual queries, which breaks the guarantees of the ACID properties of transactions. For more details see https://pris.ly/d/d1-transactions"
    );
    return ok(new D1Transaction(this.client, options));
  }
};

// src/lib/prisma.ts
var import_client = __toESM(require_default2());
var generatePrismaClient = (DB) => {
  const adapter = new PrismaD1(DB);
  return new import_client.PrismaClient({
    adapter
  });
};

// src/routes/index.ts
init_checked_fetch();
init_modules_watch_stub();

// src/routes/application-master/index.ts
init_checked_fetch();
init_modules_watch_stub();

// src/controllers/applicationMaster.controller.ts
init_checked_fetch();
init_modules_watch_stub();

// src/services/applicationMaster.sercvice.ts
init_checked_fetch();
init_modules_watch_stub();

// src/repos/applicationMaster.repo.ts
init_checked_fetch();
init_modules_watch_stub();

// src/repos/base/base.repo.ts
init_checked_fetch();
init_modules_watch_stub();
var BaseRepo = class {
  tableModel;
  constructor(tableModel) {
    this.tableModel = tableModel;
  }
  getAll = async () => {
    return await this.tableModel.findMany();
  };
  getAllActive = async () => {
    return await this.tableModel.findMany({
      where: {
        isDeleted: false
      }
    });
  };
  getAllAndChild = async (child2, select = {}) => {
    return await this.tableModel.findMany({
      include: {
        [child2]: true
      }
    });
  };
  getOneByIdAndChildren = async (id, child2) => {
    const res = await this.tableModel.findUnique({
      where: {
        id
      },
      include: {
        [child2]: true
      }
    });
    return res;
  };
  getOneById = async (id) => {
    const res = await this.tableModel.findUnique({
      where: {
        id
      }
    });
    return res;
  };
  getActiveRecordById = async (id) => {
    const res = await this.tableModel.findUnique({
      where: {
        id,
        isDeleted: false
      }
    });
    return res;
  };
  getOneByCondition = async (condition, select = {}) => {
    return await this.tableModel.findFirst({
      where: condition
    });
  };
  getManyByIds = async (ids) => {
    return await this.tableModel.findMany({
      where: {
        id: {
          in: ids
        }
      }
    });
  };
  getManyActiveRecordByIds = async (ids) => {
    return await this.tableModel.findMany({
      where: {
        id: {
          in: ids
        },
        isDeleted: false
      }
    });
  };
  getManyAndChildrenByIds = async (ids, child2) => {
    return await this.tableModel.findMany({
      where: {
        id: {
          in: ids
        }
      },
      include: {
        [child2]: true
      }
    });
  };
  getUpdated = async (lastSyncDate, include = {}) => {
    return await this.tableModel.findMany({
      where: {
        updatedAt: {
          gt: lastSyncDate
        }
      },
      include
    });
  };
};

// src/repos/applicationMaster.repo.ts
var getAll = async () => {
  const prisma = getDb();
  return await new BaseRepo(prisma.aplicationMaster).getAllActive();
};
var getOneById = async (id) => {
  const prisma = getDb();
  return await new BaseRepo(prisma.aplicationMaster).getActiveRecordById(id);
};
var getManyByIds = async (ids) => {
  const prisma = getDb();
  return await new BaseRepo(prisma.aplicationMaster).getManyActiveRecordByIds(ids);
};
var getUpdateData = async (lastSyncDate, bundleId) => {
  const prisma = getDb();
  return await prisma.aplicationMaster.findFirst({
    where: {
      updatedAt: {
        gt: lastSyncDate
      },
      packageName: bundleId,
      isDeleted: false
    }
  });
};
var getOneByBundleId = async (bundleId) => {
  const prisma = getDb();
  return await new BaseRepo(prisma.aplicationMaster).getOneByCondition({
    packageName: bundleId,
    isDeleted: false
  });
};

// src/services/applicationMaster.sercvice.ts
var ApplicationMasterFactory = class {
  static async getAll() {
    const applicationMasters = await getAll();
    if (!applicationMasters?.length) {
      throw new NotFoundError2("Application not found");
    }
    return await this.convertArrayData(applicationMasters);
  }
  static async getOneById(id) {
    const applicationMaster = await getOneById(id);
    return await new ApplicationMaster().convertData(applicationMaster);
  }
  static async getOneByBundleId() {
    const bundleId = getBundleId();
    if (!bundleId) {
      throw new NotFoundError2("bundleId not found");
    }
    const application = await getOneByBundleId(bundleId);
    if (!application) {
      return {};
    }
    return await new ApplicationMaster().convertData(application);
  }
  static async getManyByIds(ids) {
    const applicationMasters = await getManyByIds(ids);
    if (!applicationMasters?.length) {
      throw new NotFoundError2("Application not found");
    }
    return await this.convertArrayData(applicationMasters);
  }
  static async getUpdateData(lastSyncDate) {
    const bundleId = getBundleId();
    if (!bundleId) {
      throw new NotFoundError2("bundleId not found");
    }
    const app10 = await getUpdateData(lastSyncDate, bundleId);
    if (!app10) {
      return {};
    }
    return await new ApplicationMaster().convertData(app10);
  }
  static async convertArrayData(apps) {
    let result = [];
    for (const app10 of apps) {
      result.push(await new ApplicationMaster().convertData(app10));
    }
    return result;
  }
};
var ApplicationMaster = class {
  async convertData({
    id,
    appName,
    assetBundleIOS,
    assetBundleAndroid,
    outlineUrl
  }) {
    return {
      appId: id,
      appName,
      assetBundleIOS: await getPresignedUrl(assetBundleIOS),
      assetBundleAndroid: await getPresignedUrl(assetBundleAndroid),
      outlineUrl: await getPresignedUrl(outlineUrl)
    };
  }
};
var applicationMaster_sercvice_default = ApplicationMasterFactory;

// src/core/success.response.ts
init_checked_fetch();
init_modules_watch_stub();
init_httpStatusCode();
var SuccessResponse = class {
  message;
  status;
  reason;
  metadata;
  count;
  constructor({ message, status, reason, metadata: metadata7, count }) {
    this.message = message ?? reason;
    this.status = status ?? statusCodes_default.OK;
    this.reason = reason ?? reasonPhrases_default.OK;
    this.metadata = metadata7 || {};
    this.count = count;
  }
};
var OK2 = class extends SuccessResponse {
  constructor({ message, metadata: metadata7, count }) {
    super({
      message,
      status: statusCodes_default.OK,
      reason: reasonPhrases_default.OK,
      metadata: metadata7,
      count
    });
  }
};

// src/controllers/applicationMaster.controller.ts
var AplicationMasterController = class {
  getAll = async () => {
    return new OK2({
      message: "get all AplicationMasters success!",
      metadata: await applicationMaster_sercvice_default.getAll()
    });
  };
  getOneById = async (id) => {
    return new OK2({
      message: "get AplicationMaster by id success!",
      metadata: await applicationMaster_sercvice_default.getOneById(id)
    });
  };
  getManyByIds = async (ids) => {
    return new OK2({
      message: "get many AplicationMaster success!",
      metadata: await applicationMaster_sercvice_default.getManyByIds(ids)
    });
  };
  getByBundleId = async () => {
    return new OK2({
      message: "get AplicationMaster by bundleId success!",
      metadata: await applicationMaster_sercvice_default.getOneByBundleId()
    });
  };
};
var applicationMasterController = new AplicationMasterController();
var applicationMaster_controller_default = applicationMasterController;

// src/openapi/application-master/index.ts
init_checked_fetch();
init_modules_watch_stub();
var ParamsSchema = z.object({
  id: z.string().openapi({
    param: {
      name: "id",
      in: "path"
    },
    type: "integer",
    example: "1"
  })
});
var QueySchema = z.object({
  ids: z.string().openapi({
    param: {
      name: "ids",
      in: "query"
    },
    type: "string",
    example: "1,2,3",
    description: "comma separated list of ids"
  })
});
var metadata = z.object({
  appId: z.number().openapi({ example: 1 }),
  appName: z.string().openapi({ example: "appName" }),
  assetBundleIOS: z.string().openapi({ example: "application-master/1716160641744/assetBundles" }),
  assetBundleAndroid: z.string().openapi({ example: "application-master/1716160642046/assetBundles" }),
  outlineUrl: z.string().openapi({
    example: "application-master/1716160642682/image.png"
  })
});
var ResponseSchemaObject = z.object({
  message: z.string().openapi({ example: "get AplicationMaster  success!" }),
  status: z.number().openapi({ example: 200 }),
  reason: z.string().openapi({ example: "OK" }),
  metadata
});
var ResponseSchemaArray = z.object({
  message: z.string().openapi({ example: "get AplicationMaster  success!" }),
  status: z.number().openapi({ example: 200 }),
  reason: z.string().openapi({ example: "OK" }),
  metadata: z.array(metadata)
});

// ../../packages/utils/validateRequest.ts
init_checked_fetch();
init_modules_watch_stub();
var validateIds = (ids) => {
  if (!ids) {
    throw new BadRequestError("Invalid ids");
  }
  const regex = /^(\d+,)*\d+$/;
  if (!regex.test(ids)) {
    throw new BadRequestError("Invalid ids format. Expected format: 1,2,3,...");
  }
};
var validateId = (id) => {
  if (!id || isNaN(parseInt(id, 10))) {
    throw new BadRequestError("Invalid id");
  }
};
var validateDate = (date) => {
  if (!date || isNaN(new Date(date).getTime())) {
    throw new BadRequestError("Invalid date");
  }
};

// src/openapi/index.ts
init_checked_fetch();
init_modules_watch_stub();
var QuerySchemaBundleId = z.object({
  bundleId: z.string().openapi({
    param: {
      name: "bundleId",
      in: "query"
    },
    type: "string",
    example: "abc.com",
    description: "bundleId or package name of the application"
  })
});
var Authorization = z.object({
  // Header keys must be in lowercase, `Authorization` is not allowed.
  authorization: z.string().openapi({
    description: "Basic Authorization header. Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization",
    example: "Basic <Base64 encoded username and password>"
  })
});
var securitySchemes = [
  {
    BasicAuth: []
  }
];

// src/routes/application-master/index.ts
var app = new OpenAPIHono();
app.openapi(
  createRoute({
    method: "get",
    path: "/",
    description: "Get application masters by bundleId",
    security: securitySchemes,
    request: {
      query: QuerySchemaBundleId,
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchemaObject
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["Application Master"]
  }),
  async (c2) => {
    return c2.json(await applicationMaster_controller_default.getByBundleId());
  }
);
app.openapi(
  createRoute({
    method: "get",
    path: "/many",
    description: "Get many application masters by ids",
    security: securitySchemes,
    request: {
      query: QueySchema,
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchemaArray
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["Application Master"]
  }),
  async (c2) => {
    const ids = c2.req.query("ids");
    validateIds(ids);
    const numIds = ids?.split(",").map((id) => parseInt(id, 10));
    return c2.json(
      await applicationMaster_controller_default.getManyByIds(numIds)
    );
  }
);
app.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    description: "Get one application master by id",
    security: securitySchemes,
    request: {
      params: ParamsSchema,
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchemaObject
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["Application Master"]
  }),
  async (c2) => {
    const id = c2.req.param("id");
    validateId(id);
    const numId = parseInt(id, 10);
    return c2.json(await applicationMaster_controller_default.getOneById(numId));
  }
);
var application_master_default = app;

// src/routes/acsta/index.ts
init_checked_fetch();
init_modules_watch_stub();

// src/controllers/acsta.controller.ts
init_checked_fetch();
init_modules_watch_stub();

// src/services/acsta.service.ts
init_checked_fetch();
init_modules_watch_stub();

// src/repos/acsta.repo.ts
init_checked_fetch();
init_modules_watch_stub();
var child = "performace";
var getAll2 = async () => {
  const prisma = getDb();
  return await new BaseRepo(prisma.acstaManagement).getAllAndChild(
    "performace"
  );
};
var getAllByAppId = async (applicationId) => {
  const prisma = getDb();
  return await prisma.acstaManagement.findMany({
    include: {
      [child]: true
    },
    where: {
      applicationId,
      isDeleted: false
    }
  });
};
var getOneById2 = async (id, applicationId) => {
  const prisma = getDb();
  return await prisma.acstaManagement.findFirst({
    where: {
      id,
      applicationId,
      isDeleted: false
    },
    include: {
      [child]: true
    }
  });
};
var getManyByAppId = async (applicationId) => {
  const prisma = getDb();
  return await prisma.acstaManagement.findMany({
    where: {
      applicationId,
      isDeleted: false
    }
  });
};
var getManyByIds2 = async (ids, applicationId) => {
  const prisma = getDb();
  return await prisma.acstaManagement.findMany({
    where: {
      id: {
        in: ids
      },
      applicationId,
      isDeleted: false
    }
  });
};
var getManyByIdsAndChildren = async (ids, applicationId) => {
  const prisma = getDb();
  return await prisma.acstaManagement.findMany({
    where: {
      id: {
        in: ids
      },
      applicationId,
      isDeleted: false
    },
    include: {
      [child]: true
    }
  });
};
var getUpdateData2 = async (lastSyncDate, applicationId) => {
  const prisma = getDb();
  return await prisma.acstaManagement.findMany({
    where: {
      updatedAt: {
        gt: lastSyncDate
      },
      applicationId,
      isDeleted: false
    },
    include: {
      performace: true
    }
  });
};

// src/helpers/getRecordId.ts
init_checked_fetch();
init_modules_watch_stub();
var getApplicationId = async () => {
  const bundleId = getBundleId();
  if (!bundleId) {
    throw new BadRequestError("bundleId not found");
  }
  const application = await getOneByBundleId(bundleId);
  if (!application) {
    throw new NotFoundError2("Application not found");
  }
  return application.id;
};
var getAcstaIdByBundleId = async () => {
  const applicationId = await getApplicationId();
  let acsta = await getManyByAppId(applicationId);
  if (!acsta)
    return null;
  let arrayAcstaId = acsta.map((value) => value.id);
  return arrayAcstaId;
};

// src/services/acsta.service.ts
var AcstaFactory = class {
  static async getAll() {
    const acstas = await getAll2();
    if (!acstas?.length) {
      throw new NotFoundError2("No Acsta found");
    }
    return await this.convertArrayData(acstas);
  }
  static async getAllByBundleId() {
    const applicationId = await getApplicationId();
    const acstas = await getAllByAppId(applicationId);
    if (!acstas?.length) {
      return [];
    }
    return await this.convertArrayData(acstas);
  }
  static async getOneById(id) {
    const applicationId = await getApplicationId();
    const result = await getOneById2(id, applicationId);
    if (!result) {
      throw new NotFoundError2("No Acsta found");
    }
    return result;
  }
  static async getManyByIds(ids) {
    const applicationId = await getApplicationId();
    const acstas = await getManyByIds2(ids, applicationId);
    if (!acstas?.length) {
      throw new NotFoundError2("No Acsta found");
    }
    return await this.convertArrayData(acstas);
  }
  static async getManyByIdsAndChildren(ids) {
    const applicationId = await getApplicationId();
    const acstas = await getManyByIdsAndChildren(ids, applicationId);
    if (!acstas?.length) {
      throw new NotFoundError2("No Acsta found");
    }
    return await this.convertArrayData(acstas);
  }
  static async getUpdateData(lastSyncDate) {
    const applicationId = await getApplicationId();
    const acstas = await getUpdateData2(lastSyncDate, applicationId);
    if (!acstas?.length) {
      return [];
    }
    return await this.convertArrayData(acstas);
  }
  static async convertArrayData(apps) {
    let result = [];
    for (const app10 of apps) {
      result.push(await new Acsta().getData(app10));
    }
    return result;
  }
};
var Acsta = class {
  async getData({
    id,
    acstaName,
    applicationId,
    thumbnailUrl,
    scanImageUrl,
    scanOriginX,
    scanOriginY,
    scanWidth,
    scanHeight,
    scanColors,
    performace
  }) {
    return {
      acstaId: id,
      appId: applicationId,
      acstaName,
      thumbnailUrl: await getPresignedUrl(thumbnailUrl),
      scanImageUrl: await getPresignedUrl(scanImageUrl),
      scanOriginX,
      scanOriginY,
      scanWidth,
      scanHeight,
      scanColors: JSON.parse(scanColors),
      modeId: performace ? performace.map((p2) => p2.id) : []
    };
  }
};
var acsta_service_default = AcstaFactory;

// src/controllers/acsta.controller.ts
var AcstaController = class {
  getAll = async () => {
    return new OK2({
      message: "get all Acsta success!",
      metadata: await acsta_service_default.getAll()
    });
  };
  getOneById = async (id) => {
    return new OK2({
      message: "get Acsta success!",
      metadata: await acsta_service_default.getOneById(id)
    });
  };
  getManyByIds = async (ids) => {
    return new OK2({
      message: "get many Acsta success!",
      metadata: await acsta_service_default.getManyByIds(ids)
    });
  };
  getManyByIdsAndChildren = async (ids) => {
    return new OK2({
      message: "get many Acsta success!",
      metadata: await acsta_service_default.getManyByIdsAndChildren(ids)
    });
  };
  getAllByBundleId = async () => {
    return new OK2({
      message: "get many Acsta by bundleId success!",
      metadata: await acsta_service_default.getAllByBundleId()
    });
  };
};
var acstaController = new AcstaController();
var acsta_controller_default = acstaController;

// src/openapi/acsta/index.ts
init_checked_fetch();
init_modules_watch_stub();
var ParamsSchema2 = z.object({
  id: z.string().openapi({
    param: {
      name: "id",
      in: "path"
    },
    type: "integer",
    example: "1"
  })
});
var QueySchema2 = z.object({
  ids: z.string().openapi({
    param: {
      name: "ids",
      in: "query"
    },
    type: "string",
    example: "1,2,3",
    description: "comma separated list of ids"
  })
});
var metadata2 = z.object({
  acstaId: z.number().openapi({ example: 1 }),
  appId: z.number().openapi({ example: 1 }),
  acstaName: z.string().openapi({ example: "name1" }),
  thumbnailUrl: z.string().openapi({
    example: "acsta/1716161518729/Screen Shot 2022-11-04 at 10.13.27 (2) (1).png"
  }),
  scanImageUrl: z.string().openapi({
    example: "acsta/1716161518784/Screen Shot 2022-11-04 at 10.13.27 (2).png"
  }),
  scanOriginX: z.number().openapi({ example: 0.26 }),
  scanOriginY: z.number().openapi({ example: 0.26 }),
  scanWidth: z.number().openapi({ example: 0.26 }),
  scanHeight: z.number().openapi({ example: 0.26 }),
  scanColors: z.array(z.number()).openapi({
    example: [
      0.967,
      0,
      0,
      0,
      0,
      1e-3,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0.012,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0.019
    ]
  }),
  modeId: z.array(z.number()).openapi({ example: [1] })
});
var ResponseSchemaObject2 = z.object({
  message: z.string().openapi({ example: "get Acsta success!" }),
  status: z.number().openapi({ example: 200 }),
  reason: z.string().openapi({ example: "OK" }),
  metadata: metadata2
});
var ResponseSchemaArray2 = z.object({
  message: z.string().openapi({ example: "get Acsta success!" }),
  status: z.number().openapi({ example: 200 }),
  reason: z.string().openapi({ example: "OK" }),
  metadata: z.array(metadata2)
});

// src/routes/acsta/index.ts
var app2 = new OpenAPIHono();
app2.openAPIRegistry.registerComponent("securitySchemes", "Bearer", {
  type: "http",
  scheme: "bearer"
});
app2.openapi(
  createRoute({
    method: "get",
    path: "/",
    description: "Get all Acsta  by bundleId",
    security: securitySchemes,
    request: {
      query: QuerySchemaBundleId,
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchemaArray2
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["Acsta"]
  }),
  async (c2) => {
    return c2.json(await acsta_controller_default.getAllByBundleId());
  }
);
app2.openapi(
  createRoute({
    method: "get",
    path: "/many",
    description: "Get many Acsta  by ids",
    security: securitySchemes,
    request: {
      query: QueySchema2,
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchemaArray2
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["Acsta"]
  }),
  async (c2) => {
    const ids = c2.req.query("ids");
    validateIds(ids);
    const numIds = ids?.split(",").map((id) => parseInt(id, 10));
    return c2.json(
      await acsta_controller_default.getManyByIdsAndChildren(numIds)
    );
  }
);
app2.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    description: "Get one Acsta by id",
    security: securitySchemes,
    request: {
      params: ParamsSchema2,
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchemaObject2
          }
        },
        description: "Ok Response"
      }
    },
    headers: Authorization,
    tags: ["Acsta"]
  }),
  async (c2) => {
    const id = c2.req.param("id");
    validateId(id);
    const numId = parseInt(id, 10);
    return c2.json(await acsta_controller_default.getOneById(numId));
  }
);
var acsta_default = app2;

// src/routes/product/index.ts
init_checked_fetch();
init_modules_watch_stub();

// src/controllers/performance.controller.ts
init_checked_fetch();
init_modules_watch_stub();

// src/services/performance.service.ts
init_checked_fetch();
init_modules_watch_stub();

// src/repos/performance.repo.ts
init_checked_fetch();
init_modules_watch_stub();
var getAll3 = async () => {
  const prisma = getDb();
  return await new BaseRepo(prisma.performaceManagement).getAllActive();
};
var getAllByAcstaId = async (acstaId) => {
  const prisma = getDb();
  return await prisma.performaceManagement.findMany({
    where: {
      acstaId,
      isDeleted: false
    }
  });
};
var getOneById3 = async (id) => {
  const prisma = getDb();
  return await new BaseRepo(prisma.performaceManagement).getActiveRecordById(
    id
  );
};
var getManyByIds3 = async (ids) => {
  const prisma = getDb();
  return await new BaseRepo(
    prisma.performaceManagement
  ).getManyActiveRecordByIds(ids);
};
var getUpdateData3 = async (lastSyncDate, acstaId) => {
  const prisma = getDb();
  return await prisma.performaceManagement.findMany({
    where: {
      updatedAt: {
        gt: lastSyncDate
      },
      acstaId: {
        in: acstaId
      },
      isDeleted: false
    }
  });
};

// src/services/performance.service.ts
var PerformanceFactory = class {
  static async getOneById(id) {
    const res = await getOneById3(id);
    if (!res)
      throw new NotFoundError2("Product not found");
    return await new Performance().getData(res);
  }
  static async getAllByBundleId() {
    const acstaId = await getAcstaIdByBundleId();
    if (!acstaId)
      return [];
    let performances = [];
    const validAcstaIds = acstaId.filter((id) => id !== void 0);
    for (const id of validAcstaIds) {
      const performance = await getAllByAcstaId(id);
      performances = [...performances, ...performance];
    }
    if (!performances?.length)
      return [];
    return await this.convertArrayData(performances);
  }
  static async getAll() {
    const performances = await getAll3();
    if (!performances?.length)
      throw new NotFoundError2("Product not found");
    return await this.convertArrayData(performances);
  }
  static async getManyByIds(ids) {
    const performances = await getManyByIds3(ids);
    if (!performances?.length)
      throw new NotFoundError2("Product not found");
    return await this.convertArrayData(performances);
  }
  static async getUpdateData(lastSyncDate) {
    const acstaId = await getAcstaIdByBundleId();
    if (!acstaId)
      return [];
    const performances = await getUpdateData3(lastSyncDate, acstaId);
    if (!performances?.length)
      return [];
    return await this.convertArrayData(performances);
  }
  static async convertArrayData(apps) {
    let result = [];
    for (const app10 of apps) {
      result.push(await new Performance().getData(app10));
    }
    return result;
  }
};
var Performance = class {
  async getData({
    id,
    performanceTypeMasterId,
    assetBundleIOS,
    acstaId,
    assetBundleAndroid
  }) {
    return {
      modeId: id,
      modeTypeId: performanceTypeMasterId,
      acstaId,
      assetBundleIOS: await getPresignedUrl(assetBundleIOS),
      assetBundleAndroid: await getPresignedUrl(assetBundleAndroid)
    };
  }
};
var performance_service_default = PerformanceFactory;

// src/controllers/performance.controller.ts
var PerformanceController = class {
  getAll = async () => {
    return new OK2({
      message: "get all Product success!",
      metadata: await performance_service_default.getAll()
    });
  };
  getOneById = async (id) => {
    return new OK2({
      message: "get Product success!",
      metadata: await performance_service_default.getOneById(id)
    });
  };
  getManyByIds = async (ids) => {
    return new OK2({
      message: "get many Product success!",
      metadata: await performance_service_default.getManyByIds(ids)
    });
  };
  getAllByBundleId = async () => {
    return new OK2({
      message: "get many Acsta by bundleId success!",
      metadata: await performance_service_default.getAllByBundleId()
    });
  };
};
var performanceController = new PerformanceController();
var performance_controller_default = performanceController;

// src/openapi/product/index.ts
init_checked_fetch();
init_modules_watch_stub();
var ParamsSchema3 = z.object({
  id: z.string().openapi({
    param: {
      name: "id",
      in: "path"
    },
    type: "integer",
    example: "1"
  })
});
var QueySchema3 = z.object({
  ids: z.string().openapi({
    param: {
      name: "ids",
      in: "query"
    },
    type: "string",
    example: "1,2,3",
    description: "comma separated list of ids"
  })
});
var metadata3 = z.object({
  modeId: z.number().openapi({ example: 1 }),
  modeTypeId: z.number().openapi({ example: 1 }),
  assetBundleIOS: z.string().openapi({ example: "application-master/1716161586611/assetBundles" }),
  acstaId: z.number().openapi({ example: 1 }),
  assetBundleAndroid: z.string().openapi({ example: "application-master/1716161587314/assetBundles" })
});
var ResponseSchemaObject3 = z.object({
  message: z.string().openapi({ example: "get Product  success!" }),
  status: z.number().openapi({ example: 200 }),
  reason: z.string().openapi({ example: "OK" }),
  metadata: metadata3
});
var ResponseSchemaArray3 = z.object({
  message: z.string().openapi({ example: "get Product  success!" }),
  status: z.number().openapi({ example: 200 }),
  reason: z.string().openapi({ example: "OK" }),
  metadata: z.array(metadata3)
});

// src/routes/product/index.ts
var app3 = new OpenAPIHono();
app3.openapi(
  createRoute({
    method: "get",
    path: "/",
    description: "Get all Products by bundleId",
    security: securitySchemes,
    request: {
      query: QuerySchemaBundleId,
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchemaArray3
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["Product"]
  }),
  async (c2) => {
    return c2.json(await performance_controller_default.getAll());
  }
);
app3.openapi(
  createRoute({
    method: "get",
    path: "/many",
    description: "Get many Product by ids",
    security: securitySchemes,
    request: {
      query: QueySchema3,
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchemaArray3
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["Product"]
  }),
  async (c2) => {
    const ids = c2.req.query("ids");
    validateIds2(ids);
    const numIds = ids?.split(",").map((id) => parseInt(id, 10));
    return c2.json(await performance_controller_default.getManyByIds(numIds));
  }
);
app3.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    description: "Get one product by id",
    security: securitySchemes,
    request: {
      params: ParamsSchema3
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchemaObject3
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["Product"]
  }),
  async (c2) => {
    const id = c2.req.param("id");
    const numId = parseInt(id, 10);
    return c2.json(await performance_controller_default.getOneById(numId));
  }
);
var product_default = app3;
function validateIds2(ids) {
  throw new Error("Function not implemented.");
}

// src/routes/license/index.ts
init_checked_fetch();
init_modules_watch_stub();

// src/controllers/license.controller.ts
init_checked_fetch();
init_modules_watch_stub();

// src/services/license.service.ts
init_checked_fetch();
init_modules_watch_stub();

// src/repos/license.repo.ts
init_checked_fetch();
init_modules_watch_stub();
var getAll4 = async () => {
  const prisma = getDb();
  return await new BaseRepo(prisma.license).getAll();
};
var getCurrentLicense = async (licenseId) => {
  const prisma = getDb();
  const currentLicense = await prisma.license.findFirst({
    where: {
      id: licenseId
    }
  });
  return currentLicense;
};
var getOneById4 = async (id) => {
  const prisma = getDb();
  return await new BaseRepo(prisma.license).getOneById(id);
};

// src/services/license.service.ts
var LicenseService = class {
  static async getAll() {
    const licenses = await getAll4();
    if (!licenses?.length) {
      throw new NotFoundError2("License not found");
    }
    return licenses;
  }
  static async getCurrentLicense() {
    const bundleId = getBundleId();
    if (!bundleId) {
      throw new NotFoundError2("bundleId not found");
    }
    const application = await getOneByBundleId(bundleId);
    if (!application) {
      throw new NotFoundError2("Application not found");
    }
    const currentLicense = await getCurrentLicense(application.licenseId);
    if (!currentLicense) {
      throw new NotFoundError2("License not found");
    }
    const contentUrl = await getPresignedUrl(currentLicense?.content);
    return { contentUrl };
  }
  static async getOneById(id) {
    const license = await getOneById4(id);
    if (!license) {
      throw new NotFoundError2("License not found");
    }
    const contentUrl = await getPresignedUrl(license?.content);
    return { contentUrl };
  }
};
var license_service_default = LicenseService;

// src/controllers/license.controller.ts
var LicenseController = class {
  getAll = async () => {
    return new OK2({
      message: "get all License success!",
      metadata: await license_service_default.getAll()
    });
  };
  getCurrentLicense = async () => {
    return new OK2({
      message: "get latest License success!",
      metadata: await license_service_default.getCurrentLicense()
    });
  };
  getOneById = async (id) => {
    return new OK2({
      message: "get License by id success!",
      metadata: await license_service_default.getOneById(id)
    });
  };
};
var licenseController = new LicenseController();
var license_controller_default = licenseController;

// src/openapi/license/index.ts
init_checked_fetch();
init_modules_watch_stub();
var ParamsSchema4 = z.object({
  id: z.string().openapi({
    param: {
      name: "id",
      in: "path"
    },
    type: "integer",
    example: "1"
  })
});
var metadata4 = z.object({
  contentUrl: z.string().openapi({
    example: "license/1716091800044/demo.html"
  })
});
var ResponseSchema = z.object({
  message: z.string().openapi({ example: "get License success!" }),
  status: z.number().openapi({ example: 200 }),
  reason: z.string().openapi({ example: "OK" }),
  metadata: metadata4
});

// src/routes/license/index.ts
var app4 = new OpenAPIHono();
app4.openapi(
  createRoute({
    method: "get",
    path: "/latest",
    description: "Get the latest License",
    security: securitySchemes,
    request: {
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchema
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["License"]
  }),
  async (c2) => {
    return c2.json(await license_controller_default.getCurrentLicense());
  }
);
app4.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    description: "Get License by id",
    security: securitySchemes,
    request: {
      params: ParamsSchema4,
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchema
          }
        },
        description: "Ok Response"
      }
    },
    // headers: Authorization,
    tags: ["License"]
  }),
  async (c2) => {
    const id = c2.req.param("id");
    validateId(id);
    const numId = parseInt(id, 10);
    return c2.json(await license_controller_default.getOneById(numId));
  }
);
var license_default = app4;

// src/routes/terms-of-use/index.ts
init_checked_fetch();
init_modules_watch_stub();

// src/controllers/termOfUse.controller.ts
init_checked_fetch();
init_modules_watch_stub();

// src/services/termOfUse.service.ts
init_checked_fetch();
init_modules_watch_stub();

// src/repos/termOfUse.repo.ts
init_checked_fetch();
init_modules_watch_stub();
var getAll5 = async () => {
  const prisma = getDb();
  return await new BaseRepo(prisma.termsOfUse).getAll();
};
var getCurrentTermOfUse = async (termsOfUseId) => {
  const prisma = getDb();
  const currentLicense = await prisma.termsOfUse.findFirst({
    where: {
      id: termsOfUseId
    }
  });
  return currentLicense;
};
var getOneById5 = async (id) => {
  const prisma = getDb();
  return await new BaseRepo(prisma.termsOfUse).getOneById(id);
};

// src/services/termOfUse.service.ts
var TermOfUseService = class {
  static async getAll() {
    const result = await getAll5();
    if (!result?.length) {
      throw new NotFoundError2("Term of use not found");
    }
    return result;
  }
  static async getCurrentTermOfUse() {
    const bundleId = getBundleId();
    if (!bundleId) {
      throw new NotFoundError2("bundleId not found");
    }
    const application = await getOneByBundleId(bundleId);
    if (!application) {
      throw new NotFoundError2("Application not found");
    }
    const currentTermsOfUse = await getCurrentTermOfUse(
      application.termsOfUseId
    );
    if (!currentTermsOfUse) {
      throw new NotFoundError2("Term of use not found");
    }
    const contentUrl = await getPresignedUrl(
      currentTermsOfUse?.content
    );
    return { contentUrl };
  }
  static async getOneById(id) {
    const termOfUse = await getOneById5(id);
    if (!termOfUse) {
      throw new NotFoundError2("Term of use not found");
    }
    const contentUrl = await getPresignedUrl(termOfUse?.content);
    return { contentUrl };
  }
};
var termOfUse_service_default = TermOfUseService;

// src/controllers/termOfUse.controller.ts
var TeamOfUseController = class {
  getAll = async () => {
    return new OK2({
      message: "get all Term Of Use success!",
      metadata: await termOfUse_service_default.getAll()
    });
  };
  getCurrentTermOfUse = async () => {
    return new OK2({
      message: "get latest Term Of Use success!",
      metadata: await termOfUse_service_default.getCurrentTermOfUse()
    });
  };
  getOneById = async (id) => {
    return new OK2({
      message: "get Term Of Use by id success!",
      metadata: await termOfUse_service_default.getOneById(id)
    });
  };
};
var termOfUseController = new TeamOfUseController();
var termOfUse_controller_default = termOfUseController;

// src/openapi/terms-of-use/index.ts
init_checked_fetch();
init_modules_watch_stub();
var ParamsSchema5 = z.object({
  id: z.string().openapi({
    param: {
      name: "id",
      in: "path"
    },
    type: "integer",
    example: "1"
  })
});
var metadata5 = z.object({
  contentUrl: z.string().openapi({
    example: "term-of-use/1716091800044/demo.html"
  })
});
var ResponseSchema2 = z.object({
  message: z.string().openapi({ example: "get Term Of Use  success!" }),
  status: z.number().openapi({ example: 200 }),
  reason: z.string().openapi({ example: "OK" }),
  metadata: metadata5
});

// src/routes/terms-of-use/index.ts
var app5 = new OpenAPIHono();
app5.openapi(
  createRoute({
    method: "get",
    path: "/latest",
    description: "Get the latest Term Of Use",
    security: securitySchemes,
    request: {
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchema2
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["Term Of Use"]
  }),
  async (c2) => {
    return c2.json(await termOfUse_controller_default.getCurrentTermOfUse());
  }
);
app5.openapi(
  createRoute({
    method: "get",
    path: "/{id}",
    description: "Get Term Of Use by id",
    security: securitySchemes,
    request: {
      params: ParamsSchema5,
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchema2
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["Term Of Use"]
  }),
  async (c2) => {
    const id = c2.req.param("id");
    if (!id) {
      throw new BadRequestError("Invalid id");
    }
    const numId = parseInt(id, 10);
    return c2.json(await termOfUse_controller_default.getOneById(numId));
  }
);
var terms_of_use_default = app5;

// src/routes/update-check/index.ts
init_checked_fetch();
init_modules_watch_stub();

// ../../packages/consts/forceUpdate.ts
init_checked_fetch();
init_modules_watch_stub();
var OS_MAP = {
  ios: "0",
  android: "1"
};

// src/openapi/check-update/index.ts
init_checked_fetch();
init_modules_watch_stub();
var updateCheckSchema = z.object({
  os: z.enum(["ios", "android"]),
  version: z.string().openapi({
    example: "1.1"
  }),
  bundleId: z.string().openapi({
    example: "com.example.app"
  })
});
var metadata6 = z.object({
  mandatoryUpdate: z.boolean().openapi({
    example: true,
    description: "Whether the update is mandatory. true is mandatory, false is not."
  }),
  version: z.string().nullable().openapi({
    example: "1.1"
  }),
  publishedDate: z.string().nullable().openapi({
    example: "2024-05-19T04:09:00.000Z"
  })
});
var updateCheckResponseSchema = z.object({
  message: z.string().openapi({
    example: "check update success!"
  }),
  metadata: metadata6
});

// src/routes/update-check/index.ts
var app6 = new OpenAPIHono();
app6.openapi(
  createRoute({
    method: "post",
    path: "/",
    description: "Check update",
    security: securitySchemes,
    request: {
      body: {
        required: true,
        content: {
          "application/json": {
            schema: updateCheckSchema
          }
        }
      },
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: updateCheckResponseSchema
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["Update Check"]
  }),
  async (c2) => {
    try {
      const result = updateCheckSchema.safeParse(await c2.req.json());
      if (!result.success) {
        throw new BadRequestError("Invalid request");
      }
      const { os, version, bundleId } = result.data;
      const osMap = OS_MAP[os];
      if (osMap == null || osMap == void 0) {
        throw new BadRequestError("Invalid OS");
      }
      if (!version) {
        throw new BadRequestError("Invalid version");
      }
      if (!bundleId) {
        throw new BadRequestError("Invalid bundleId");
      }
      const application = await getOneByBundleId(bundleId);
      if (!application) {
        throw new NotFoundError2("Application not found");
      }
      const prisma = getDb();
      const updateInfo = await prisma.forcedUpdateManagement.findFirst({
        where: {
          operateSystem: osMap.toString(),
          version: {
            gt: version
          },
          appMasterId: application.id
        },
        orderBy: {
          version: "asc"
        }
      });
      if (updateInfo) {
        return c2.json(
          new OK2({
            message: "check update success!",
            metadata: {
              mandatoryUpdate: true,
              version: updateInfo.version,
              publishedDate: updateInfo.publishedDate
            }
          })
        );
      } else {
        return c2.json(
          new OK2({
            message: "check update success!",
            metadata: {
              mandatoryUpdate: false
            }
          })
        );
      }
    } catch (error) {
      if (error instanceof BadRequestError || error instanceof NotFoundError2) {
        throw error;
      } else {
        console.error("Unexpected error occurred:", error);
        throw new InternalServerError(error.message);
      }
    }
  }
);
var update_check_default = app6;

// src/routes/get-data/index.ts
init_checked_fetch();
init_modules_watch_stub();

// src/controllers/getData.controller.ts
init_checked_fetch();
init_modules_watch_stub();
async function getUpdatedTables(lastSyncDate) {
  const prisma = getDb();
  const updatedTables = await prisma.bootUpdate.findMany({
    where: {
      updatedAt: {
        gt: lastSyncDate
      }
    }
  });
  return updatedTables.map((entry) => entry.tableName);
}
var DataController = class {
  getInitData = async () => {
    return new OK2({
      message: "get all License success!",
      metadata: {
        license: await license_service_default.getCurrentLicense(),
        termOfUse: await termOfUse_service_default.getCurrentTermOfUse(),
        applicationMaster: await applicationMaster_sercvice_default.getOneByBundleId(),
        acsta: await acsta_service_default.getAllByBundleId(),
        performance: await performance_service_default.getAllByBundleId()
      }
    });
  };
  getUpdateData = async (lastSyncDate) => {
    const updatedTables = await getUpdatedTables(lastSyncDate);
    if (!updatedTables.length) {
      return new OK2({
        message: "No updated data",
        metadata: {}
      });
    }
    let updatedData = {};
    return new OK2({
      message: "get updated data success!",
      metadata: {
        license: await license_service_default.getCurrentLicense(),
        termOfUse: await termOfUse_service_default.getCurrentTermOfUse(),
        applicationMaster: await applicationMaster_sercvice_default.getUpdateData(lastSyncDate),
        acsta: await acsta_service_default.getUpdateData(lastSyncDate),
        performance: await performance_service_default.getUpdateData(lastSyncDate)
      }
      // metadata: updatedData,
    });
  };
};
var licenseController2 = new DataController();
var getData_controller_default = licenseController2;

// src/openapi/get-data/index.ts
init_checked_fetch();
init_modules_watch_stub();
var ResponseSchema3 = z.object({
  message: z.string().openapi({ example: "get License success!" }),
  status: z.number().openapi({ example: 200 }),
  reason: z.string().openapi({ example: "OK" }),
  metadata: z.object({
    license: metadata4,
    termOfUse: metadata5,
    applicationMaster: metadata,
    acsta: z.array(metadata2),
    performance: z.array(metadata3)
  })
});
var ParamsSchema6 = z.object({
  lastSyncDate: z.string().openapi({
    param: {
      name: "lastSyncDate",
      in: "path"
    },
    type: "string",
    example: "2021-09-01T00:00:00.000Z",
    description: "The last sync date. Zulu time (GMT)"
  })
});

// src/routes/get-data/index.ts
var app7 = new OpenAPIHono();
app7.openapi(
  createRoute({
    method: "get",
    path: "/init",
    description: "Get intialize data",
    security: securitySchemes,
    request: {
      query: QuerySchemaBundleId,
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchema3
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["Data"]
  }),
  async (c2) => {
    return c2.json(await getData_controller_default.getInitData());
  }
);
app7.openapi(
  createRoute({
    method: "get",
    path: "/updated/{lastSyncDate}",
    description: "Get updated data",
    security: securitySchemes,
    request: {
      params: ParamsSchema6,
      query: QuerySchemaBundleId,
      headers: Authorization
    },
    responses: {
      200: {
        content: {
          "application/json": {
            schema: ResponseSchema3
          }
        },
        description: "Ok Response"
      }
    },
    tags: ["Data"]
  }),
  async (c2) => {
    const lastSyncDate = c2.req.param("lastSyncDate");
    validateDate(lastSyncDate);
    return c2.json(await getData_controller_default.getUpdateData(lastSyncDate));
  }
);
var get_data_default = app7;

// src/routes/index.ts
var app8 = new OpenAPIHono();
app8.route("/application-masters", application_master_default);
app8.route("/acstas", acsta_default);
app8.route("/products", product_default);
app8.route("/terms-of-uses", terms_of_use_default);
app8.route("/licenses", license_default);
app8.route("/update-check", update_check_default);
app8.route("/get-data", get_data_default);
var routes_default = app8;

// src/index.ts
var app9 = new OpenAPIHono();
app9.onError((err2, c2) => {
  return c2.json(
    {
      message: err2.message || "Internal Server Error",
      status: err2.status || 500
    },
    err2?.status || 500
  );
});
app9.openAPIRegistry.registerComponent(
  "securitySchemes",
  "BasicAuth",
  // <- Add security name
  {
    type: "apiKey",
    name: "Authorization",
    in: "header"
  }
);
app9.use(
  globalObject.store((c2) => ({
    USERNAME: c2.env?.USERNAME,
    PASSWORD: c2.env?.PASSWORD
  }))
);
app9.use(
  "/ui",
  createMiddleware(async (c2, next) => {
    return next();
  })
);
app9.use("/ui", swaggerBasicAuth);
app9.use(
  "/doc",
  bearerAuth({
    token: "bearer-token"
  })
);
app9.doc("/doc", {
  info: {
    title: "An API",
    version: "v1"
  },
  openapi: "3.1.0"
});
app9.get(
  "/ui",
  middleware({
    url: "/doc",
    requestInterceptor: `
      request => {
        if (request.url === '/doc') {
          request.headers['authorization'] = \`Bearer bearer-token\`;
        }
        return request;
      }
    `
  })
);
app9.use(basicAuthMiddware);
app9.use(
  globalObject.store((c2) => ({
    bundleId: c2.req.query("bundleId"),
    db: generatePrismaClient(c2.env?.DB),
    s3client: generateS3Client(
      c2.env?.CLOUDFLARE_ACCOUNT_ID,
      c2.env?.CLOUDFLARE_ACCESS_KEY_ID,
      c2.env?.CLOUDFLARE_SECRET_ACCESS_KEY
    ),
    bucketName: c2.env?.CLOUDFLARE_BUCKET_NAME
  }))
);
app9.route("/api/v1", routes_default);
app9.get("/", (c2) => {
  return c2.json({ message: "Acsta API" });
});
var src_default = app9;

// ../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_checked_fetch();
init_modules_watch_stub();
var drainBody = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e2) {
      console.error("Failed to drain the unused request body.", e2);
    }
  }
};
var middleware_ensure_req_body_drained_default = drainBody;

// ../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_checked_fetch();
init_modules_watch_stub();
function reduceError(e2) {
  return {
    name: e2?.name,
    message: e2?.message ?? String(e2),
    stack: e2?.stack,
    cause: e2?.cause === void 0 ? void 0 : reduceError(e2.cause)
  };
}
var jsonError = async (request, env, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env);
  } catch (e2) {
    const error = reduceError(e2);
    return Response.json(error, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
};
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-NyGiPh/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = src_default;

// ../../node_modules/wrangler/templates/middleware/common.ts
init_checked_fetch();
init_modules_watch_stub();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
function __facade_invokeChain__(request, env, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env, ctx, middlewareCtx);
}
function __facade_invoke__(request, env, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}

// .wrangler/tmp/bundle-NyGiPh/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware2 of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware2);
  }
  const fetchDispatcher = function(request, env, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env, ctx);
  };
  return {
    ...worker,
    fetch(request, env, ctx) {
      const dispatcher = function(type, init2) {
        if (type === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init2.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env, ctx);
        }
      };
      return __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);
    }
  };
}
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware2 of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware2);
  }
  return class extends klass {
    #fetchDispatcher = (request, env, ctx) => {
      this.env = env;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    };
    #dispatcher = (type, init2) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init2.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    };
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
/*! Bundled license information:

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

tslib/tslib.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=index.js.map
